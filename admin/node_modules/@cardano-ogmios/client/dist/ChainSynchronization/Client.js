"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPointFromCurrentTip = exports.TipIsOriginError = exports.createChainSynchronizationClient = void 0;
const fastq_1 = __importDefault(require("fastq"));
const ts_custom_error_1 = require("ts-custom-error");
const Connection_1 = require("../Connection");
const util_1 = require("../util");
const findIntersection_1 = require("./findIntersection");
const nextBlock_1 = require("./nextBlock");
async function createChainSynchronizationClient(context, messageHandlers, options) {
    const { socket } = context;
    return new Promise((resolve) => {
        const messageHandler = async (response) => {
            await (0, nextBlock_1.handler)(response, messageHandlers, () => (0, nextBlock_1.nextBlock)(socket));
        };
        const responseHandler = options?.sequential !== false
            ? fastq_1.default.promise(messageHandler, 1).push
            : messageHandler;
        socket.on('message', async (message) => {
            await responseHandler(util_1.safeJSON.parse(message));
        });
        return resolve({
            context,
            shutdown: () => new Promise(resolve => {
                (0, Connection_1.ensureSocketIsOpen)(socket);
                socket.once('close', resolve);
                socket.close();
            }),
            resume: async (points, inFlight) => {
                const intersection = await (0, findIntersection_1.findIntersection)(context, points || [await createPointFromCurrentTip(context)]);
                for (let n = 0; n < (inFlight || 100); n += 1) {
                    (0, nextBlock_1.nextBlock)(socket);
                }
                return intersection;
            }
        });
    });
}
exports.createChainSynchronizationClient = createChainSynchronizationClient;
class TipIsOriginError extends ts_custom_error_1.CustomError {
    constructor() {
        super();
        this.message = 'Unable to produce point as the chain tip is the origin';
    }
}
exports.TipIsOriginError = TipIsOriginError;
async function createPointFromCurrentTip(context) {
    const { tip } = await (0, findIntersection_1.findIntersection)(context, ['origin']);
    if (tip === 'origin') {
        throw new TipIsOriginError();
    }
    return {
        id: tip.id,
        slot: tip.slot
    };
}
exports.createPointFromCurrentTip = createPointFromCurrentTip;
//# sourceMappingURL=Client.js.map