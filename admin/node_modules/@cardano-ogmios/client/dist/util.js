"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.utxoSize = exports.CONSTANT_OUTPUT_SERIALIZATION_OVERHEAD = exports.isBlockPraos = exports.isBlockBFT = exports.isBlockEBB = exports.isObject = exports.eventEmitterToGenerator = exports.safeJSON = void 0;
const bech32_1 = require("bech32");
const JSONBig = require('@cardanosolutions/json-bigint');
exports.safeJSON = {
    $: JSONBig({ useNativeBigInt: true }),
    sanitize(json, parentKey) {
        if (typeof json === 'object' && json !== null) {
            if (json.lovelace !== undefined) {
                return this.sanitizeFields(json, ['lovelace']);
            }
            if (json.ada !== undefined || parentKey === 'mint' || parentKey === 'value') {
                return this.sanitizeAdditionalFields(json, 2);
            }
            if (json.clause === 'some' && json.atLeast !== undefined) {
                this.sanitizeFields(json, ['atLeast']);
                return this.sanitize(json.from, 'from');
            }
            if (parentKey === 'labels') {
                return this.sanitizeMetadatum(json);
            }
            for (const k in json) {
                this.sanitize(json[k], k);
            }
        }
        return json;
    },
    sanitizeFields(json, fields) {
        for (const k in json) {
            const v = json[k];
            if (fields.includes(k)) {
                json[k] = typeof v === 'number' ? BigInt(v) : v;
            }
            else {
                this.sanitize(v, k);
            }
        }
        return json;
    },
    sanitizeAdditionalFields(json, depth) {
        for (const k in json) {
            const v = json[k];
            if (depth > 1) {
                this.sanitizeAdditionalFields(v, depth - 1);
            }
            else {
                json[k] = typeof v === 'number' ? BigInt(v) : v;
            }
        }
        return json;
    },
    sanitizeMetadatum(json) {
        if (typeof json === 'object' && json !== null) {
            for (const k in json) {
                const v = json[k];
                json[k] = typeof v === 'number' ? BigInt(v) : this.sanitizeMetadatum(v);
            }
        }
        return json;
    },
    parse(raw) {
        try {
            return this.sanitize(this.$.parse(raw));
        }
        catch (e) {
            if (e.name === 'SyntaxError' && typeof e.message === 'string' && e.message.includes('forbidden constructor')) {
                const escaped = raw.replace(/"constructor"/g, '"constr"');
                return this.sanitize(this.$.parse(escaped));
            }
            throw e;
        }
    },
    stringify(...args) {
        return this.$.stringify(...args);
    }
};
function eventEmitterToGenerator(eventEmitter, eventName, match) {
    const events = [];
    const listeners = [];
    eventEmitter.on(eventName, async (e) => {
        const matched = match(e);
        if (matched !== null) {
            if (listeners.length > 0) {
                listeners.shift()(matched);
            }
            else {
                events.push(matched);
            }
        }
    });
    return async function* generator() {
        while (true) {
            yield new Promise((resolve) => {
                if (events.length > 0) {
                    resolve(events.shift());
                }
                else {
                    listeners.push(resolve);
                }
            });
        }
    };
}
exports.eventEmitterToGenerator = eventEmitterToGenerator;
const BYRON_ERA = 'byron';
function isObject($) {
    return typeof $ === 'object' && $ !== null;
}
exports.isObject = isObject;
function isBlockEBB(block) {
    return block.era === BYRON_ERA && typeof block.issuer === 'undefined';
}
exports.isBlockEBB = isBlockEBB;
function isBlockBFT(block) {
    return block.era === BYRON_ERA && typeof block.issuer !== 'undefined';
}
exports.isBlockBFT = isBlockBFT;
function isBlockPraos(block) {
    return block.era !== BYRON_ERA;
}
exports.isBlockPraos = isBlockPraos;
exports.CONSTANT_OUTPUT_SERIALIZATION_OVERHEAD = 160;
const utxoSize = (output) => {
    return exports.CONSTANT_OUTPUT_SERIALIZATION_OVERHEAD +
        sizeOfArrayDef(1) +
        sizeOfAddress(output.address) +
        sizeOfValue(output.value) +
        sizeOfInlineDatum(output.datum) +
        sizeOfDatumHash(output.datumHash) +
        sizeOfScript(output.script);
    function sizeOfInteger(n) {
        let size = 0;
        if (n < 24n) {
            size = 1;
        }
        else if (n < 256n) {
            size = 2;
        }
        else if (n < 65536n) {
            size = 3;
        }
        else if (n < 4294967296n) {
            size = 5;
        }
        else {
            size = 9;
        }
        return size;
    }
    function sizeOfBytesDef(n) {
        return sizeOfInteger(BigInt(n));
    }
    function sizeOfArrayDef(n) {
        return n < 24 ? 1 : 2;
    }
    function sizeOfAddress(address) {
        const cborOverhead = 3;
        const payloadSize = bech32_1.bech32.fromWords(bech32_1.bech32.decode(address, 999).words).length;
        return cborOverhead + payloadSize;
    }
    function sizeOfValue(value) {
        const POLICY_ID_SIZE = 28;
        const { ada: { lovelace }, ...assets } = value;
        const lovelaceSize = lovelace >= 4294967296n ? 9 : 5;
        const [assetsSize, policies] = Object.keys(assets).reduce(([total, policies], policyId) => {
            const assetsSize = Object.keys(assets[policyId]).reduce((assetsSize, assetName) => {
                registerAssetId(policies, policyId, assetName);
                const quantitySize = sizeOfInteger(assets[policyId][assetName]);
                const assetNameSize = assetName.length / 2;
                const assetNameOverhead = sizeOfBytesDef(assetNameSize);
                return assetsSize + assetNameSize + assetNameOverhead + quantitySize;
            }, 0);
            const policyIdSize = 2 + POLICY_ID_SIZE;
            return [total + policyIdSize + assetsSize, policies];
        }, [0, new Map()]);
        const policiesOverhead = sizeOfArrayDef(policies.size);
        const assetsOverhead = Array.from(policies).reduce((total, [_, policy]) => {
            return total + sizeOfArrayDef(policy.size);
        }, 0);
        const cborOverhead = 1 + (Object.keys(assets).length === 0 ? 0 : (1 + policiesOverhead + assetsOverhead));
        return cborOverhead + lovelaceSize + assetsSize;
        function registerAssetId(assets, policyId, assetName) {
            let policy = assets.get(policyId);
            if (policy === undefined) {
                policy = new Set();
                policy.add(assetName);
                assets.set(policyId, policy);
                return false;
            }
            else {
                policy.add(assetName);
                return true;
            }
        }
    }
    function sizeOfInlineDatum(datum) {
        if (datum === undefined) {
            return 0;
        }
        const cborOverhead = 5 + sizeOfBytesDef(datum.length);
        const datumSize = datum.length / 2;
        return cborOverhead + datumSize;
    }
    function sizeOfDatumHash(datumHash) {
        if (datumHash === undefined) {
            return 0;
        }
        const cborOverhead = 5;
        const hashDigestSize = datumHash.length / 2;
        return cborOverhead + hashDigestSize;
    }
    function sizeOfScript(script) {
        if (script === undefined) {
            return 0;
        }
        let scriptSize = script.cbor.length / 2;
        if (script.language !== 'native') {
            scriptSize += sizeOfBytesDef(scriptSize);
        }
        scriptSize += 2;
        const cborOverhead = 3 + sizeOfBytesDef(scriptSize);
        return cborOverhead + scriptSize;
    }
};
exports.utxoSize = utxoSize;
//# sourceMappingURL=util.js.map