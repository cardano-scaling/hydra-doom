"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isReleaseLedgerStateResponse = exports.isAcquireLedgerStateSuccess = exports.createLedgerStateQueryClient = void 0;
const Connection_1 = require("../Connection");
const query_1 = require("./query");
async function createLedgerStateQueryClient(context, options) {
    const { socket } = context;
    const client = {
        context,
        async acquireLedgerState(point) {
            return (0, Connection_1.Method)({
                method: 'acquireLedgerState',
                params: { point }
            }, {
                handler: (response, resolve, reject) => {
                    if (isAcquireLedgerStateSuccess(response)) {
                        resolve();
                    }
                    else {
                        reject(response);
                    }
                }
            }, context);
        },
        async releaseLedgerState() {
            return (0, Connection_1.Method)({
                method: 'releaseLedgerState'
            }, {
                handler: (response, resolve, reject) => {
                    if (isReleaseLedgerStateResponse(response)) {
                        resolve();
                    }
                    else {
                        reject(response);
                    }
                }
            }, context);
        },
        constitution() {
            return (0, query_1.constitution)(context);
        },
        epoch() {
            return (0, query_1.epoch)(context);
        },
        eraStart() {
            return (0, query_1.eraStart)(context);
        },
        eraSummaries() {
            return (0, query_1.eraSummaries)(context);
        },
        genesisConfiguration(era) {
            switch (era) {
                case 'byron':
                    return (0, query_1.genesisConfiguration)(context, era);
                case 'shelley':
                    return (0, query_1.genesisConfiguration)(context, era);
                case 'alonzo':
                    return (0, query_1.genesisConfiguration)(context, era);
                case 'conway':
                    return (0, query_1.genesisConfiguration)(context, era);
                default: {
                    const _era = era;
                    return (0, query_1.genesisConfiguration)(context, _era);
                }
            }
        },
        ledgerTip() {
            return (0, query_1.ledgerTip)(context);
        },
        liveStakeDistribution() {
            return (0, query_1.liveStakeDistribution)(context);
        },
        networkBlockHeight() {
            return (0, query_1.networkBlockHeight)(context);
        },
        networkStartTime() {
            return (0, query_1.networkStartTime)(context);
        },
        networkTip() {
            return (0, query_1.networkTip)(context);
        },
        projectedRewards(filter) {
            return (0, query_1.projectedRewards)(context, filter);
        },
        proposedProtocolParameters() {
            return (0, query_1.proposedProtocolParameters)(context);
        },
        protocolParameters() {
            return (0, query_1.protocolParameters)(context);
        },
        rewardAccountSummaries(filter) {
            return (0, query_1.rewardAccountSummaries)(context, filter);
        },
        rewardsProvenance() {
            return (0, query_1.rewardsProvenance)(context);
        },
        stakePools() {
            return (0, query_1.stakePools)(context);
        },
        utxo(filter) {
            return (0, query_1.utxo)(context, filter);
        },
        shutdown() {
            return new Promise(resolve => {
                (0, Connection_1.ensureSocketIsOpen)(socket);
                socket.once('close', resolve);
                socket.close();
            });
        }
    };
    return new Promise((resolve, reject) => {
        if (options?.point !== undefined) {
            client.acquireLedgerState(options.point)
                .then(() => resolve(client))
                .catch(reject);
        }
        else {
            resolve(client);
        }
    });
}
exports.createLedgerStateQueryClient = createLedgerStateQueryClient;
function isAcquireLedgerStateSuccess(response) {
    return response?.result?.acquired === 'ledgerState';
}
exports.isAcquireLedgerStateSuccess = isAcquireLedgerStateSuccess;
function isReleaseLedgerStateResponse(response) {
    return response?.result?.released === 'ledgerState';
}
exports.isReleaseLedgerStateResponse = isReleaseLedgerStateResponse;
//# sourceMappingURL=Client.js.map