"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Method = exports.send = exports.ensureSocketIsOpen = exports.baseRequest = exports.createInteractionContext = exports.createConnectionObject = exports.JSONRPCError = void 0;
const nanoid_1 = require("nanoid");
const IsomorphicWebSocket_1 = require("./IsomorphicWebSocket");
const ServerHealth_1 = require("./ServerHealth");
const util_1 = require("./util");
class JSONRPCError extends Error {
    constructor(code, message, data, id) {
        super(message);
        this.stack = '';
        this.code = code;
        if (typeof data !== 'undefined') {
            this.data = data;
        }
        if (typeof id !== 'undefined') {
            this.id = Object.assign({}, id || {});
        }
    }
    static tryFrom(any) {
        if ('error' in any && 'jsonrpc' in any && any.jsonrpc === '2.0') {
            const { error: e } = any;
            if ('code' in e && 'message' in e) {
                if (Number.isInteger(e.code) && typeof e.message === 'string') {
                    return new JSONRPCError(e.code, e.message, e?.data, any?.id);
                }
            }
        }
        return null;
    }
}
exports.JSONRPCError = JSONRPCError;
function createConnectionObject(config) {
    const _128MB = 128 * 1024 * 1024;
    const base = {
        host: config?.host ?? '127.0.0.1',
        port: config?.port ?? 1337,
        tls: config?.tls ?? false,
        maxPayload: config?.maxPayload ?? _128MB
    };
    const hostAndPort = `${base.host}:${base.port}`;
    return {
        ...base,
        address: {
            http: `${base.tls ? 'https' : 'http'}://${hostAndPort}`,
            webSocket: `${base.tls ? 'wss' : 'ws'}://${hostAndPort}`
        }
    };
}
exports.createConnectionObject = createConnectionObject;
const createInteractionContext = async (errorHandler, closeHandler, options) => {
    const connection = createConnectionObject(options?.connection);
    const health = await (0, ServerHealth_1.getServerHealth)({ connection });
    return new Promise((resolve, reject) => {
        if (health.lastTipUpdate === null) {
            return reject(new ServerHealth_1.ServerNotReady(health));
        }
        const socket = new IsomorphicWebSocket_1.WebSocket(connection.address.webSocket, { maxPayload: connection.maxPayload });
        const onInitialError = (error) => {
            socket.removeAllListeners();
            return reject(error);
        };
        socket.setMaxListeners(options.maxEventListeners || 10);
        socket.on('error', onInitialError);
        socket.once('close', (_code, reason) => {
            socket.removeAllListeners();
            reject(new Error(reason));
        });
        socket.on('open', async () => {
            socket.removeListener('error', onInitialError);
            socket.on('error', errorHandler);
            socket.on('close', closeHandler);
            resolve({
                connection,
                socket
            });
        });
    });
};
exports.createInteractionContext = createInteractionContext;
exports.baseRequest = {
    jsonrpc: '2.0'
};
const ensureSocketIsOpen = (socket) => {
    if (socket.readyState !== socket.OPEN) {
        throw new Error('WebSocket is closed');
    }
};
exports.ensureSocketIsOpen = ensureSocketIsOpen;
const send = async (send, context) => {
    const { socket } = context;
    return new Promise((resolve, reject) => {
        function onUnexpectedClose(code, reason) {
            reject(new JSONRPCError(-32000, 'Connection closed', { code, reason }));
        }
        socket.once('close', onUnexpectedClose);
        send(socket)
            .then(resolve)
            .catch(error => reject(JSONRPCError.tryFrom(error) || error))
            .finally(() => socket.removeListener('close', onUnexpectedClose));
    });
};
exports.send = send;
const Method = (req, res, context) => (0, exports.send)((socket) => new Promise((resolve, reject) => {
    const requestId = (0, nanoid_1.nanoid)(16);
    async function listener(data) {
        const response = util_1.safeJSON.parse(data);
        if (response?.id?.requestId !== requestId) {
            return;
        }
        socket.removeListener('message', listener);
        try {
            const handler = res.handler || ((response, resolve, reject) => {
                if (response.method === req.method && 'result' in response) {
                    resolve(response.result);
                }
                else {
                    reject(response);
                }
            });
            await handler(response, resolve, reject);
        }
        catch (e) {
            return reject(e);
        }
    }
    socket.on('message', listener);
    (0, exports.ensureSocketIsOpen)(socket);
    socket.send(util_1.safeJSON.stringify({
        ...exports.baseRequest,
        method: req.method,
        params: req.params,
        id: { requestId }
    }));
}), context);
exports.Method = Method;
//# sourceMappingURL=Connection.js.map