"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMempoolMonitoringClient = void 0;
const util_1 = require("../util");
const Connection_1 = require("../Connection");
const acquireMempool = __importStar(require("./acquireMempool"));
const hasTransaction = __importStar(require("./hasTransaction"));
const nextTransaction = __importStar(require("./nextTransaction"));
const releaseMempool = __importStar(require("./releaseMempool"));
const sizeOfMempool = __importStar(require("./sizeOfMempool"));
function matchAny(data) {
    const json = util_1.safeJSON.parse(data);
    const methods = [
        'acquireMempool',
        'hasTransaction',
        'nextTransaction',
        'sizeOfMempool',
        'releaseMempool'
    ];
    if (typeof json.id === 'object' && json.id !== null) {
        if ('method' in json.id) {
            if (methods.includes(json.id.method)) {
                return json;
            }
        }
    }
    return null;
}
const createMempoolMonitoringClient = async (context) => {
    const { socket } = context;
    const response = (0, util_1.eventEmitterToGenerator)(socket, 'message', matchAny)();
    return Promise.resolve({
        context,
        acquireMempool: (params) => {
            const method = 'acquireMempool';
            return (0, Connection_1.send)(async (socket) => {
                socket.send(util_1.safeJSON.stringify({
                    ...Connection_1.baseRequest,
                    method,
                    params,
                    id: { method }
                }));
                const { value } = await response.next();
                return new Promise((resolve, reject) => acquireMempool.handler(value, resolve, reject));
            }, context);
        },
        hasTransaction: (id) => {
            const method = 'hasTransaction';
            return (0, Connection_1.send)(async (socket) => {
                socket.send(util_1.safeJSON.stringify({
                    ...Connection_1.baseRequest,
                    method,
                    params: { id },
                    id: { method }
                }));
                const { value } = await response.next();
                return new Promise((resolve, reject) => hasTransaction.handler(value, resolve, reject));
            }, context);
        },
        nextTransaction: (params) => {
            const method = 'nextTransaction';
            return (0, Connection_1.send)(async (socket) => {
                socket.send(util_1.safeJSON.stringify({
                    ...Connection_1.baseRequest,
                    method,
                    params: params || {},
                    id: { method }
                }));
                const { value } = await response.next();
                return new Promise((resolve, reject) => nextTransaction.handler(value, resolve, reject, params));
            }, context);
        },
        sizeOfMempool: (params) => {
            const method = 'sizeOfMempool';
            return (0, Connection_1.send)(async (socket) => {
                socket.send(util_1.safeJSON.stringify({
                    ...Connection_1.baseRequest,
                    method,
                    params,
                    id: { method }
                }));
                const { value } = await response.next();
                return new Promise((resolve, reject) => sizeOfMempool.handler(value, resolve, reject));
            }, context);
        },
        releaseMempool: (params) => {
            const method = 'releaseMempool';
            return (0, Connection_1.send)(async (socket) => {
                socket.send(util_1.safeJSON.stringify({
                    ...Connection_1.baseRequest,
                    method,
                    params,
                    id: { method }
                }));
                const { value } = await response.next();
                return new Promise((resolve, reject) => releaseMempool.handler(value, resolve, reject));
            }, context);
        },
        shutdown: () => new Promise(resolve => {
            (0, Connection_1.ensureSocketIsOpen)(socket);
            socket.once('close', resolve);
            socket.close();
        })
    });
};
exports.createMempoolMonitoringClient = createMempoolMonitoringClient;
//# sourceMappingURL=Client.js.map