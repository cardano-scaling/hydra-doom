import {
  __export,
  assetTypes,
  assets,
  empty,
  intersect,
  makeValue,
  merge,
  negate,
  negatives,
  positives,
  sub,
  value_exports,
  zero
} from "./chunk-47RNDKDB.mjs";

// src/tx.ts
import { Hash28ByteBase16 } from "@blaze-cardano/core";
import {
  CborSet,
  TransactionInput,
  TransactionBody,
  Transaction,
  Value as Value2,
  TransactionOutput,
  PlutusData,
  Redeemers,
  Redeemer,
  RedeemerPurpose,
  Address,
  Ed25519PublicKeyHex,
  Credential,
  CredentialType,
  Ed25519SignatureHex,
  PlutusLanguageVersion,
  TransactionWitnessSet,
  AssetId,
  NativeScript,
  PlutusV1Script,
  PlutusV2Script,
  PlutusV3Script,
  VkeyWitness,
  Costmdls,
  CostModel,
  Hash,
  HashAsPubKeyHex,
  PolicyIdToHash,
  getPaymentAddress,
  Certificate,
  StakeDelegation,
  CertificateType,
  blake2b_256 as blake2b_2562,
  RedeemerTag,
  StakeRegistration,
  getBurnAddress,
  setInConwayEra
} from "@blaze-cardano/core";

// src/coinSelection.ts
import { Value, UTxOSelectionError } from "@blaze-cardano/core";
function wideSelection(inputs, dearth) {
  const availableInputs = [...inputs];
  const selectedInputs = [];
  let acc = new Value(0n);
  for (let j = 0; j < 30; j++) {
    const diff = sub(dearth, acc);
    const goal = positives(diff);
    if (assetTypes(goal) <= 1) {
      break;
    } else {
      let bestStep = [0, new Value(0n), -1];
      for (let i = 0; i < availableInputs.length; i += 1) {
        const iValue = availableInputs[i].output().amount();
        const iImprove = positives(sub(goal, iValue));
        const iIntersect = intersect(goal, iValue);
        const rating = assetTypes(goal) - assetTypes(iImprove) + iIntersect / 10;
        if (rating > bestStep[0]) {
          bestStep = [rating, iValue, i];
        }
      }
      if (bestStep[2] == -1) {
        throw new UTxOSelectionError(
          "wide",
          dearth,
          availableInputs,
          selectedInputs,
          bestStep
        );
      }
      selectedInputs.push(...availableInputs.splice(bestStep[2], 1));
      acc = merge(acc, bestStep[1]);
    }
  }
  return { selectedInputs, selectedValue: acc, inputs: availableInputs };
}
function deepSelection(inputs, dearth) {
  const availableInputs = [...inputs];
  const selectedInputs = [];
  let acc = new Value(0n);
  for (let j = 0; j < 30; j++) {
    const diff = sub(dearth, acc);
    const goal = positives(diff);
    if (assetTypes(goal) == 0) {
      break;
    } else {
      const searchAsset = assets(goal)[0];
      let bestStep = [0n, new Value(0n), -1];
      for (let i = 0; i < availableInputs.length; i += 1) {
        const iValue = availableInputs[i].output().amount();
        let rating;
        if (searchAsset == "lovelace") {
          rating = iValue.coin();
        } else {
          rating = iValue.multiasset()?.get(searchAsset) ?? 0n;
        }
        if (rating > bestStep[0]) {
          bestStep = [rating, iValue, i];
        }
      }
      if (bestStep[2] == -1) {
        throw new UTxOSelectionError(
          "deep",
          dearth,
          availableInputs,
          selectedInputs,
          bestStep
        );
      }
      selectedInputs.push(...availableInputs.splice(bestStep[2], 1));
      acc = merge(acc, bestStep[1]);
    }
  }
  return { selectedInputs, selectedValue: acc, inputs: availableInputs };
}
function micahsSelector(inputs, dearth) {
  const wideResult = wideSelection(inputs, dearth);
  const remainingDearth = positives(
    sub(dearth, wideResult.selectedValue)
  );
  const deepResult = deepSelection(wideResult.inputs, remainingDearth);
  const finalDearth = positives(
    sub(remainingDearth, deepResult.selectedValue)
  );
  const selectedInputs = [
    ...wideResult.selectedInputs,
    ...deepResult.selectedInputs
  ];
  if (!empty(finalDearth)) {
    throw new UTxOSelectionError("final", finalDearth, inputs, selectedInputs);
  }
  return {
    selectedInputs,
    selectedValue: merge(
      wideResult.selectedValue,
      deepResult.selectedValue
    ),
    inputs: deepResult.inputs
  };
}

// src/utils.ts
import {
  blake2b_256,
  CborReader,
  CborWriter
} from "@blaze-cardano/core";
function getScriptSize(script) {
  const cborReader = new CborReader(script.toCbor());
  cborReader.readStartArray();
  cborReader.readInt();
  return cborReader.readByteString().length;
}
function calculateReferenceScriptFee(refScripts, params) {
  let referenceScriptSize = refScripts.reduce(
    (acc, refScript) => acc + getScriptSize(refScript),
    0
  );
  const { base, multiplier, range } = params.minFeeReferenceScripts;
  let baseFee = base;
  let refFee = 0;
  while (referenceScriptSize > 0) {
    refFee += Math.min(range, referenceScriptSize) * baseFee;
    referenceScriptSize -= range;
    baseFee *= multiplier;
  }
  return refFee;
}
function computeScriptData(redeemers, datums, usedCostModels) {
  const writeDatums = datums && (datums?.size() ?? 0) > 0;
  if (redeemers.size() == 0 && !writeDatums) {
    return void 0;
  }
  const redeemersEncoded = Buffer.from(redeemers.toCbor(), "hex");
  const datumsEncoded = writeDatums ? Buffer.from(datums.toCbor(), "hex") : void 0;
  const costModelsEncoded = Buffer.from(
    usedCostModels.languageViewsEncoding(),
    "hex"
  );
  const writer = new CborWriter();
  writer.writeEncodedValue(redeemersEncoded);
  if (writeDatums) {
    writer.writeEncodedValue(datumsEncoded);
  }
  writer.writeEncodedValue(costModelsEncoded);
  const hashedData = writer.encodeAsHex();
  const scriptDataHash = blake2b_256(hashedData);
  return {
    redeemersEncoded: redeemersEncoded.toString("hex"),
    datumsEncoded: writeDatums ? datumsEncoded.toString("hex") : void 0,
    costModelsEncoded: costModelsEncoded.toString("hex"),
    hashedData,
    scriptDataHash
  };
}

// src/tx.ts
var TxBuilder = class {
  /**
   * Constructs a new instance of the TxBuilder class.
   * Initializes a new transaction body with an empty set of inputs, outputs, and no fee.
   */
  constructor(params) {
    this.preCompleteHooks = [];
    this.redeemers = Redeemers.fromCore([]);
    // A collection of redeemers for script validation.
    this.utxos = /* @__PURE__ */ new Set();
    // A set of unspent transaction outputs.
    this.utxoScope = /* @__PURE__ */ new Set();
    // A scoped set of UTxOs for the transaction.
    this.collateralUtxos = /* @__PURE__ */ new Set();
    // A set of unspent transaction outputs specifically reserved for collateral, if any.
    this.scriptScope = /* @__PURE__ */ new Set();
    // A set of scripts included in the transaction.
    this.scriptSeen = /* @__PURE__ */ new Set();
    // The index of the change output in the transaction.
    this.plutusData = /* @__PURE__ */ new Set();
    // A set of Plutus data for witness purposes.
    this.requiredWitnesses = /* @__PURE__ */ new Set();
    // A set of public keys required for witnessing the transaction.
    this.requiredNativeScripts = /* @__PURE__ */ new Set();
    // A set of native script hashes required by the transaction.
    this.requiredPlutusScripts = /* @__PURE__ */ new Set();
    // A set of Plutus script hashes required by the transaction.
    this.usedLanguages = {
      [0]: false,
      // Indicates whether Plutus V1 is used.
      [1]: false,
      // Indicates whether Plutus V2 is used.
      [2]: false
      // Indicates whether Plutus V3 is used.
    };
    this.extraneousDatums = /* @__PURE__ */ new Set();
    // A set of extraneous Plutus data not directly used in the transaction.
    this.fee = 0n;
    // The fee for the transaction.
    this.additionalSigners = 0;
    this.consumedMintHashes = [];
    this.consumedWithdrawalHashes = [];
    this.consumedSpendInputs = [];
    this.minimumFee = 0n;
    // minimum fee for the transaction, in lovelace. For script eval purposes!
    this.feePadding = 0n;
    // A padding to add onto the fee; use only in emergencies, and open a ticket so we can fix the fee calculation please!
    this.coinSelector = micahsSelector;
    setInConwayEra(true);
    this.params = params;
    this.body = new TransactionBody(
      CborSet.fromCore([], TransactionInput.fromCore),
      [],
      0n,
      void 0
    );
  }
  get burnAddress() {
    if (!this._burnAddress) {
      this._burnAddress = getBurnAddress(this.networkId);
    }
    return this._burnAddress;
  }
  insertSorted(arr, el) {
    const index = arr.findIndex((x) => x.localeCompare(el) > 0);
    if (index == -1) {
      arr.push(el);
    } else {
      arr.splice(index, 0, el);
    }
    return index == -1 ? arr.length - 1 : index;
  }
  /**
   * Sets the change address for the transaction.
   * This address will receive any remaining funds not allocated to outputs or fees.
   *
   * @param {Address} address - The address to receive the change.
   * @param {boolean} [override=true] - Whether to override the change address if one is already set.
   * @returns {TxBuilder} The same transaction builder
   */
  setChangeAddress(address, override = true) {
    if (override || !this.changeAddress) {
      this.changeAddress = address;
    }
    return this;
  }
  /**
   * Sets the collateral change address for the transaction.
   * This address will receive the collateral change if there is any.
   *
   * @param {Address} address - The address to receive the collateral change.
   * @returns {TxBuilder} The same transaction builder
   */
  setCollateralChangeAddress(address) {
    this.collateralChangeAddress = address;
    return this;
  }
  /**
   * Sets the reward address for the transaction.
   * This address will be used for delegation purposes and also stake key component of the transaction.
   *
   * @param {Address} address - The reward address
   * @returns {TxBuilder} The same transaction builder
   */
  setRewardAddress(address) {
    this.rewardAddress = address;
    return this;
  }
  /**
   * Sets the evaluator for the transaction builder.
   * The evaluator is used to execute Plutus scripts during transaction building.
   *
   * @param {Evaluator} evaluator - The evaluator to be used for script execution.
   * @param {boolean} [override=true] - Whether to override the evaluator if one is already set.
   * @returns {TxBuilder} The same transaction builder
   */
  useEvaluator(evaluator, override = true) {
    if (override || !this.evaluator) {
      this.evaluator = evaluator;
    }
    return this;
  }
  /**
   * Sets a custom coin selector function for the transaction builder.
   * This function will be used to select inputs during the transaction building process.
   *
   * @param {(inputs: TransactionUnspentOutput[], dearth: Value): SelectionResult} selector - The coin selector function to use.
   * @returns {TxBuilder} The same transaction builder
   */
  useCoinSelector(selector) {
    this.coinSelector = selector;
    return this;
  }
  /**
   * Sets the network ID for the transaction builder.
   * The network ID is used to determine which network the transaction is intended for.
   *
   * @param {NetworkId} networkId - The network ID to set.
   * @returns {TxBuilder} The same transaction builder
   */
  setNetworkId(networkId) {
    this.networkId = networkId;
    return this;
  }
  /**
   * The additional signers field is used to add additional signing counts for fee calculation.
   * These will be included in the signing phase at a later stage.
   * This is needed due to native scripts signees being non-deterministic.
   * @param {number} amount - The amount of additional signers
   * @returns {TxBuilder} The same transaction builder
   */
  addAdditionalSigners(amount) {
    this.additionalSigners += amount;
    return this;
  }
  /**
   * Sets the minimum fee for the transaction.
   * This fee will be used during the transaction building process.
   *
   * @param {bigint} fee - The minimum fee to be set.
   * @returns {TxBuilder} The same transaction builder
   */
  setMinimumFee(fee) {
    this.minimumFee = fee;
    return this;
  }
  /**
   * Sets an additional padding to add onto the transactions.
   * Use this only in emergencies, and please open a ticket at https://github.com/butaneprotocol/blaze-cardano so we can correct the fee calculation!
   *
   * @param {bigint} pad - The padding to add onto the transaction fee
   * @returns {TxBuilder} the same transaction builder
   */
  setFeePadding(pad) {
    this.feePadding = pad;
    return this;
  }
  /**
   * Adds a reference input to the transaction. Reference inputs are used to refer to outputs from previous transactions
   * without spending them, allowing scripts to read their data. This can be useful for various contract logic, such as
   * checking the state of a datum without consuming the UTxO that holds it.
   *
   * @param {TransactionUnspentOutput} utxo - The unspent transaction output to add as a reference input.
   * @returns {TxBuilder} The same transaction builder
   * @throws {Error} If the input to be added is already present in the list of reference inputs, to prevent duplicates.
   */
  addReferenceInput(utxo) {
    const referenceInputs = this.body.referenceInputs() ?? CborSet.fromCore([], TransactionInput.fromCore);
    const values = [...referenceInputs.values()];
    if (values.find(
      (val) => val.index() == utxo.input().index() && val.transactionId() == utxo.input().transactionId()
    )) {
      throw new Error(
        "Cannot add duplicate reference input to the transaction"
      );
    }
    values.push(utxo.input());
    referenceInputs.setValues(values);
    this.utxoScope.add(utxo);
    const scriptRef = utxo.output().scriptRef();
    if (scriptRef) {
      this.scriptScope.add(scriptRef);
      this.scriptSeen.add(scriptRef.hash());
    }
    this.body.setReferenceInputs(referenceInputs);
    return this;
  }
  /**
   * Adds an input to the transaction. This method is responsible for including a new input, which represents
   * a reference to an unspent transaction output (UTxO) that will be consumed by the transaction. Optionally,
   * a redeemer and an unhashed datum can be provided for script validation purposes.
   *
   * @param {TransactionUnspentOutput} utxo - The UTxO to be consumed as an input.
   * @param {PlutusData} [redeemer] - Optional. The redeemer data for script validation, required for spending Plutus script-locked UTxOs.
   * @param {PlutusData} [unhashDatum] - Optional. The unhashed datum, required if the UTxO being spent includes a datum hash instead of inline datum.
   * @returns {TxBuilder} The same transaction builder
   * @throws {Error} If attempting to add a duplicate input, if the UTxO payment key is missing, if attempting to spend with a redeemer for a KeyHash credential,
   *                 if attempting to spend without a datum when required, or if providing both an inline datum and an unhashed datum.
   */
  addInput(utxo, redeemer, unhashDatum) {
    const inputs = this.body.inputs();
    const values = [...inputs.values()];
    if (values.find(
      (val) => val.index() == utxo.input().index() && val.transactionId() == utxo.input().transactionId()
    )) {
      throw new Error("Cannot add duplicate input to the transaction");
    }
    values.push(utxo.input());
    inputs.setValues(values);
    this.utxoScope.add(utxo);
    this.body.setInputs(inputs);
    const oref = utxo.input().transactionId() + utxo.input().index().toString();
    const insertIdx = this.insertSorted(this.consumedSpendInputs, oref);
    const redeemers = [...this.redeemers.values()];
    for (const redeemer2 of redeemers) {
      if (redeemer2.tag() == RedeemerTag.Spend && redeemer2.index() >= BigInt(insertIdx)) {
        redeemer2.setIndex(redeemer2.index() + 1n);
      }
    }
    const key = utxo.output().address().getProps().paymentPart;
    if (!key) {
      throw new Error("addInput: Somehow the UTxO payment key is missing!");
    }
    if (redeemer !== void 0) {
      if (key.type == CredentialType.KeyHash) {
        throw new Error(
          "addInput: Cannot spend with redeemer for KeyHash credential!"
        );
      }
      this.requiredPlutusScripts.add(key.hash);
      const datum = utxo.output().datum();
      if (!datum) {
        throw new Error(
          "addInput: Cannot spend with redeemer when datum is missing!"
        );
      }
      if (datum?.asInlineData() && unhashDatum) {
        throw new Error(
          "addInput: Cannot have inline datum and also provided datum (3rd arg)."
        );
      }
      if (datum?.asDataHash()) {
        if (!unhashDatum) {
          throw new Error(
            "addInput: When spending datum hash, must provide datum (3rd arg)."
          );
        }
        this.plutusData.add(unhashDatum);
      }
      redeemers.push(
        Redeemer.fromCore({
          index: insertIdx,
          purpose: RedeemerPurpose["spend"],
          data: redeemer.toCore(),
          executionUnits: {
            memory: this.params.maxExecutionUnitsPerTransaction.memory,
            steps: this.params.maxExecutionUnitsPerTransaction.steps
          }
        })
      );
      this.redeemers.setValues(redeemers);
    } else {
      if (key.type == CredentialType.ScriptHash) {
        this.requiredNativeScripts.add(key.hash);
      } else {
        this.requiredWitnesses.add(HashAsPubKeyHex(key.hash));
      }
    }
    const scriptRef = utxo.output().scriptRef();
    if (scriptRef) {
      this.scriptScope.add(scriptRef);
      this.scriptSeen.add(scriptRef.hash());
    }
    return this;
  }
  /**
   * Adds unspent transaction outputs (UTxOs) to the set of UTxOs available for this transaction.
   * These UTxOs can then be used for balancing the transaction, ensuring that inputs and outputs are equal.
   *
   * @param {TransactionUnspentOutput[]} utxos - The unspent transaction outputs to add.
   * @returns {TxBuilder} The same transaction builder
   */
  addUnspentOutputs(utxos) {
    for (const utxo of utxos) {
      this.utxos.add(utxo);
    }
    return this;
  }
  /**
   * Adds unspent transaction outputs (UTxOs) to the set of collateral UTxOs available for this transaction.
   * These UTxOs can then be used to provide collateral for the transaction, if necessary. If provided, they will b
   * If there are specific, valid collateral UTxOs provided, Blaze will use them before using any other UTxO.
   *
   * @param {TransactionUnspentOutput[]} utxos - the UTxOs to add as collateral
   * @returns {TxBuilder} The same transaction builder
   */
  provideCollateral(utxos) {
    for (const utxo of utxos) {
      this.collateralUtxos.add(utxo);
    }
    return this;
  }
  /**
   * Adds minting information to the transaction. This includes specifying the policy under which assets are minted,
   * the assets to be minted, and an optional redeemer for Plutus scripts.
   *
   * @param {PolicyId} policy - The policy ID under which the assets are minted.
   * @param {Map<AssetName, bigint>} assets - A map of asset names to the amounts being minted.
   * @param {PlutusData} [redeemer] - Optional. A redeemer to be used if the minting policy requires Plutus script validation.
   */
  addMint(policy, assets2, redeemer) {
    const insertIdx = this.insertSorted(
      this.consumedMintHashes,
      PolicyIdToHash(policy)
    );
    const mint = this.body.mint() ?? /* @__PURE__ */ new Map();
    for (const asset of mint.keys()) {
      if (AssetId.getPolicyId(asset) == policy) {
        throw new Error("addMint: Duplicate policy!");
      }
    }
    for (const [key, amount] of assets2.entries()) {
      mint.set(AssetId.fromParts(policy, key), amount);
    }
    this.body.setMint(mint);
    if (redeemer) {
      this.requiredPlutusScripts.add(PolicyIdToHash(policy));
      const redeemers = [...this.redeemers.values()];
      for (const redeemer2 of redeemers) {
        if (redeemer2.tag() == RedeemerTag.Mint && redeemer2.index() >= BigInt(insertIdx)) {
          redeemer2.setIndex(redeemer2.index() + 1n);
        }
      }
      redeemers.push(
        Redeemer.fromCore({
          index: insertIdx,
          purpose: RedeemerPurpose["mint"],
          // Specify the purpose of the redeemer as minting.
          data: redeemer.toCore(),
          // Convert the provided PlutusData redeemer to its core representation.
          executionUnits: {
            memory: this.params.maxExecutionUnitsPerTransaction.memory,
            // Placeholder memory units, replace with actual estimation.
            steps: this.params.maxExecutionUnitsPerTransaction.steps
            // Placeholder step units, replace with actual estimation.
          }
        })
      );
      this.redeemers.setValues(redeemers);
    } else {
      this.requiredNativeScripts.add(PolicyIdToHash(policy));
    }
    return this;
  }
  /**
   * This methods calculates the minimum ada required for a transaction output.
   * @param {TransactionOutput} output - The transaction output to calculate the minimum ada for.
   * @returns {bigint} The minimum ada required for the output.
   */
  calculateMinAda(output) {
    const byteLength = BigInt(output.toCbor().length / 2);
    return BigInt(this.params.coinsPerUtxoByte) * (byteLength + 160n);
  }
  /**
   * This method checks and alters the output of a transaction.
   * It ensures that the output meets the minimum ada requirements and does not exceed the maximum value size.
   *
   * @param {TransactionOutput} output - The transaction output to be checked and altered.
   * @returns {TransactionOutput} The altered transaction output.
   * @throws {Error} If the output does not meet the minimum ada requirements or exceeds the maximum value size.
   */
  checkAndAlterOutput(output) {
    {
      let minAda = this.calculateMinAda(output);
      let coin = output.amount().coin();
      while (coin < minAda) {
        const amount = output.amount();
        amount.setCoin(minAda);
        const datum = output.datum();
        const scriptRef = output.scriptRef();
        output = new TransactionOutput(output.address(), amount);
        if (datum) {
          output.setDatum(datum);
        }
        if (scriptRef) {
          output.setScriptRef(scriptRef);
        }
        minAda = this.calculateMinAda(output);
        coin = output.amount().coin();
      }
    }
    const byteLength = BigInt(output.toCbor().length / 2);
    if (output.amount().coin() < BigInt(this.params.coinsPerUtxoByte) * (byteLength + 160n)) {
      throw new Error("addOutput: Failed due to min ada!");
    }
    const valueByteLength = output.amount().toCbor().length / 2;
    if (valueByteLength > this.params.maxValueSize) {
      throw new Error("addOutput: Failed due to max value size!");
    }
    return output;
  }
  /**
   * Adds a transaction output to the current transaction body. This method also ensures that the minimum ada
   * requirements are met for the output. After adding the output, it updates the transaction body's outputs.
   * It also checks if the output value exceeds the maximum value size.
   *
   * @param {TransactionOutput} output - The transaction output to be added.
   * @returns {TxBuilder} The same transaction builder
   */
  addOutput(output) {
    output = this.checkAndAlterOutput(output);
    const outputs = this.body.outputs();
    outputs.push(output);
    this.body.setOutputs(outputs);
    return this;
  }
  /**
   * Returns the number of transaction outputs in the current transaction body.
   *
   * @returns {number} The number of transaction outputs.
   */
  get outputsCount() {
    return this.body.outputs().length;
  }
  /**
   * Adds a payment in lovelace to the transaction output.
   * This method ensures that the address is valid and the payment is added to the transaction output.
   *
   * @param {Address} address - The address to send the payment to.
   * @param {bigint} lovelace - The amount of lovelace to send.
   * @param {Datum} [datum] - Optional datum to be associated with the paid assets.
   * @returns {TxBuilder} The same transaction builder
   */
  payLovelace(address, lovelace, datum) {
    assertPaymentsAddress(address);
    const paymentAddress = getPaymentAddress(address);
    const datumData = typeof datum == "object" ? datum.toCore() : void 0;
    const datumHash = typeof datum == "string" ? datum : void 0;
    this.addOutput(
      TransactionOutput.fromCore({
        address: paymentAddress,
        value: { coins: lovelace },
        datum: datumData,
        datumHash
      })
    );
    return this;
  }
  /**
   * Adds a payment in assets to the transaction output.
   * This method ensures that the address is valid and the payment is added to the transaction output.
   *
   * @param {Address} address - The address to send the payment to.
   * @param {Value} value - The value of the assets to send.
   * @param {Datum} [datum] - Optional datum to be associated with the paid assets.
   * @returns {TxBuilder} The same transaction builder
   */
  payAssets(address, value, datum) {
    assertPaymentsAddress(address);
    const paymentAddress = getPaymentAddress(address);
    const datumData = typeof datum == "object" ? datum.toCore() : void 0;
    const datumHash = typeof datum == "string" ? datum : void 0;
    this.addOutput(
      TransactionOutput.fromCore({
        address: paymentAddress,
        value: value.toCore(),
        datum: datumData,
        datumHash
      })
    );
    return this;
  }
  /**
   * Locks a specified amount of lovelace to a script.
   * The difference between 'pay' and 'lock' is that you pay to a public key/user,
   * and you lock at a script.
   * This method ensures that the address is valid and the lovelace is locked to the script.
   *
   * @param {Address} address - The address to lock the lovelace to.
   * @param {bigint} lovelace - The amount of lovelace to lock.
   * @param {Datum} datum - The datum to be associated with the locked lovelace.
   * @param {Script} scriptReference - The reference to the script to lock the lovelace to.
   * @returns {TxBuilder} The same transaction builder
   */
  lockLovelace(address, lovelace, datum, scriptReference) {
    return this.lockAssets(
      address,
      new Value2(lovelace),
      datum,
      scriptReference
    );
  }
  /**
   * Locks a specified amount of assets to a script.
   * The difference between 'pay' and 'lock' is that you pay to a public key/user,
   * and you lock at a script.
   * This method ensures that the address is valid and the assets are locked to the script.
   *
   * @param {Address} address - The address to lock the assets to.
   * @param {Value} value - The value of the assets to lock.
   * @param {Datum} datum - The datum to be associated with the locked assets.
   * @param {Script} scriptReference - The reference to the script to lock the assets to.
   * @returns {TxBuilder} The same transaction builder
   */
  lockAssets(address, value, datum, scriptReference) {
    const datumData = typeof datum == "object" ? datum.toCore() : void 0;
    const datumHash = typeof datum == "string" ? datum : void 0;
    assertLockAddress(address);
    const paymentAddress = getPaymentAddress(address);
    return this.addOutput(
      TransactionOutput.fromCore({
        address: paymentAddress,
        value: value.toCore(),
        datum: datumData,
        datumHash,
        scriptReference: scriptReference?.toCore()
      })
    );
  }
  /**
   * Deploys a script by creating a new UTxO with the script as its reference.
   *
   * @param {Script} script - The script to be deployed.
   * @param {Address} [address] - The address to lock the script to. Defaults to a burn address where the UTxO will be unspendable.
   * @returns {TxBuilder} The same transaction builder.
   *
   *
   * @example
   * ```typescript
   * const myScript = Script.newPlutusV2Script(new PlutusV2Script("..."));
   * txBuilder.deployScript(myScript);
   * // or
   * txBuilder.deployScript(myScript, someAddress);
   * ```
   */
  deployScript(script, address = this.burnAddress) {
    const out = new TransactionOutput(address, new Value2(0n));
    out.setScriptRef(script);
    out.amount().setCoin(this.calculateMinAda(out));
    this.addOutput(out);
    return this;
  }
  /**
   * Adds a Plutus datum to the transaction. This datum is not directly associated with any particular output but may be used
   * by scripts during transaction validation. This method is useful for including additional information that scripts may
   * need to validate the transaction without requiring it to be attached to a specific output.
   *
   * @param {PlutusData} datum - The Plutus datum to be added to the transaction.
   * @returns {TxBuilder} The same transaction builder
   */
  provideDatum(datum) {
    this.extraneousDatums.add(datum);
    return this;
  }
  /**
   * Evaluates the scripts for the given draft transaction and calculates the execution units and fees required.
   * This function iterates over all UTXOs within the transaction's scope, simulates the execution of associated scripts,
   * and aggregates the execution units. It then calculates the total fee based on the execution units and updates the
   * transaction's redeemers with the new execution units.
   *
   * @param {Transaction} draft_tx - The draft transaction to evaluate.
   * @returns {Promise<bigint>} The total fee calculated based on the execution units of the scripts.
   */
  async evaluate(draft_tx) {
    const allUtxos = Array.from(
      this.utxoScope.values()
    );
    const redeemers = await this.evaluator(draft_tx, allUtxos);
    let fee = 0;
    for (const redeemer of redeemers.values()) {
      const exUnits = redeemer.exUnits();
      fee += this.params.prices.memory * Number(exUnits.mem());
      fee += this.params.prices.steps * Number(exUnits.steps());
    }
    this.redeemers = redeemers;
    return BigInt(Math.ceil(fee));
  }
  /**
   * Builds the transaction witness set required for the transaction.
   * This includes collecting all necessary scripts (native, Plutus V1, V2, V3),
   * vkey witnesses, redeemers, and Plutus data required for script validation.
   * It organizes these components into a structured format that can be
   * serialized and included in the transaction.
   *
   * @returns {TransactionWitnessSet} A constructed transaction witness set.
   * @throws {Error} If a required script cannot be resolved by its hash.
   */
  buildTransactionWitnessSet() {
    const tw = new TransactionWitnessSet();
    const scriptLookup = {};
    for (const script of this.scriptScope) {
      scriptLookup[script.hash()] = script;
    }
    const sn = [];
    const s1 = [];
    const s2 = [];
    const s3 = [];
    for (const requiredScriptHash of this.requiredPlutusScripts) {
      if (!this.scriptSeen.has(requiredScriptHash)) {
        const script = scriptLookup[requiredScriptHash];
        if (!script) {
          throw new Error(
            `complete: Could not resolve script hash ${requiredScriptHash}`
          );
        } else {
          if (script.asNative() != void 0) {
            sn.push(script.asNative());
          }
          if (script.asPlutusV1() != void 0) {
            s1.push(script.asPlutusV1());
          }
          if (script.asPlutusV2() != void 0) {
            s2.push(script.asPlutusV2());
          }
          if (script.asPlutusV3() != void 0) {
            s3.push(script.asPlutusV3());
          }
        }
      }
      const lang = scriptLookup[requiredScriptHash]?.language();
      if (lang == 1) {
        this.usedLanguages[PlutusLanguageVersion.V1] = true;
      } else if (lang == 2) {
        this.usedLanguages[PlutusLanguageVersion.V2] = true;
      } else if (lang == 3) {
        this.usedLanguages[PlutusLanguageVersion.V3] = true;
      } else if (!lang) {
        throw new Error(
          "buildTransactionWitnessSet: lang script lookup failed"
        );
      }
    }
    for (const requiredScriptHash of this.requiredNativeScripts) {
      if (!this.scriptSeen.has(requiredScriptHash)) {
        const script = scriptLookup[requiredScriptHash];
        if (!script) {
          throw new Error(
            `complete: Could not resolve script hash ${requiredScriptHash}`
          );
        } else {
          if (script.asNative() != void 0) {
            sn.push(script.asNative());
          } else {
            throw new Error(
              "complete: Could not resolve script hash (was not native script)"
            );
          }
        }
      }
    }
    if (sn.length != 0) {
      const cborSet = CborSet.fromCore([], NativeScript.fromCore);
      cborSet.setValues(sn);
      tw.setNativeScripts(cborSet);
    }
    if (s1.length != 0) {
      const cborSet = CborSet.fromCore([], PlutusV1Script.fromCore);
      cborSet.setValues(s1);
      tw.setPlutusV1Scripts(cborSet);
    }
    if (s2.length != 0) {
      const cborSet = CborSet.fromCore([], PlutusV2Script.fromCore);
      cborSet.setValues(s2);
      tw.setPlutusV2Scripts(cborSet);
    }
    if (s3.length != 0) {
      const cborSet = CborSet.fromCore([], PlutusV3Script.fromCore);
      cborSet.setValues(s3);
      tw.setPlutusV3Scripts(cborSet);
    }
    const requiredWitnesses = Array.from(
      { length: this.requiredWitnesses.size + this.additionalSigners },
      (_, i) => [
        Ed25519PublicKeyHex(i.toString(16).padStart(64, "0")),
        Ed25519SignatureHex(i.toString(16).padStart(128, "0"))
      ]
    );
    tw.setVkeys(CborSet.fromCore(requiredWitnesses, VkeyWitness.fromCore));
    tw.setRedeemers(this.redeemers);
    const plutusData = CborSet.fromCore([], PlutusData.fromCore);
    const plutusDataList = [];
    for (const p of this.plutusData.values()) {
      plutusDataList.push(p);
    }
    for (const p of this.extraneousDatums.values()) {
      plutusDataList.push(p);
    }
    plutusData.setValues(plutusDataList);
    tw.setPlutusData(plutusData);
    return tw;
  }
  /**
   * Calculates the net value difference between the inputs and outputs of a transaction,
   * including minted values, withdrawals, and subtracting a fixed fee amount.
   * This function is used to determine the excess value that needs to be returned as change.
   *
   * @returns {Value} The net value that represents the transaction's pitch.
   * @throws {Error} If a corresponding UTxO for an input cannot be found.
   */
  getPitch(spareAmount = 0n) {
    let withdrawalAmount = 0n;
    const withdrawals = this.body.withdrawals();
    if (withdrawals !== void 0) {
      for (const account of withdrawals.keys()) {
        withdrawalAmount += withdrawals.get(account);
      }
    }
    let inputValue = new Value2(withdrawalAmount);
    let outputValue = new Value2(bigintMax(this.fee, this.minimumFee));
    const mintValue = new Value2(0n, this.body.mint());
    for (const input of this.body.inputs().values()) {
      let utxo;
      for (const iterUtxo of this.utxoScope.values()) {
        if (iterUtxo.input().transactionId() == input.transactionId() && iterUtxo.input().index() == input.index()) {
          utxo = iterUtxo;
        }
      }
      if (!utxo) {
        throw new Error("Unreachable! UTxO missing!");
      }
      inputValue = merge(inputValue, utxo.output().amount());
    }
    for (const output of this.body.outputs().values()) {
      outputValue = merge(outputValue, output.amount());
    }
    for (const cert of this.body.certs()?.values() || []) {
      switch (cert.kind()) {
        case 0:
          outputValue = merge(
            outputValue,
            new Value2(BigInt(this.params.stakeKeyDeposit))
          );
          break;
        case 1:
          inputValue = merge(
            inputValue,
            new Value2(BigInt(this.params.stakeKeyDeposit))
          );
          break;
        case 3:
          if (this.params.poolDeposit) {
            outputValue = merge(
              outputValue,
              new Value2(BigInt(this.params.poolDeposit))
            );
          }
          break;
        case 4:
          if (this.params.poolDeposit) {
            inputValue = merge(
              inputValue,
              new Value2(BigInt(this.params.poolDeposit))
            );
          }
          break;
      }
    }
    const tilt = merge(
      merge(inputValue, negate(outputValue)),
      mintValue
    );
    if (spareAmount != 0n) {
      return merge(tilt, new Value2(-spareAmount));
    }
    if (this.changeOutputIndex !== void 0) {
      return merge(
        tilt,
        this.body.outputs()[this.changeOutputIndex].amount()
      );
    }
    return tilt;
  }
  balanced() {
    let withdrawalAmount = 0n;
    const withdrawals = this.body.withdrawals();
    if (withdrawals !== void 0) {
      for (const account of withdrawals.keys()) {
        withdrawalAmount += withdrawals.get(account);
      }
    }
    let inputValue = new Value2(withdrawalAmount);
    let outputValue = new Value2(bigintMax(this.fee, this.minimumFee));
    const mintValue = new Value2(0n, this.body.mint());
    for (const input of this.body.inputs().values()) {
      let utxo;
      for (const iterUtxo of this.utxoScope.values()) {
        if (iterUtxo.input().transactionId() == input.transactionId() && iterUtxo.input().index() == input.index()) {
          utxo = iterUtxo;
        }
      }
      if (!utxo) {
        throw new Error("Unreachable! UTxO missing!");
      }
      inputValue = merge(inputValue, utxo.output().amount());
    }
    for (const output of this.body.outputs().values()) {
      outputValue = merge(outputValue, output.amount());
    }
    for (const cert of this.body.certs()?.values() || []) {
      switch (cert.kind()) {
        case 0:
          outputValue = merge(
            outputValue,
            new Value2(BigInt(this.params.stakeKeyDeposit))
          );
          break;
        case 1:
          inputValue = merge(
            inputValue,
            new Value2(BigInt(this.params.stakeKeyDeposit))
          );
          break;
        case 3:
          if (this.params.poolDeposit) {
            outputValue = merge(
              outputValue,
              new Value2(BigInt(this.params.poolDeposit))
            );
          }
          break;
        case 4:
          if (this.params.poolDeposit) {
            inputValue = merge(
              inputValue,
              new Value2(BigInt(this.params.poolDeposit))
            );
          }
          break;
      }
    }
    const tilt = merge(
      merge(inputValue, negate(outputValue)),
      mintValue
    );
    return tilt.toCbor() == zero().toCbor();
  }
  /**
   * Generates a script data hash for the transaction if there are any datums or redeemers present.
   * This hash is crucial for the validation of Plutus scripts in the transaction.
   *
   * @param {TransactionWitnessSet} tw - The transaction witness set containing Plutus data.
   * @returns {IScriptData | undefined} The full lscript data if datums or redeemers are present, otherwise undefined.
   */
  getScriptData(tw) {
    const usedCostModels = new Costmdls();
    for (let i = 0; i <= Object.keys(this.usedLanguages).length; i++) {
      if (this.usedLanguages[i]) {
        const cm = this.params.costModels.get(i);
        if (cm == void 0) {
          throw new Error(
            `complete: Could not find cost model for Plutus Language Version ${i + 1}`
          );
        }
        usedCostModels.insert(new CostModel(i, cm));
      }
    }
    return computeScriptData(this.redeemers, tw.plutusData(), usedCostModels);
  }
  /**
   * Helper method to just get the script data hash from a TransactionWitnessSet.
   *
   * @param {TransactionWitnessSet} tw - The transaction witness set containing Plutus data.
   * @returns {Hash32ByteBase16 | undefined} The script data hash if datums or redeemers are present, otherwise undefined.
   */
  getScriptDataHash(tw) {
    return this.getScriptData(tw)?.scriptDataHash;
  }
  /**
   * Adjusts the balance of the transaction by creating or updating a change output.
   * This method takes the excess value from the transaction, removes any zero-valued
   * tokens from the multiasset map, and then either creates a new change output or
   * updates an existing one with the adjusted value.
   *
   * @param {Value} excessValue - The excess value that needs to be returned as change.
   */
  balanceChange(excessValue) {
    const tokenMap = excessValue.multiasset();
    if (tokenMap) {
      for (const key of tokenMap.keys()) {
        if (tokenMap.get(key) == 0n) {
          tokenMap.delete(key);
        }
      }
      excessValue.setMultiasset(tokenMap);
    }
    const output = new TransactionOutput(this.changeAddress, excessValue);
    if (void 0 === this.changeOutputIndex) {
      this.addOutput(output);
      this.changeOutputIndex = this.outputsCount - 1;
    } else {
      const outputs = this.body.outputs();
      outputs[this.changeOutputIndex] = this.checkAndAlterOutput(output);
      this.body.setOutputs(outputs);
    }
  }
  /**
   * Calculates the transaction fees based on the transaction size and parameters.
   * It updates the transaction body with the calculated fee.
   *
   * @param {Transaction} draft_tx - The draft transaction to calculate fees for.
   */
  calculateFees(draft_tx) {
    let minFee = this.params.minFeeConstant + draft_tx.toCbor().length / 2 * this.params.minFeeCoefficient;
    if (this.params.minFeeReferenceScripts) {
      const utxoScope = [...this.utxoScope.values()];
      const allInputs = [
        ...draft_tx.body().inputs().values(),
        ...draft_tx.body().referenceInputs()?.values() ?? []
      ];
      const refScripts = allInputs.map(
        (x) => utxoScope.find((y) => y.input().toCbor() == x.toCbor()).output().scriptRef()
      ).filter((x) => x !== void 0);
      if (refScripts.length > 0) {
        minFee += calculateReferenceScriptFee(refScripts, this.params);
      }
    }
    const redeemers = draft_tx.witnessSet().redeemers();
    if (redeemers) {
      for (const redeemer of redeemers.values()) {
        const exUnits = redeemer.exUnits();
        minFee += this.params.prices.memory * Number(exUnits.mem());
        minFee += this.params.prices.steps * Number(exUnits.steps());
      }
    }
    this.fee = BigInt(Math.ceil(minFee));
    this.body.setFee(bigintMax(this.fee, this.minimumFee) + this.feePadding);
  }
  /**
   * Prepares the collateral for the transaction by selecting suitable UTXOs.
   * Throws an error if suitable collateral cannot be found or if some inputs cannot be resolved.
   */
  prepareCollateral() {
    const providedCollateral = [...this.collateralUtxos.values()].sort(
      (a, b) => a.output().amount().coin() < b.output().amount().coin() ? -1 : 1
    );
    const inputs = [...this.body.inputs().values()];
    const scope = [...this.utxoScope.values()];
    let [best, rank] = [
      void 0,
      99
    ];
    if (providedCollateral.length > 0) {
      for (const utxo of providedCollateral) {
        const coinAmount = this.getUtxoEffectiveCoin(utxo);
        if (coinAmount >= 5e6 && utxo.output().address().getProps().paymentPart?.type == CredentialType.KeyHash) {
          const ranking = assetTypes(utxo.output().amount());
          if (ranking < rank) {
            rank = ranking;
            best = [utxo];
          }
        }
      }
    } else {
      for (const input of inputs) {
        const utxo = scope.find(
          (x) => x.input().transactionId() === input.transactionId() && x.input().index() === input.index()
        );
        if (utxo) {
          const coinAmount = this.getUtxoEffectiveCoin(utxo);
          if (coinAmount >= 5e6 && utxo.output().address().getProps().paymentPart?.type == CredentialType.KeyHash) {
            const ranking = assetTypes(utxo.output().amount());
            if (ranking < rank) {
              rank = ranking;
              best = [utxo];
            }
          }
        } else {
          throw new Error("prepareCollateral: could not resolve some input");
        }
      }
    }
    if (!best) {
      for (const utxo of this.utxos.values()) {
        const coinAmount = this.getUtxoEffectiveCoin(utxo);
        if (coinAmount >= 5000000n && utxo.output().address().getProps().paymentPart?.type == CredentialType.KeyHash) {
          const ranking = assetTypes(utxo.output().amount());
          if (ranking < rank) {
            rank = ranking;
            best = [utxo];
          }
        }
      }
      if (best) {
        for (const bestUtxo of best) {
          this.utxoScope.add(bestUtxo);
        }
      } else {
        const collateral = [];
        let adaAmount = 0n;
        for (let i = 0; i < Math.min(this.params.maxCollateralInputs, providedCollateral.length); i++) {
          adaAmount += providedCollateral[i].output().amount().coin();
          collateral.push(providedCollateral[i]);
          if (adaAmount >= 5000000n) {
            break;
          }
        }
        if (adaAmount < 5000000n) {
          const adaUtxos = [...this.utxos.values()].sort((a, b) => {
            const aCoinAmount = this.getUtxoEffectiveCoin(a);
            const bCoinAmount = this.getUtxoEffectiveCoin(b);
            return aCoinAmount < bCoinAmount ? -1 : 1;
          });
          for (let i = 0; i < Math.min(this.params.maxCollateralInputs, adaUtxos.length); i++) {
            adaAmount += this.getUtxoEffectiveCoin(adaUtxos[i]);
            collateral.push(adaUtxos[i]);
            if (adaAmount >= 5000000n) {
              break;
            }
          }
        }
        if (adaAmount <= 5e6) {
          throw new Error(
            "prepareCollateral: could not find enough collateral (5 ada minimum)"
          );
        }
        best = collateral;
      }
    }
    const tis = CborSet.fromCore([], TransactionInput.fromCore);
    tis.setValues(best.map((x) => x.input()));
    this.body.setCollateral(tis);
    for (const bestUtxo of best) {
      const key = bestUtxo.output().address().getProps().paymentPart;
      if (key.type == CredentialType.ScriptHash) {
        this.requiredNativeScripts.add(key.hash);
      } else {
        this.requiredWitnesses.add(HashAsPubKeyHex(key.hash));
      }
    }
    const ret = new TransactionOutput(
      this.collateralChangeAddress ?? this.changeAddress,
      best.reduce(
        (acc, x) => merge(acc, x.output().amount()),
        zero()
      )
    );
    this.body.setCollateralReturn(ret);
  }
  /**
   * Returns the effective coin value of the utxo substracting the min utxo needed for the multiasset in the utxo
   *
   * @param {TransactionUnspentOutput} utxo - The utxo to calculate the effective coin value
   * @returns {bigint} The effective coin value of the utxo
   * */
  getUtxoEffectiveCoin(utxo) {
    const output = utxo.output();
    const multiasset = output.amount().multiasset();
    const hasMultiasset = multiasset && multiasset.size > 0;
    const outputMinAda = this.calculateMinAda(output);
    return hasMultiasset ? output.amount().coin() - outputMinAda : output.amount().coin();
  }
  /**
   * Adjusts the balance of the transaction by creating or updating a change output.
   * This method takes only the native assets from excess value from the transaction, removes any zero-valued
   * tokens from the multiasset map, and then creates change outputs that don't exceed the minValueSize.
   *
   * Updates the changeOutputIndex to the index of the last change output.
   *
   * @param {Value} excessValue - The excess value that needs to be returned as change.
   * returns {Value} The remaining excess value after creating change outputs. (Which should only be ADA)
   */
  balanceMultiAssetChange(excessValue) {
    const tokenMap = excessValue.multiasset();
    if (tokenMap) {
      for (const key of tokenMap.keys()) {
        if (tokenMap.get(key) == 0n) {
          tokenMap.delete(key);
        }
      }
      excessValue.setMultiasset(tokenMap);
    }
    let changeExcess = excessValue;
    const multiAsset = excessValue.multiasset();
    if (!multiAsset || multiAsset.size == 0) return excessValue;
    let output = new TransactionOutput(this.changeAddress, zero());
    for (const [asset, qty] of Array.from(multiAsset.entries())) {
      const newOutputValue = merge(
        output.amount(),
        makeValue(0n, [asset, qty])
      );
      const newOutputValueByteLength = newOutputValue.toCbor().length / 2;
      if (newOutputValueByteLength > this.params.maxValueSize * 0.9) {
        this.addOutput(output);
        changeExcess = sub(changeExcess, output.amount());
        output = new TransactionOutput(
          this.changeAddress,
          makeValue(0n, [asset, qty])
        );
      } else {
        output = new TransactionOutput(this.changeAddress, newOutputValue);
      }
    }
    this.addOutput(output);
    changeExcess = sub(changeExcess, output.amount());
    return changeExcess;
  }
  /**
   * Balances the collateral change by creating a transaction output that returns the excess collateral.
   * Throws an error if the change address is not set.
   */
  balanceCollateralChange() {
    if (!this.changeAddress) {
      throw new Error("balanceCollateralChange: change address not set");
    }
    const collateral = this.body.collateral();
    if (!collateral || collateral.size() == 0) {
      return;
    }
    const scope = [
      ...this.utxoScope.values(),
      ...this.collateralUtxos.values()
    ];
    const totalCollateral = BigInt(
      Math.ceil(
        this.params.collateralPercentage / 100 * Number(bigintMax(this.fee, this.minimumFee) + this.feePadding)
      )
    );
    const collateralValue = this.body.collateral().values().reduce((acc, input) => {
      const utxo = scope.find(
        (x) => x.input().transactionId() === input.transactionId() && x.input().index() === input.index()
      );
      if (!utxo) {
        throw new Error(
          "balanceCollateralChange: Could not resolve some collateral input"
        );
      }
      return merge(utxo.output().amount(), acc);
    }, zero());
    this.body.setCollateralReturn(
      new TransactionOutput(
        this.changeAddress,
        merge(collateralValue, new Value2(-totalCollateral))
      )
    );
    this.body.setTotalCollateral(totalCollateral);
  }
  /**
   * Prints the transaction cbor in its current state without trying to complete it
   * @returns {string} The CBOR representation of the transaction
   * */
  toCbor() {
    const tw = this.buildTransactionWitnessSet();
    return new Transaction(this.body, tw, this.auxiliaryData).toCbor();
  }
  /**
   * Completes the transaction by performing several key operations:
   * - Verifies the presence of a change address.
   * - Gathers inputs and performs coin selection if necessary.
   * - Balances the change output.
   * - Builds the transaction witness set.
   * - Calculates the script data hash.
   * - Estimates and sets the transaction fee.
   * - Merges the fee value with the excess value and rebalances the change.
   *
   * @throws {Error} If the change address is not set, or if the coin selection fails to eliminate negative values,
   *                 or if balancing the change output fails.
   * @returns {Promise<Transaction>} A new Transaction object with all components set and ready for submission.
   */
  async complete() {
    if (this.preCompleteHooks && this.preCompleteHooks.length > 0) {
      for (const hook of this.preCompleteHooks) {
        await hook(this);
      }
    }
    if (!this.changeAddress) {
      throw new Error(
        "Cannot complete transaction without setting change address"
      );
    }
    if (this.networkId === void 0) {
      throw new Error(
        "Cannot complete transaction without setting a network id"
      );
    }
    const inputs = [...this.body.inputs().values()];
    const preliminaryDraftTx = new Transaction(
      this.body,
      new TransactionWitnessSet()
    );
    const preliminaryFee = this.params.minFeeConstant + preliminaryDraftTx.toCbor().length / 2 * this.params.minFeeCoefficient;
    let excessValue = this.getPitch(
      bigintMax(BigInt(Math.ceil(preliminaryFee)), this.minimumFee)
    );
    let spareInputs = [];
    for (const [utxo] of this.utxos.entries()) {
      if (!inputs.includes(utxo.input())) {
        spareInputs.push(utxo);
      }
    }
    const selectionResult = this.coinSelector(
      spareInputs,
      negate(negatives(excessValue))
    );
    excessValue = merge(excessValue, selectionResult.selectedValue);
    spareInputs = selectionResult.inputs;
    if (selectionResult.selectedInputs.length > 0) {
      for (const input of selectionResult.selectedInputs) {
        this.addInput(input);
      }
    } else {
      if (this.body.inputs().size() == 0) {
        if (!spareInputs[0]) {
          throw new Error(
            "No spare inputs available to add to the transaction"
          );
        }
        const [inputWithLeastMultiAssets] = spareInputs.reduce(
          ([minInput, minMultiAssetCount], currentInput) => {
            const currentMultiAssetCount = assetTypes(
              currentInput.output().amount()
            );
            return currentMultiAssetCount < minMultiAssetCount ? [currentInput, minMultiAssetCount] : [minInput, assetTypes(minInput.output().amount())];
          },
          [spareInputs[0], assetTypes(spareInputs[0].output().amount())]
        );
        this.addInput(inputWithLeastMultiAssets);
        spareInputs = spareInputs.filter(
          (input) => input !== inputWithLeastMultiAssets
        );
      }
    }
    if (this.body.inputs().values().length == 0) {
      throw new Error(
        "TxBuilder: resolved empty input set, cannot construct transaction!"
      );
    }
    if (!empty(negatives(excessValue))) {
      throw new Error(
        "Unreachable! Somehow coin selection succeeded but still failed."
      );
    }
    excessValue = this.balanceMultiAssetChange(excessValue);
    this.balanceChange(excessValue);
    if (this.changeOutputIndex === void 0) {
      throw new Error(
        "Unreachable! Somehow change balancing succeeded but still failed."
      );
    }
    let tw = this.buildTransactionWitnessSet();
    {
      const scriptDataHash = this.getScriptDataHash(tw);
      if (scriptDataHash) {
        this.body.setScriptDataHash(scriptDataHash);
      }
    }
    const auxiliaryData = this.auxiliaryData;
    if (auxiliaryData) {
      const auxiliaryDataHash = this.getAuxiliaryDataHash(auxiliaryData);
      if (auxiliaryDataHash != this.body.auxiliaryDataHash()) {
        throw new Error(
          "TxBuilder complete: auxiliary data somehow didn't match auxiliary data hash"
        );
      }
    } else {
      if (this.body.auxiliaryDataHash() != void 0) {
        throw new Error(
          "TxBuilder complete: auxiliary data somehow didn't match auxiliary data hash"
        );
      }
    }
    this.balanceChange(excessValue);
    const draft_tx = new Transaction(this.body, tw, this.auxiliaryData);
    let draft_size = draft_tx.toCbor().length / 2;
    this.calculateFees(draft_tx);
    excessValue = merge(
      excessValue,
      new Value2(
        -(bigintMax(this.fee, this.minimumFee) + this.feePadding) + BigInt(preliminaryFee)
      )
    );
    this.balanceChange(excessValue);
    let evaluationFee = 0n;
    if (this.redeemers.size() > 0) {
      this.prepareCollateral();
      tw = this.buildTransactionWitnessSet();
      try {
        evaluationFee = await this.evaluate(draft_tx);
      } catch (e) {
        console.log(
          `An error occurred when trying to evaluate this transaction. Full CBOR: ${draft_tx.toCbor()}`
        );
        throw e;
      }
      tw.setRedeemers(this.redeemers);
      draft_tx.setWitnessSet(tw);
      this.calculateFees(draft_tx);
      if (this.fee > this.minimumFee) {
        if (this.fee - evaluationFee > this.minimumFee) {
          excessValue = merge(excessValue, new Value2(-evaluationFee));
          this.balanceChange(excessValue);
        } else {
          const feeChange = this.fee - this.minimumFee;
          excessValue = merge(excessValue, new Value2(-feeChange));
          this.balanceChange(excessValue);
        }
      }
    }
    {
      const scriptDataHash = this.getScriptDataHash(tw);
      if (scriptDataHash) {
        this.body.setScriptDataHash(scriptDataHash);
      }
    }
    if (this.feePadding > 0n) {
      console.warn(
        "A transaction was built using fee padding. This is useful for working around changes to fee calculation, but ultimately is a bandaid. If you find yourself needing this, please open a ticket at https://github.com/butaneprotocol/blaze-cardano so we can fix the underlying inaccuracy!"
      );
    }
    let final_size = draft_size;
    do {
      const oldEvaluationFee = evaluationFee;
      const newTW = this.buildTransactionWitnessSet();
      const redeemers = tw.redeemers();
      if (redeemers) newTW.setRedeemers(redeemers);
      tw = newTW;
      draft_tx.setWitnessSet(tw);
      this.calculateFees(draft_tx);
      excessValue = this.getPitch();
      this.balanceChange(Value2.fromCore(excessValue.toCore()));
      const changeOutput = this.body.outputs()[this.changeOutputIndex];
      if (changeOutput.amount().coin() > excessValue.coin()) {
        const excessDifference = merge(
          changeOutput.amount(),
          negate(excessValue)
        );
        if (spareInputs.length == 0) {
          throw new Error("Tx builder could not satisfy coin selection");
        }
        const selectionResult2 = this.coinSelector(
          spareInputs,
          excessDifference
        );
        spareInputs = selectionResult2.inputs;
        for (const input of selectionResult2.selectedInputs) {
          this.addInput(input);
        }
        draft_tx.setBody(this.body);
        if (evaluationFee > 0) {
          await this.evaluate(draft_tx);
          tw.setRedeemers(this.redeemers);
          draft_tx.setWitnessSet(tw);
          this.calculateFees(draft_tx);
          {
            const scriptDataHash = this.getScriptDataHash(tw);
            if (scriptDataHash) {
              this.body.setScriptDataHash(scriptDataHash);
            }
          }
          if (evaluationFee > oldEvaluationFee) {
            continue;
          }
        }
      }
      if (this.body.collateral()) {
        this.balanceCollateralChange();
      }
      draft_tx.setBody(this.body);
      draft_size = final_size;
      final_size = draft_tx.toCbor().length / 2;
    } while (final_size != draft_size || !this.balanced());
    tw.setVkeys(CborSet.fromCore([], VkeyWitness.fromCore));
    return new Transaction(this.body, tw, this.auxiliaryData);
  }
  /**
   * Adds a certificate to delegate a staker to a pool
   *
   * @param {Credential} delegator - The credential of the staker to delegate.
   * @param {PoolId} poolId - The ID of the pool to delegate to.
   * @param {PlutusData} [redeemer] - Optional. A redeemer to be used if the delegation requires Plutus script validation.
   * @returns {TxBuilder} The updated transaction builder.
   */
  addDelegation(delegator, poolId, redeemer) {
    const stakeDelegation = {
      __typename: CertificateType.StakeDelegation,
      stakeCredential: delegator.toCore(),
      poolId
    };
    const delegationCertificate = Certificate.newStakeDelegation(
      StakeDelegation.fromCore(stakeDelegation)
    );
    const certs = this.body.certs() ?? CborSet.fromCore([], Certificate.fromCore);
    const vals = [...certs.values(), delegationCertificate];
    certs.setValues(vals);
    this.body.setCerts(certs);
    const delegatorCredential = delegator.toCore();
    if (delegatorCredential.type == CredentialType.ScriptHash) {
      if (redeemer) {
        this.requiredPlutusScripts.add(delegatorCredential.hash);
        const redeemers = [...this.redeemers.values()];
        redeemers.push(
          Redeemer.fromCore({
            index: 256,
            // todo: fix
            purpose: RedeemerPurpose["certificate"],
            data: redeemer.toCore(),
            executionUnits: {
              memory: this.params.maxExecutionUnitsPerTransaction.memory,
              steps: this.params.maxExecutionUnitsPerTransaction.steps
            }
          })
        );
        this.redeemers.setValues(redeemers);
      } else {
        this.requiredNativeScripts.add(delegatorCredential.hash);
      }
    } else if (redeemer) {
      throw new Error(
        "TxBuilder addDelegation: failing to attach redeemer to a non-script delegation!"
      );
    } else {
      this.requiredWitnesses.add(HashAsPubKeyHex(delegatorCredential.hash));
    }
    return this;
  }
  /**
   * This method delegates the selected reward address to a pool.
   * It first checks if the reward address is set and if it has a stake component.
   * If both conditions are met, it adds a delegation to the transaction.
   *
   * @param {PoolId} poolId - The ID of the pool to delegate the reward address to.
   * @throws {Error} If the reward address is not set or if the method is unimplemented.
   */
  delegate(poolId, redeemer) {
    if (!this.rewardAddress) {
      throw new Error("TxBuilder delegate: Reward address must be set!");
    }
    const credential = this.rewardAddress.getProps().delegationPart;
    if (!credential) {
      throw new Error(
        "TxBuilder delegate: Somehow the reward address had no stake component"
      );
    }
    this.addDelegation(Credential.fromCore(credential), poolId, redeemer);
    return this;
  }
  /**
   * Adds a certificate to register a staker.
   * @param {Credential} credential - The credential to register.
   * @throws {Error} Method not implemented.
   */
  addRegisterStake(credential) {
    const stakeRegistration = new StakeRegistration(
      credential.toCore()
    );
    const registrationCertificate = Certificate.newStakeRegistration(stakeRegistration);
    const certs = this.body.certs() ?? CborSet.fromCore([], Certificate.fromCore);
    const vals = [...certs.values(), registrationCertificate];
    certs.setValues(vals);
    this.body.setCerts(certs);
    return this;
  }
  /**
   * Adds a certificate to deregister a staker.
   * @throws {Error} Method not implemented.
   */
  addDeregisterStake() {
    throw new Error("Method not implemented.");
  }
  /**
   * Adds a certificate to register a pool.
   * @throws {Error} Method not implemented.
   */
  addRegisterPool() {
    throw new Error("Method not implemented.");
  }
  /**
   * Adds a certificate to retire a pool.
   * @throws {Error} Method not implemented.
   */
  addRetirePool() {
    throw new Error("Method not implemented.");
  }
  /**
   * Specifies the exact time when the transaction becomes valid.
   *
   * @param {Slot} validFrom - The slot from which the transaction becomes valid.
   * @throws {Error} If the validity start interval is already set.
   * @returns {TxBuilder} The instance of this TxBuilder for chaining.
   */
  setValidFrom(validFrom) {
    if (this.body.validityStartInterval() !== void 0) {
      throw new Error(
        "TxBuilder setValidFrom: Validity start interval is already set"
      );
    }
    this.body.setValidityStartInterval(validFrom);
    return this;
  }
  /**
   * Specifies the exact time when the transaction expires.
   *
   * @param {Slot} validUntil - The slot until which the transaction is valid.
   * @throws {Error} If the time to live is already set.
   * @returns {TxBuilder} The instance of this TxBuilder for chaining.
   */
  setValidUntil(validUntil) {
    if (this.body.ttl() !== void 0) {
      throw new Error("TxBuilder setValidUntil: Time to live is already set");
    }
    this.body.setTtl(validUntil);
    return this;
  }
  /**
   * Adds a withdrawal to the transaction. This method allows for the withdrawal of funds from a staking reward account.
   * Optionally, a redeemer can be provided for script validation purposes.
   *
   * @param {C.Cardano.RewardAccount} address - The reward account from which to withdraw.
   * @param {bigint} amount - The amount of ADA to withdraw.
   * @param {PlutusData} [redeemer] - Optional. The redeemer data for script validation.
   * @returns {TxBuilder} The same transaction builder
   * @throws {Error} If the reward account does not have a stake credential or if any other error occurs.
   */
  addWithdrawal(address, amount, redeemer) {
    const withdrawalHash = Address.fromBech32(address).getProps().paymentPart?.hash;
    if (!withdrawalHash) {
      throw new Error(
        "addWithdrawal: The RewardAccount provided does not have an associated stake credential."
      );
    }
    const insertIdx = this.insertSorted(
      this.consumedWithdrawalHashes,
      withdrawalHash
    );
    const withdrawals = this.body.withdrawals() ?? /* @__PURE__ */ new Map();
    if (withdrawals.has(address)) {
      throw new Error(
        "addWithdrawal: Withdrawal for this address already exists."
      );
    }
    withdrawals.set(address, amount);
    this.body.setWithdrawals(withdrawals);
    if (redeemer) {
      this.requiredPlutusScripts.add(withdrawalHash);
      const redeemers = [...this.redeemers.values()];
      for (const redeemer2 of redeemers) {
        if (redeemer2.tag() == RedeemerTag.Reward && redeemer2.index() >= BigInt(insertIdx)) {
          redeemer2.setIndex(redeemer2.index() + 1n);
        }
      }
      redeemers.push(
        Redeemer.fromCore({
          index: insertIdx,
          purpose: RedeemerPurpose["withdrawal"],
          // TODO: Confirm the purpose of the redeemer.
          data: redeemer.toCore(),
          executionUnits: {
            memory: this.params.maxExecutionUnitsPerTransaction.memory,
            steps: this.params.maxExecutionUnitsPerTransaction.steps
          }
        })
      );
      this.redeemers.setValues(redeemers);
    } else {
      const key = Address.fromBech32(address).getProps().paymentPart;
      if (!key) {
        throw new Error(
          "addWithdrawal: The RewardAccount provided does not have an associated stake credential."
        );
      }
      if (key.type == CredentialType.ScriptHash) {
        this.requiredNativeScripts.add(key.hash);
      } else {
        this.requiredWitnesses.add(HashAsPubKeyHex(key.hash));
      }
    }
    return this;
  }
  /**
   * Adds a required signer to the transaction. This is necessary for transactions that must be explicitly signed by a particular key.
   *
   * @param {Ed25519KeyHashHex} signer - The hash of the Ed25519 public key that is required to sign the transaction.
   * @returns {TxBuilder} The same transaction builder
   */
  addRequiredSigner(signer) {
    const signers = this.body.requiredSigners() ?? CborSet.fromCore([], Hash.fromCore);
    this.requiredWitnesses.add(
      HashAsPubKeyHex(Hash28ByteBase16.fromEd25519KeyHashHex(signer))
    );
    const values = [...signers.values()];
    values.push(Hash.fromCore(signer));
    signers.setValues(values);
    this.body.setRequiredSigners(signers);
    return this;
  }
  /**
   * Computes the hash of the auxiliary data if it exists.
   *
   * @param {AuxiliaryData} auxiliaryData - The auxiliary data to hash.
   * @returns {Hash32ByteBase16 | undefined} The hash of the auxiliary data or undefined if no auxiliary data is provided.
   */
  getAuxiliaryDataHash(auxiliaryData) {
    return auxiliaryData ? blake2b_2562(auxiliaryData.toCbor()) : void 0;
  }
  /**
   * Sets the auxiliary data for the transaction and updates the transaction's auxiliary data hash.
   *
   * @param {AuxiliaryData} auxiliaryData - The auxiliary data to set.
   * @returns {TxBuilder} The same transaction builder
   */
  setAuxiliaryData(auxiliaryData) {
    const auxiliaryDataHash = this.getAuxiliaryDataHash(auxiliaryData);
    if (auxiliaryDataHash) {
      this.body.setAuxiliaryDataHash(auxiliaryDataHash);
    }
    this.auxiliaryData = auxiliaryData;
    return this;
  }
  /**
   * Adds a script to the transaction's script scope. If the script is already provided via a reference script,
   * it will not be explicitly used again. This method ensures that each script is only included once in the
   * transaction, either directly or by reference, to optimize the transaction size and processing.
   *
   * @param {Script} script - The script to be added to the transaction's script scope.
   * @returns {TxBuilder} The same transaction builder
   */
  provideScript(script) {
    this.scriptScope.add(script);
    return this;
  }
  /**
   * Adds a pre-complete hook to the transaction builder. This hook will be executed
   * before the transaction is finalized.
   *
   * Pre-complete hooks are useful for performing last-minute modifications or
   * validations on the transaction before it's completed. Multiple hooks can be
   * added, and they will be executed in the order they were added.
   *
   * @param {(tx: TxBuilder) => Promise<void>} hook - A function that takes the TxBuilder
   * instance as an argument and performs some operation. The hook should be asynchronous.
   * @returns {TxBuilder} The same transaction builder instance for method chaining.
   */
  addPreCompleteHook(hook) {
    if (!this.preCompleteHooks) {
      this.preCompleteHooks = [];
    }
    this.preCompleteHooks.push(hook);
    return this;
  }
};
function assertPaymentsAddress(address) {
  const props = address.getProps();
  if (!props.paymentPart) {
    throw new Error("assertPaymentsAddress: address has no payment part!");
  }
  if (props.paymentPart.type == CredentialType.ScriptHash) {
    throw new Error(
      "assertPaymentsAddress: address payment credential cannot be a script hash!"
    );
  }
}
function assertLockAddress(address) {
  const props = address.getProps();
  if (!props.paymentPart) {
    throw new Error("assertLockAddress: address has no payment part!");
  }
  if (props.paymentPart.type != CredentialType.ScriptHash) {
    throw new Error(
      "assertLockAddress: address payment credential must be a script hash!"
    );
  }
}
function bigintMax(a, b) {
  return a > b ? a : b;
}

// src/data.ts
import {
  PlutusData as PlutusData2,
  fromHex,
  toHex,
  ConstrPlutusData,
  PlutusList,
  PlutusMap,
  PlutusDataKind
} from "@blaze-cardano/core";

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/guard/value.mjs
var value_exports2 = {};
__export(value_exports2, {
  IsArray: () => IsArray,
  IsAsyncIterator: () => IsAsyncIterator,
  IsBigInt: () => IsBigInt,
  IsBoolean: () => IsBoolean,
  IsDate: () => IsDate,
  IsFunction: () => IsFunction,
  IsIterator: () => IsIterator,
  IsNull: () => IsNull,
  IsNumber: () => IsNumber,
  IsObject: () => IsObject,
  IsRegExp: () => IsRegExp,
  IsString: () => IsString,
  IsSymbol: () => IsSymbol,
  IsUint8Array: () => IsUint8Array,
  IsUndefined: () => IsUndefined
});
function IsAsyncIterator(value) {
  return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.asyncIterator in value;
}
function IsArray(value) {
  return Array.isArray(value);
}
function IsBigInt(value) {
  return typeof value === "bigint";
}
function IsBoolean(value) {
  return typeof value === "boolean";
}
function IsDate(value) {
  return value instanceof globalThis.Date;
}
function IsFunction(value) {
  return typeof value === "function";
}
function IsIterator(value) {
  return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.iterator in value;
}
function IsNull(value) {
  return value === null;
}
function IsNumber(value) {
  return typeof value === "number";
}
function IsObject(value) {
  return typeof value === "object" && value !== null;
}
function IsRegExp(value) {
  return value instanceof globalThis.RegExp;
}
function IsString(value) {
  return typeof value === "string";
}
function IsSymbol(value) {
  return typeof value === "symbol";
}
function IsUint8Array(value) {
  return value instanceof globalThis.Uint8Array;
}
function IsUndefined(value) {
  return value === void 0;
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/clone/value.mjs
function ArrayType(value) {
  return value.map((value2) => Visit(value2));
}
function DateType(value) {
  return new Date(value.getTime());
}
function Uint8ArrayType(value) {
  return new Uint8Array(value);
}
function RegExpType(value) {
  return new RegExp(value.source, value.flags);
}
function ObjectType(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Visit(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Visit(value[key]);
  }
  return result;
}
function Visit(value) {
  return IsArray(value) ? ArrayType(value) : IsDate(value) ? DateType(value) : IsUint8Array(value) ? Uint8ArrayType(value) : IsRegExp(value) ? RegExpType(value) : IsObject(value) ? ObjectType(value) : value;
}
function Clone(value) {
  return Visit(value);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/clone/type.mjs
function CloneRest(schemas) {
  return schemas.map((schema) => CloneType(schema));
}
function CloneType(schema, options = {}) {
  return { ...Clone(schema), ...options };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/error/error.mjs
var TypeBoxError = class extends Error {
  constructor(message) {
    super(message);
  }
};

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/symbols/symbols.mjs
var TransformKind = Symbol.for("TypeBox.Transform");
var ReadonlyKind = Symbol.for("TypeBox.Readonly");
var OptionalKind = Symbol.for("TypeBox.Optional");
var Hint = Symbol.for("TypeBox.Hint");
var Kind = Symbol.for("TypeBox.Kind");

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/guard/kind.mjs
function IsReadonly(value) {
  return IsObject(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional(value) {
  return IsObject(value) && value[OptionalKind] === "Optional";
}
function IsAny(value) {
  return IsKindOf(value, "Any");
}
function IsArray2(value) {
  return IsKindOf(value, "Array");
}
function IsAsyncIterator2(value) {
  return IsKindOf(value, "AsyncIterator");
}
function IsBigInt2(value) {
  return IsKindOf(value, "BigInt");
}
function IsBoolean2(value) {
  return IsKindOf(value, "Boolean");
}
function IsConstructor(value) {
  return IsKindOf(value, "Constructor");
}
function IsDate2(value) {
  return IsKindOf(value, "Date");
}
function IsFunction2(value) {
  return IsKindOf(value, "Function");
}
function IsInteger(value) {
  return IsKindOf(value, "Integer");
}
function IsIntersect(value) {
  return IsKindOf(value, "Intersect");
}
function IsIterator2(value) {
  return IsKindOf(value, "Iterator");
}
function IsKindOf(value, kind) {
  return IsObject(value) && Kind in value && value[Kind] === kind;
}
function IsLiteral(value) {
  return IsKindOf(value, "Literal");
}
function IsMappedKey(value) {
  return IsKindOf(value, "MappedKey");
}
function IsMappedResult(value) {
  return IsKindOf(value, "MappedResult");
}
function IsNever(value) {
  return IsKindOf(value, "Never");
}
function IsNot(value) {
  return IsKindOf(value, "Not");
}
function IsNull2(value) {
  return IsKindOf(value, "Null");
}
function IsNumber2(value) {
  return IsKindOf(value, "Number");
}
function IsObject2(value) {
  return IsKindOf(value, "Object");
}
function IsPromise(value) {
  return IsKindOf(value, "Promise");
}
function IsRecord(value) {
  return IsKindOf(value, "Record");
}
function IsRef(value) {
  return IsKindOf(value, "Ref");
}
function IsRegExp2(value) {
  return IsKindOf(value, "RegExp");
}
function IsString2(value) {
  return IsKindOf(value, "String");
}
function IsSymbol2(value) {
  return IsKindOf(value, "Symbol");
}
function IsTemplateLiteral(value) {
  return IsKindOf(value, "TemplateLiteral");
}
function IsThis(value) {
  return IsKindOf(value, "This");
}
function IsTransform(value) {
  return IsObject(value) && TransformKind in value;
}
function IsTuple(value) {
  return IsKindOf(value, "Tuple");
}
function IsUndefined2(value) {
  return IsKindOf(value, "Undefined");
}
function IsUnion(value) {
  return IsKindOf(value, "Union");
}
function IsUint8Array2(value) {
  return IsKindOf(value, "Uint8Array");
}
function IsUnknown(value) {
  return IsKindOf(value, "Unknown");
}
function IsUnsafe(value) {
  return IsKindOf(value, "Unsafe");
}
function IsVoid(value) {
  return IsKindOf(value, "Void");
}
function IsKind(value) {
  return IsObject(value) && Kind in value && IsString(value[Kind]);
}
function IsSchema(value) {
  return IsAny(value) || IsArray2(value) || IsBoolean2(value) || IsBigInt2(value) || IsAsyncIterator2(value) || IsConstructor(value) || IsDate2(value) || IsFunction2(value) || IsInteger(value) || IsIntersect(value) || IsIterator2(value) || IsLiteral(value) || IsMappedKey(value) || IsMappedResult(value) || IsNever(value) || IsNot(value) || IsNull2(value) || IsNumber2(value) || IsObject2(value) || IsPromise(value) || IsRecord(value) || IsRef(value) || IsRegExp2(value) || IsString2(value) || IsSymbol2(value) || IsTemplateLiteral(value) || IsThis(value) || IsTuple(value) || IsUndefined2(value) || IsUnion(value) || IsUint8Array2(value) || IsUnknown(value) || IsUnsafe(value) || IsVoid(value) || IsKind(value);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/guard/type.mjs
var type_exports = {};
__export(type_exports, {
  IsAny: () => IsAny2,
  IsArray: () => IsArray3,
  IsAsyncIterator: () => IsAsyncIterator3,
  IsBigInt: () => IsBigInt3,
  IsBoolean: () => IsBoolean3,
  IsConstructor: () => IsConstructor2,
  IsDate: () => IsDate3,
  IsFunction: () => IsFunction3,
  IsInteger: () => IsInteger2,
  IsIntersect: () => IsIntersect2,
  IsIterator: () => IsIterator3,
  IsKind: () => IsKind2,
  IsKindOf: () => IsKindOf2,
  IsLiteral: () => IsLiteral2,
  IsLiteralBoolean: () => IsLiteralBoolean,
  IsLiteralNumber: () => IsLiteralNumber,
  IsLiteralString: () => IsLiteralString,
  IsLiteralValue: () => IsLiteralValue,
  IsMappedKey: () => IsMappedKey2,
  IsMappedResult: () => IsMappedResult2,
  IsNever: () => IsNever2,
  IsNot: () => IsNot2,
  IsNull: () => IsNull3,
  IsNumber: () => IsNumber3,
  IsObject: () => IsObject3,
  IsOptional: () => IsOptional2,
  IsPromise: () => IsPromise2,
  IsProperties: () => IsProperties,
  IsReadonly: () => IsReadonly2,
  IsRecord: () => IsRecord2,
  IsRecursive: () => IsRecursive,
  IsRef: () => IsRef2,
  IsRegExp: () => IsRegExp3,
  IsSchema: () => IsSchema2,
  IsString: () => IsString3,
  IsSymbol: () => IsSymbol3,
  IsTemplateLiteral: () => IsTemplateLiteral2,
  IsThis: () => IsThis2,
  IsTransform: () => IsTransform2,
  IsTuple: () => IsTuple2,
  IsUint8Array: () => IsUint8Array3,
  IsUndefined: () => IsUndefined3,
  IsUnion: () => IsUnion2,
  IsUnionLiteral: () => IsUnionLiteral,
  IsUnknown: () => IsUnknown2,
  IsUnsafe: () => IsUnsafe2,
  IsVoid: () => IsVoid2,
  TypeGuardUnknownTypeError: () => TypeGuardUnknownTypeError
});
var TypeGuardUnknownTypeError = class extends TypeBoxError {
};
var KnownTypes = [
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];
function IsPattern(value) {
  try {
    new RegExp(value);
    return true;
  } catch {
    return false;
  }
}
function IsControlCharacterFree(value) {
  if (!IsString(value))
    return false;
  for (let i = 0; i < value.length; i++) {
    const code = value.charCodeAt(i);
    if (code >= 7 && code <= 13 || code === 27 || code === 127) {
      return false;
    }
  }
  return true;
}
function IsAdditionalProperties(value) {
  return IsOptionalBoolean(value) || IsSchema2(value);
}
function IsOptionalBigInt(value) {
  return IsUndefined(value) || IsBigInt(value);
}
function IsOptionalNumber(value) {
  return IsUndefined(value) || IsNumber(value);
}
function IsOptionalBoolean(value) {
  return IsUndefined(value) || IsBoolean(value);
}
function IsOptionalString(value) {
  return IsUndefined(value) || IsString(value);
}
function IsOptionalPattern(value) {
  return IsUndefined(value) || IsString(value) && IsControlCharacterFree(value) && IsPattern(value);
}
function IsOptionalFormat(value) {
  return IsUndefined(value) || IsString(value) && IsControlCharacterFree(value);
}
function IsOptionalSchema(value) {
  return IsUndefined(value) || IsSchema2(value);
}
function IsReadonly2(value) {
  return IsObject(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional2(value) {
  return IsObject(value) && value[OptionalKind] === "Optional";
}
function IsAny2(value) {
  return IsKindOf2(value, "Any") && IsOptionalString(value.$id);
}
function IsArray3(value) {
  return IsKindOf2(value, "Array") && value.type === "array" && IsOptionalString(value.$id) && IsSchema2(value.items) && IsOptionalNumber(value.minItems) && IsOptionalNumber(value.maxItems) && IsOptionalBoolean(value.uniqueItems) && IsOptionalSchema(value.contains) && IsOptionalNumber(value.minContains) && IsOptionalNumber(value.maxContains);
}
function IsAsyncIterator3(value) {
  return IsKindOf2(value, "AsyncIterator") && value.type === "AsyncIterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsBigInt3(value) {
  return IsKindOf2(value, "BigInt") && value.type === "bigint" && IsOptionalString(value.$id) && IsOptionalBigInt(value.exclusiveMaximum) && IsOptionalBigInt(value.exclusiveMinimum) && IsOptionalBigInt(value.maximum) && IsOptionalBigInt(value.minimum) && IsOptionalBigInt(value.multipleOf);
}
function IsBoolean3(value) {
  return IsKindOf2(value, "Boolean") && value.type === "boolean" && IsOptionalString(value.$id);
}
function IsConstructor2(value) {
  return IsKindOf2(value, "Constructor") && value.type === "Constructor" && IsOptionalString(value.$id) && IsArray(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsDate3(value) {
  return IsKindOf2(value, "Date") && value.type === "Date" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximumTimestamp) && IsOptionalNumber(value.exclusiveMinimumTimestamp) && IsOptionalNumber(value.maximumTimestamp) && IsOptionalNumber(value.minimumTimestamp) && IsOptionalNumber(value.multipleOfTimestamp);
}
function IsFunction3(value) {
  return IsKindOf2(value, "Function") && value.type === "Function" && IsOptionalString(value.$id) && IsArray(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsInteger2(value) {
  return IsKindOf2(value, "Integer") && value.type === "integer" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsProperties(value) {
  return IsObject(value) && Object.entries(value).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema2(schema));
}
function IsIntersect2(value) {
  return IsKindOf2(value, "Intersect") && (IsString(value.type) && value.type !== "object" ? false : true) && IsArray(value.allOf) && value.allOf.every((schema) => IsSchema2(schema) && !IsTransform2(schema)) && IsOptionalString(value.type) && (IsOptionalBoolean(value.unevaluatedProperties) || IsOptionalSchema(value.unevaluatedProperties)) && IsOptionalString(value.$id);
}
function IsIterator3(value) {
  return IsKindOf2(value, "Iterator") && value.type === "Iterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsKindOf2(value, kind) {
  return IsObject(value) && Kind in value && value[Kind] === kind;
}
function IsLiteralString(value) {
  return IsLiteral2(value) && IsString(value.const);
}
function IsLiteralNumber(value) {
  return IsLiteral2(value) && IsNumber(value.const);
}
function IsLiteralBoolean(value) {
  return IsLiteral2(value) && IsBoolean(value.const);
}
function IsLiteral2(value) {
  return IsKindOf2(value, "Literal") && IsOptionalString(value.$id) && IsLiteralValue(value.const);
}
function IsLiteralValue(value) {
  return IsBoolean(value) || IsNumber(value) || IsString(value);
}
function IsMappedKey2(value) {
  return IsKindOf2(value, "MappedKey") && IsArray(value.keys) && value.keys.every((key) => IsNumber(key) || IsString(key));
}
function IsMappedResult2(value) {
  return IsKindOf2(value, "MappedResult") && IsProperties(value.properties);
}
function IsNever2(value) {
  return IsKindOf2(value, "Never") && IsObject(value.not) && Object.getOwnPropertyNames(value.not).length === 0;
}
function IsNot2(value) {
  return IsKindOf2(value, "Not") && IsSchema2(value.not);
}
function IsNull3(value) {
  return IsKindOf2(value, "Null") && value.type === "null" && IsOptionalString(value.$id);
}
function IsNumber3(value) {
  return IsKindOf2(value, "Number") && value.type === "number" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsObject3(value) {
  return IsKindOf2(value, "Object") && value.type === "object" && IsOptionalString(value.$id) && IsProperties(value.properties) && IsAdditionalProperties(value.additionalProperties) && IsOptionalNumber(value.minProperties) && IsOptionalNumber(value.maxProperties);
}
function IsPromise2(value) {
  return IsKindOf2(value, "Promise") && value.type === "Promise" && IsOptionalString(value.$id) && IsSchema2(value.item);
}
function IsRecord2(value) {
  return IsKindOf2(value, "Record") && value.type === "object" && IsOptionalString(value.$id) && IsAdditionalProperties(value.additionalProperties) && IsObject(value.patternProperties) && ((schema) => {
    const keys = Object.getOwnPropertyNames(schema.patternProperties);
    return keys.length === 1 && IsPattern(keys[0]) && IsObject(schema.patternProperties) && IsSchema2(schema.patternProperties[keys[0]]);
  })(value);
}
function IsRecursive(value) {
  return IsObject(value) && Hint in value && value[Hint] === "Recursive";
}
function IsRef2(value) {
  return IsKindOf2(value, "Ref") && IsOptionalString(value.$id) && IsString(value.$ref);
}
function IsRegExp3(value) {
  return IsKindOf2(value, "RegExp") && IsOptionalString(value.$id) && IsString(value.source) && IsString(value.flags) && IsOptionalNumber(value.maxLength) && IsOptionalNumber(value.minLength);
}
function IsString3(value) {
  return IsKindOf2(value, "String") && value.type === "string" && IsOptionalString(value.$id) && IsOptionalNumber(value.minLength) && IsOptionalNumber(value.maxLength) && IsOptionalPattern(value.pattern) && IsOptionalFormat(value.format);
}
function IsSymbol3(value) {
  return IsKindOf2(value, "Symbol") && value.type === "symbol" && IsOptionalString(value.$id);
}
function IsTemplateLiteral2(value) {
  return IsKindOf2(value, "TemplateLiteral") && value.type === "string" && IsString(value.pattern) && value.pattern[0] === "^" && value.pattern[value.pattern.length - 1] === "$";
}
function IsThis2(value) {
  return IsKindOf2(value, "This") && IsOptionalString(value.$id) && IsString(value.$ref);
}
function IsTransform2(value) {
  return IsObject(value) && TransformKind in value;
}
function IsTuple2(value) {
  return IsKindOf2(value, "Tuple") && value.type === "array" && IsOptionalString(value.$id) && IsNumber(value.minItems) && IsNumber(value.maxItems) && value.minItems === value.maxItems && // empty
  (IsUndefined(value.items) && IsUndefined(value.additionalItems) && value.minItems === 0 || IsArray(value.items) && value.items.every((schema) => IsSchema2(schema)));
}
function IsUndefined3(value) {
  return IsKindOf2(value, "Undefined") && value.type === "undefined" && IsOptionalString(value.$id);
}
function IsUnionLiteral(value) {
  return IsUnion2(value) && value.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));
}
function IsUnion2(value) {
  return IsKindOf2(value, "Union") && IsOptionalString(value.$id) && IsObject(value) && IsArray(value.anyOf) && value.anyOf.every((schema) => IsSchema2(schema));
}
function IsUint8Array3(value) {
  return IsKindOf2(value, "Uint8Array") && value.type === "Uint8Array" && IsOptionalString(value.$id) && IsOptionalNumber(value.minByteLength) && IsOptionalNumber(value.maxByteLength);
}
function IsUnknown2(value) {
  return IsKindOf2(value, "Unknown") && IsOptionalString(value.$id);
}
function IsUnsafe2(value) {
  return IsKindOf2(value, "Unsafe");
}
function IsVoid2(value) {
  return IsKindOf2(value, "Void") && value.type === "void" && IsOptionalString(value.$id);
}
function IsKind2(value) {
  return IsObject(value) && Kind in value && IsString(value[Kind]) && !KnownTypes.includes(value[Kind]);
}
function IsSchema2(value) {
  return IsObject(value) && (IsAny2(value) || IsArray3(value) || IsBoolean3(value) || IsBigInt3(value) || IsAsyncIterator3(value) || IsConstructor2(value) || IsDate3(value) || IsFunction3(value) || IsInteger2(value) || IsIntersect2(value) || IsIterator3(value) || IsLiteral2(value) || IsMappedKey2(value) || IsMappedResult2(value) || IsNever2(value) || IsNot2(value) || IsNull3(value) || IsNumber3(value) || IsObject3(value) || IsPromise2(value) || IsRecord2(value) || IsRef2(value) || IsRegExp3(value) || IsString3(value) || IsSymbol3(value) || IsTemplateLiteral2(value) || IsThis2(value) || IsTuple2(value) || IsUndefined3(value) || IsUnion2(value) || IsUint8Array3(value) || IsUnknown2(value) || IsUnsafe2(value) || IsVoid2(value) || IsKind2(value));
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/patterns/patterns.mjs
var PatternBoolean = "(true|false)";
var PatternNumber = "(0|[1-9][0-9]*)";
var PatternString = "(.*)";
var PatternNever = "(?!.*)";
var PatternBooleanExact = `^${PatternBoolean}$`;
var PatternNumberExact = `^${PatternNumber}$`;
var PatternStringExact = `^${PatternString}$`;
var PatternNeverExact = `^${PatternNever}$`;

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/sets/set.mjs
function SetIncludes(T, S) {
  return T.includes(S);
}
function SetDistinct(T) {
  return [...new Set(T)];
}
function SetIntersect(T, S) {
  return T.filter((L) => S.includes(L));
}
function SetIntersectManyResolve(T, Init) {
  return T.reduce((Acc, L) => {
    return SetIntersect(Acc, L);
  }, Init);
}
function SetIntersectMany(T) {
  return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve(T.slice(1), T[0]) : [];
}
function SetUnionMany(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...L);
  return Acc;
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/any/any.mjs
function Any(options = {}) {
  return { ...options, [Kind]: "Any" };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/array/array.mjs
function Array2(schema, options = {}) {
  return {
    ...options,
    [Kind]: "Array",
    type: "array",
    items: CloneType(schema)
  };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/async-iterator/async-iterator.mjs
function AsyncIterator(items, options = {}) {
  return {
    ...options,
    [Kind]: "AsyncIterator",
    type: "AsyncIterator",
    items: CloneType(items)
  };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/discard/discard.mjs
function DiscardKey(value, key) {
  const { [key]: _, ...rest } = value;
  return rest;
}
function Discard(value, keys) {
  return keys.reduce((acc, key) => DiscardKey(acc, key), value);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/never/never.mjs
function Never(options = {}) {
  return {
    ...options,
    [Kind]: "Never",
    not: {}
  };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/mapped/mapped-result.mjs
function MappedResult(properties) {
  return {
    [Kind]: "MappedResult",
    properties
  };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/constructor/constructor.mjs
function Constructor(parameters, returns, options) {
  return {
    ...options,
    [Kind]: "Constructor",
    type: "Constructor",
    parameters: CloneRest(parameters),
    returns: CloneType(returns)
  };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/function/function.mjs
function Function(parameters, returns, options) {
  return {
    ...options,
    [Kind]: "Function",
    type: "Function",
    parameters: CloneRest(parameters),
    returns: CloneType(returns)
  };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/union/union-create.mjs
function UnionCreate(T, options) {
  return { ...options, [Kind]: "Union", anyOf: CloneRest(T) };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/union/union-evaluated.mjs
function IsUnionOptional(T) {
  return T.some((L) => IsOptional(L));
}
function RemoveOptionalFromRest(T) {
  return T.map((L) => IsOptional(L) ? RemoveOptionalFromType(L) : L);
}
function RemoveOptionalFromType(T) {
  return Discard(T, [OptionalKind]);
}
function ResolveUnion(T, options) {
  return IsUnionOptional(T) ? Optional(UnionCreate(RemoveOptionalFromRest(T), options)) : UnionCreate(RemoveOptionalFromRest(T), options);
}
function UnionEvaluated(T, options = {}) {
  return T.length === 0 ? Never(options) : T.length === 1 ? CloneType(T[0], options) : ResolveUnion(T, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/union/union.mjs
function Union(T, options = {}) {
  return T.length === 0 ? Never(options) : T.length === 1 ? CloneType(T[0], options) : UnionCreate(T, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/template-literal/parse.mjs
var TemplateLiteralParserError = class extends TypeBoxError {
};
function Unescape(pattern) {
  return pattern.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}
function IsNonEscaped(pattern, index, char) {
  return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
}
function IsOpenParen(pattern, index) {
  return IsNonEscaped(pattern, index, "(");
}
function IsCloseParen(pattern, index) {
  return IsNonEscaped(pattern, index, ")");
}
function IsSeparator(pattern, index) {
  return IsNonEscaped(pattern, index, "|");
}
function IsGroup(pattern) {
  if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
    return false;
  let count = 0;
  for (let index = 0; index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (count === 0 && index !== pattern.length - 1)
      return false;
  }
  return true;
}
function InGroup(pattern) {
  return pattern.slice(1, pattern.length - 1);
}
function IsPrecedenceOr(pattern) {
  let count = 0;
  for (let index = 0; index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0)
      return true;
  }
  return false;
}
function IsPrecedenceAnd(pattern) {
  for (let index = 0; index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      return true;
  }
  return false;
}
function Or(pattern) {
  let [count, start] = [0, 0];
  const expressions = [];
  for (let index = 0; index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0) {
      const range2 = pattern.slice(start, index);
      if (range2.length > 0)
        expressions.push(TemplateLiteralParse(range2));
      start = index + 1;
    }
  }
  const range = pattern.slice(start);
  if (range.length > 0)
    expressions.push(TemplateLiteralParse(range));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
}
function And(pattern) {
  function Group(value, index) {
    if (!IsOpenParen(value, index))
      throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
    let count = 0;
    for (let scan = index; scan < value.length; scan++) {
      if (IsOpenParen(value, scan))
        count += 1;
      if (IsCloseParen(value, scan))
        count -= 1;
      if (count === 0)
        return [index, scan];
    }
    throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern2, index) {
    for (let scan = index; scan < pattern2.length; scan++) {
      if (IsOpenParen(pattern2, scan))
        return [index, scan];
    }
    return [index, pattern2.length];
  }
  const expressions = [];
  for (let index = 0; index < pattern.length; index++) {
    if (IsOpenParen(pattern, index)) {
      const [start, end] = Group(pattern, index);
      const range = pattern.slice(start, end + 1);
      expressions.push(TemplateLiteralParse(range));
      index = end;
    } else {
      const [start, end] = Range(pattern, index);
      const range = pattern.slice(start, end);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse(range));
      index = end - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
}
function TemplateLiteralParse(pattern) {
  return IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: Unescape(pattern) };
}
function TemplateLiteralParseExact(pattern) {
  return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/template-literal/finite.mjs
var TemplateLiteralFiniteError = class extends TypeBoxError {
};
function IsNumberExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
}
function IsBooleanExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
}
function IsStringExpression(expression) {
  return expression.type === "const" && expression.const === ".*";
}
function IsTemplateLiteralExpressionFinite(expression) {
  return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/template-literal/generate.mjs
var TemplateLiteralGenerateError = class extends TypeBoxError {
};
function* GenerateReduce(buffer) {
  if (buffer.length === 1)
    return yield* buffer[0];
  for (const left of buffer[0]) {
    for (const right of GenerateReduce(buffer.slice(1))) {
      yield `${left}${right}`;
    }
  }
}
function* GenerateAnd(expression) {
  return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
}
function* GenerateOr(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate(expr);
}
function* GenerateConst(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate(expression) {
  return expression.type === "and" ? yield* GenerateAnd(expression) : expression.type === "or" ? yield* GenerateOr(expression) : expression.type === "const" ? yield* GenerateConst(expression) : (() => {
    throw new TemplateLiteralGenerateError("Unknown expression");
  })();
}
function TemplateLiteralGenerate(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/literal/literal.mjs
function Literal(value, options = {}) {
  return {
    ...options,
    [Kind]: "Literal",
    const: value,
    type: typeof value
  };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/boolean/boolean.mjs
function Boolean(options = {}) {
  return {
    ...options,
    [Kind]: "Boolean",
    type: "boolean"
  };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/bigint/bigint.mjs
function BigInt2(options = {}) {
  return {
    ...options,
    [Kind]: "BigInt",
    type: "bigint"
  };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/number/number.mjs
function Number2(options = {}) {
  return {
    ...options,
    [Kind]: "Number",
    type: "number"
  };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/string/string.mjs
function String(options = {}) {
  return { ...options, [Kind]: "String", type: "string" };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/template-literal/syntax.mjs
function* FromUnion(syntax) {
  const trim = syntax.trim().replace(/"|'/g, "");
  return trim === "boolean" ? yield Boolean() : trim === "number" ? yield Number2() : trim === "bigint" ? yield BigInt2() : trim === "string" ? yield String() : yield (() => {
    const literals = trim.split("|").map((literal) => Literal(literal.trim()));
    return literals.length === 0 ? Never() : literals.length === 1 ? literals[0] : UnionEvaluated(literals);
  })();
}
function* FromTerminal(syntax) {
  if (syntax[1] !== "{") {
    const L = Literal("$");
    const R = FromSyntax(syntax.slice(1));
    return yield* [L, ...R];
  }
  for (let i = 2; i < syntax.length; i++) {
    if (syntax[i] === "}") {
      const L = FromUnion(syntax.slice(2, i));
      const R = FromSyntax(syntax.slice(i + 1));
      return yield* [...L, ...R];
    }
  }
  yield Literal(syntax);
}
function* FromSyntax(syntax) {
  for (let i = 0; i < syntax.length; i++) {
    if (syntax[i] === "$") {
      const L = Literal(syntax.slice(0, i));
      const R = FromTerminal(syntax.slice(i));
      return yield* [L, ...R];
    }
  }
  yield Literal(syntax);
}
function TemplateLiteralSyntax(syntax) {
  return [...FromSyntax(syntax)];
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/template-literal/pattern.mjs
var TemplateLiteralPatternError = class extends TypeBoxError {
};
function Escape(value) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Visit2(schema, acc) {
  return IsTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : IsUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit2(schema2, acc)).join("|")})` : IsNumber2(schema) ? `${acc}${PatternNumber}` : IsInteger(schema) ? `${acc}${PatternNumber}` : IsBigInt2(schema) ? `${acc}${PatternNumber}` : IsString2(schema) ? `${acc}${PatternString}` : IsLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : IsBoolean2(schema) ? `${acc}${PatternBoolean}` : (() => {
    throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[Kind]}'`);
  })();
}
function TemplateLiteralPattern(kinds) {
  return `^${kinds.map((schema) => Visit2(schema, "")).join("")}$`;
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/template-literal/union.mjs
function TemplateLiteralToUnion(schema) {
  const R = TemplateLiteralGenerate(schema);
  const L = R.map((S) => Literal(S));
  return UnionEvaluated(L);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/template-literal/template-literal.mjs
function TemplateLiteral(unresolved, options = {}) {
  const pattern = IsString(unresolved) ? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved)) : TemplateLiteralPattern(unresolved);
  return { ...options, [Kind]: "TemplateLiteral", type: "string", pattern };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-property-keys.mjs
function FromTemplateLiteral(T) {
  const R = TemplateLiteralGenerate(T);
  return R.map((S) => S.toString());
}
function FromUnion2(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...IndexPropertyKeys(L));
  return Acc;
}
function FromLiteral(T) {
  return [T.toString()];
}
function IndexPropertyKeys(T) {
  return [...new Set(IsTemplateLiteral(T) ? FromTemplateLiteral(T) : IsUnion(T) ? FromUnion2(T.anyOf) : IsLiteral(T) ? FromLiteral(T.const) : IsNumber2(T) ? ["[number]"] : IsInteger(T) ? ["[number]"] : [])];
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-result.mjs
function FromProperties(T, P, options) {
  const Acc = {};
  for (const K2 of Object.getOwnPropertyNames(P)) {
    Acc[K2] = Index(T, IndexPropertyKeys(P[K2]), options);
  }
  return Acc;
}
function FromMappedResult(T, R, options) {
  return FromProperties(T, R.properties, options);
}
function IndexFromMappedResult(T, R, options) {
  const P = FromMappedResult(T, R, options);
  return MappedResult(P);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/indexed/indexed.mjs
function FromRest(T, K) {
  return T.map((L) => IndexFromPropertyKey(L, K));
}
function FromIntersectRest(T) {
  return T.filter((L) => !IsNever(L));
}
function FromIntersect(T, K) {
  return IntersectEvaluated(FromIntersectRest(FromRest(T, K)));
}
function FromUnionRest(T) {
  return T.some((L) => IsNever(L)) ? [] : T;
}
function FromUnion3(T, K) {
  return UnionEvaluated(FromUnionRest(FromRest(T, K)));
}
function FromTuple(T, K) {
  return K in T ? T[K] : K === "[number]" ? UnionEvaluated(T) : Never();
}
function FromArray(T, K) {
  return K === "[number]" ? T : Never();
}
function FromProperty(T, K) {
  return K in T ? T[K] : Never();
}
function IndexFromPropertyKey(T, K) {
  return IsIntersect(T) ? FromIntersect(T.allOf, K) : IsUnion(T) ? FromUnion3(T.anyOf, K) : IsTuple(T) ? FromTuple(T.items ?? [], K) : IsArray2(T) ? FromArray(T.items, K) : IsObject2(T) ? FromProperty(T.properties, K) : Never();
}
function IndexFromPropertyKeys(T, K) {
  return K.map((L) => IndexFromPropertyKey(T, L));
}
function FromSchema(T, K) {
  return UnionEvaluated(IndexFromPropertyKeys(T, K));
}
function Index(T, K, options = {}) {
  return IsMappedResult(K) ? CloneType(IndexFromMappedResult(T, K, options)) : IsMappedKey(K) ? CloneType(IndexFromMappedKey(T, K, options)) : IsSchema(K) ? CloneType(FromSchema(T, IndexPropertyKeys(K)), options) : CloneType(FromSchema(T, K), options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-key.mjs
function MappedIndexPropertyKey(T, K, options) {
  return { [K]: Index(T, [K], options) };
}
function MappedIndexPropertyKeys(T, K, options) {
  return K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIndexPropertyKey(T, L, options) };
  }, {});
}
function MappedIndexProperties(T, K, options) {
  return MappedIndexPropertyKeys(T, K.keys, options);
}
function IndexFromMappedKey(T, K, options) {
  const P = MappedIndexProperties(T, K, options);
  return MappedResult(P);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/iterator/iterator.mjs
function Iterator(items, options = {}) {
  return {
    ...options,
    [Kind]: "Iterator",
    type: "Iterator",
    items: CloneType(items)
  };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/object/object.mjs
function _Object(properties, options = {}) {
  const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);
  const optionalKeys = propertyKeys.filter((key) => IsOptional(properties[key]));
  const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
  const clonedAdditionalProperties = IsSchema(options.additionalProperties) ? { additionalProperties: CloneType(options.additionalProperties) } : {};
  const clonedProperties = {};
  for (const key of propertyKeys)
    clonedProperties[key] = CloneType(properties[key]);
  return requiredKeys.length > 0 ? { ...options, ...clonedAdditionalProperties, [Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys } : { ...options, ...clonedAdditionalProperties, [Kind]: "Object", type: "object", properties: clonedProperties };
}
var Object2 = _Object;

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/promise/promise.mjs
function Promise2(item, options = {}) {
  return {
    ...options,
    [Kind]: "Promise",
    type: "Promise",
    item: CloneType(item)
  };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/readonly/readonly.mjs
function RemoveReadonly(schema) {
  return Discard(CloneType(schema), [ReadonlyKind]);
}
function AddReadonly(schema) {
  return { ...CloneType(schema), [ReadonlyKind]: "Readonly" };
}
function ReadonlyWithFlag(schema, F) {
  return F === false ? RemoveReadonly(schema) : AddReadonly(schema);
}
function Readonly(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? ReadonlyFromMappedResult(schema, F) : ReadonlyWithFlag(schema, F);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/readonly/readonly-from-mapped-result.mjs
function FromProperties2(K, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Readonly(K[K2], F);
  return Acc;
}
function FromMappedResult2(R, F) {
  return FromProperties2(R.properties, F);
}
function ReadonlyFromMappedResult(R, F) {
  const P = FromMappedResult2(R, F);
  return MappedResult(P);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/tuple/tuple.mjs
function Tuple(items, options = {}) {
  const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
  return items.length > 0 ? { ...options, [Kind]: "Tuple", type: "array", items: CloneRest(items), additionalItems, minItems, maxItems } : { ...options, [Kind]: "Tuple", type: "array", minItems, maxItems };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/mapped/mapped.mjs
function FromMappedResult3(K, P) {
  return K in P ? FromSchemaType(K, P[K]) : MappedResult(P);
}
function MappedKeyToKnownMappedResultProperties(K) {
  return { [K]: Literal(K) };
}
function MappedKeyToUnknownMappedResultProperties(P) {
  const Acc = {};
  for (const L of P)
    Acc[L] = Literal(L);
  return Acc;
}
function MappedKeyToMappedResultProperties(K, P) {
  return SetIncludes(P, K) ? MappedKeyToKnownMappedResultProperties(K) : MappedKeyToUnknownMappedResultProperties(P);
}
function FromMappedKey(K, P) {
  const R = MappedKeyToMappedResultProperties(K, P);
  return FromMappedResult3(K, R);
}
function FromRest2(K, T) {
  return T.map((L) => FromSchemaType(K, L));
}
function FromProperties3(K, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(T))
    Acc[K2] = FromSchemaType(K, T[K2]);
  return Acc;
}
function FromSchemaType(K, T) {
  return (
    // unevaluated modifier types
    IsOptional(T) ? Optional(FromSchemaType(K, Discard(T, [OptionalKind]))) : IsReadonly(T) ? Readonly(FromSchemaType(K, Discard(T, [ReadonlyKind]))) : (
      // unevaluated mapped types
      IsMappedResult(T) ? FromMappedResult3(K, T.properties) : IsMappedKey(T) ? FromMappedKey(K, T.keys) : (
        // unevaluated types
        IsConstructor(T) ? Constructor(FromRest2(K, T.parameters), FromSchemaType(K, T.returns)) : IsFunction2(T) ? Function(FromRest2(K, T.parameters), FromSchemaType(K, T.returns)) : IsAsyncIterator2(T) ? AsyncIterator(FromSchemaType(K, T.items)) : IsIterator2(T) ? Iterator(FromSchemaType(K, T.items)) : IsIntersect(T) ? Intersect(FromRest2(K, T.allOf)) : IsUnion(T) ? Union(FromRest2(K, T.anyOf)) : IsTuple(T) ? Tuple(FromRest2(K, T.items ?? [])) : IsObject2(T) ? Object2(FromProperties3(K, T.properties)) : IsArray2(T) ? Array2(FromSchemaType(K, T.items)) : IsPromise(T) ? Promise2(FromSchemaType(K, T.item)) : T
      )
    )
  );
}
function MappedFunctionReturnType(K, T) {
  const Acc = {};
  for (const L of K)
    Acc[L] = FromSchemaType(L, T);
  return Acc;
}
function Mapped(key, map, options = {}) {
  const K = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const RT = map({ [Kind]: "MappedKey", keys: K });
  const R = MappedFunctionReturnType(K, RT);
  return CloneType(Object2(R), options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/optional/optional.mjs
function RemoveOptional(schema) {
  return Discard(CloneType(schema), [OptionalKind]);
}
function AddOptional(schema) {
  return { ...CloneType(schema), [OptionalKind]: "Optional" };
}
function OptionalWithFlag(schema, F) {
  return F === false ? RemoveOptional(schema) : AddOptional(schema);
}
function Optional(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? OptionalFromMappedResult(schema, F) : OptionalWithFlag(schema, F);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/optional/optional-from-mapped-result.mjs
function FromProperties4(P, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Optional(P[K2], F);
  return Acc;
}
function FromMappedResult4(R, F) {
  return FromProperties4(R.properties, F);
}
function OptionalFromMappedResult(R, F) {
  const P = FromMappedResult4(R, F);
  return MappedResult(P);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-create.mjs
function IntersectCreate(T, options) {
  const allObjects = T.every((schema) => IsObject2(schema));
  const clonedUnevaluatedProperties = IsSchema(options.unevaluatedProperties) ? { unevaluatedProperties: CloneType(options.unevaluatedProperties) } : {};
  return options.unevaluatedProperties === false || IsSchema(options.unevaluatedProperties) || allObjects ? { ...options, ...clonedUnevaluatedProperties, [Kind]: "Intersect", type: "object", allOf: CloneRest(T) } : { ...options, ...clonedUnevaluatedProperties, [Kind]: "Intersect", allOf: CloneRest(T) };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-evaluated.mjs
function IsIntersectOptional(T) {
  return T.every((L) => IsOptional(L));
}
function RemoveOptionalFromType2(T) {
  return Discard(T, [OptionalKind]);
}
function RemoveOptionalFromRest2(T) {
  return T.map((L) => IsOptional(L) ? RemoveOptionalFromType2(L) : L);
}
function ResolveIntersect(T, options) {
  return IsIntersectOptional(T) ? Optional(IntersectCreate(RemoveOptionalFromRest2(T), options)) : IntersectCreate(RemoveOptionalFromRest2(T), options);
}
function IntersectEvaluated(T, options = {}) {
  if (T.length === 0)
    return Never(options);
  if (T.length === 1)
    return CloneType(T[0], options);
  if (T.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect(T, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/intersect/intersect.mjs
function Intersect(T, options = {}) {
  if (T.length === 0)
    return Never(options);
  if (T.length === 1)
    return CloneType(T[0], options);
  if (T.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate(T, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/awaited/awaited.mjs
function FromRest3(T) {
  return T.map((L) => AwaitedResolve(L));
}
function FromIntersect2(T) {
  return Intersect(FromRest3(T));
}
function FromUnion4(T) {
  return Union(FromRest3(T));
}
function FromPromise(T) {
  return AwaitedResolve(T);
}
function AwaitedResolve(T) {
  return IsIntersect(T) ? FromIntersect2(T.allOf) : IsUnion(T) ? FromUnion4(T.anyOf) : IsPromise(T) ? FromPromise(T.item) : T;
}
function Awaited(T, options = {}) {
  return CloneType(AwaitedResolve(T), options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-keys.mjs
function FromRest4(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(KeyOfPropertyKeys(L));
  return Acc;
}
function FromIntersect3(T) {
  const C = FromRest4(T);
  const R = SetUnionMany(C);
  return R;
}
function FromUnion5(T) {
  const C = FromRest4(T);
  const R = SetIntersectMany(C);
  return R;
}
function FromTuple2(T) {
  return T.map((_, I) => I.toString());
}
function FromArray2(_) {
  return ["[number]"];
}
function FromProperties5(T) {
  return globalThis.Object.getOwnPropertyNames(T);
}
function FromPatternProperties(patternProperties) {
  if (!includePatternProperties)
    return [];
  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
  return patternPropertyKeys.map((key) => {
    return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
  });
}
function KeyOfPropertyKeys(T) {
  return IsIntersect(T) ? FromIntersect3(T.allOf) : IsUnion(T) ? FromUnion5(T.anyOf) : IsTuple(T) ? FromTuple2(T.items ?? []) : IsArray2(T) ? FromArray2(T.items) : IsObject2(T) ? FromProperties5(T.properties) : IsRecord(T) ? FromPatternProperties(T.patternProperties) : [];
}
var includePatternProperties = false;

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/keyof/keyof.mjs
function KeyOfPropertyKeysToRest(T) {
  return T.map((L) => L === "[number]" ? Number2() : Literal(L));
}
function KeyOf(T, options = {}) {
  if (IsMappedResult(T)) {
    return KeyOfFromMappedResult(T, options);
  } else {
    const K = KeyOfPropertyKeys(T);
    const S = KeyOfPropertyKeysToRest(K);
    const U = UnionEvaluated(S);
    return CloneType(U, options);
  }
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-from-mapped-result.mjs
function FromProperties6(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = KeyOf(K[K2], options);
  return Acc;
}
function FromMappedResult5(R, options) {
  return FromProperties6(R.properties, options);
}
function KeyOfFromMappedResult(R, options) {
  const P = FromMappedResult5(R, options);
  return MappedResult(P);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/composite/composite.mjs
function CompositeKeys(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...KeyOfPropertyKeys(L));
  return SetDistinct(Acc);
}
function FilterNever(T) {
  return T.filter((L) => !IsNever(L));
}
function CompositeProperty(T, K) {
  const Acc = [];
  for (const L of T)
    Acc.push(...IndexFromPropertyKeys(L, [K]));
  return FilterNever(Acc);
}
function CompositeProperties(T, K) {
  const Acc = {};
  for (const L of K) {
    Acc[L] = IntersectEvaluated(CompositeProperty(T, L));
  }
  return Acc;
}
function Composite(T, options = {}) {
  const K = CompositeKeys(T);
  const P = CompositeProperties(T, K);
  const R = Object2(P, options);
  return R;
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/date/date.mjs
function Date2(options = {}) {
  return {
    ...options,
    [Kind]: "Date",
    type: "Date"
  };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/null/null.mjs
function Null(options = {}) {
  return {
    ...options,
    [Kind]: "Null",
    type: "null"
  };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/symbol/symbol.mjs
function Symbol2(options) {
  return { ...options, [Kind]: "Symbol", type: "symbol" };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/undefined/undefined.mjs
function Undefined(options = {}) {
  return { ...options, [Kind]: "Undefined", type: "undefined" };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/uint8array/uint8array.mjs
function Uint8Array2(options = {}) {
  return { ...options, [Kind]: "Uint8Array", type: "Uint8Array" };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/unknown/unknown.mjs
function Unknown(options = {}) {
  return {
    ...options,
    [Kind]: "Unknown"
  };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/const/const.mjs
function FromArray3(T) {
  return T.map((L) => FromValue(L, false));
}
function FromProperties7(value) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(value))
    Acc[K] = Readonly(FromValue(value[K], false));
  return Acc;
}
function ConditionalReadonly(T, root) {
  return root === true ? T : Readonly(T);
}
function FromValue(value, root) {
  return IsAsyncIterator(value) ? ConditionalReadonly(Any(), root) : IsIterator(value) ? ConditionalReadonly(Any(), root) : IsArray(value) ? Readonly(Tuple(FromArray3(value))) : IsUint8Array(value) ? Uint8Array2() : IsDate(value) ? Date2() : IsObject(value) ? ConditionalReadonly(Object2(FromProperties7(value)), root) : IsFunction(value) ? ConditionalReadonly(Function([], Unknown()), root) : IsUndefined(value) ? Undefined() : IsNull(value) ? Null() : IsSymbol(value) ? Symbol2() : IsBigInt(value) ? BigInt2() : IsNumber(value) ? Literal(value) : IsBoolean(value) ? Literal(value) : IsString(value) ? Literal(value) : Object2({});
}
function Const(T, options = {}) {
  return CloneType(FromValue(T, true), options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/constructor-parameters/constructor-parameters.mjs
function ConstructorParameters(schema, options = {}) {
  return Tuple(CloneRest(schema.parameters), { ...options });
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/deref/deref.mjs
function FromRest5(schema, references) {
  return schema.map((schema2) => Deref(schema2, references));
}
function FromProperties8(properties, references) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties)) {
    Acc[K] = Deref(properties[K], references);
  }
  return Acc;
}
function FromConstructor(schema, references) {
  schema.parameters = FromRest5(schema.parameters, references);
  schema.returns = Deref(schema.returns, references);
  return schema;
}
function FromFunction(schema, references) {
  schema.parameters = FromRest5(schema.parameters, references);
  schema.returns = Deref(schema.returns, references);
  return schema;
}
function FromIntersect4(schema, references) {
  schema.allOf = FromRest5(schema.allOf, references);
  return schema;
}
function FromUnion6(schema, references) {
  schema.anyOf = FromRest5(schema.anyOf, references);
  return schema;
}
function FromTuple3(schema, references) {
  if (IsUndefined(schema.items))
    return schema;
  schema.items = FromRest5(schema.items, references);
  return schema;
}
function FromArray4(schema, references) {
  schema.items = Deref(schema.items, references);
  return schema;
}
function FromObject(schema, references) {
  schema.properties = FromProperties8(schema.properties, references);
  return schema;
}
function FromPromise2(schema, references) {
  schema.item = Deref(schema.item, references);
  return schema;
}
function FromAsyncIterator(schema, references) {
  schema.items = Deref(schema.items, references);
  return schema;
}
function FromIterator(schema, references) {
  schema.items = Deref(schema.items, references);
  return schema;
}
function FromRef(schema, references) {
  const target = references.find((remote) => remote.$id === schema.$ref);
  if (target === void 0)
    throw Error(`Unable to dereference schema with $id ${schema.$ref}`);
  const discard = Discard(target, ["$id"]);
  return Deref(discard, references);
}
function DerefResolve(schema, references) {
  return IsConstructor(schema) ? FromConstructor(schema, references) : IsFunction2(schema) ? FromFunction(schema, references) : IsIntersect(schema) ? FromIntersect4(schema, references) : IsUnion(schema) ? FromUnion6(schema, references) : IsTuple(schema) ? FromTuple3(schema, references) : IsArray2(schema) ? FromArray4(schema, references) : IsObject2(schema) ? FromObject(schema, references) : IsPromise(schema) ? FromPromise2(schema, references) : IsAsyncIterator2(schema) ? FromAsyncIterator(schema, references) : IsIterator2(schema) ? FromIterator(schema, references) : IsRef(schema) ? FromRef(schema, references) : schema;
}
function Deref(schema, references) {
  return DerefResolve(CloneType(schema), CloneRest(references));
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/enum/enum.mjs
function Enum(item, options = {}) {
  if (IsUndefined(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value) => Literal(value));
  return Union(anyOf, { ...options, [Hint]: "Enum" });
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/extends/extends-check.mjs
var ExtendsResolverError = class extends TypeBoxError {
};
var ExtendsResult;
(function(ExtendsResult2) {
  ExtendsResult2[ExtendsResult2["Union"] = 0] = "Union";
  ExtendsResult2[ExtendsResult2["True"] = 1] = "True";
  ExtendsResult2[ExtendsResult2["False"] = 2] = "False";
})(ExtendsResult || (ExtendsResult = {}));
function IntoBooleanResult(result) {
  return result === ExtendsResult.False ? result : ExtendsResult.True;
}
function Throw(message) {
  throw new ExtendsResolverError(message);
}
function IsStructuralRight(right) {
  return type_exports.IsNever(right) || type_exports.IsIntersect(right) || type_exports.IsUnion(right) || type_exports.IsUnknown(right) || type_exports.IsAny(right);
}
function StructuralRight(left, right) {
  return type_exports.IsNever(right) ? FromNeverRight(left, right) : type_exports.IsIntersect(right) ? FromIntersectRight(left, right) : type_exports.IsUnion(right) ? FromUnionRight(left, right) : type_exports.IsUnknown(right) ? FromUnknownRight(left, right) : type_exports.IsAny(right) ? FromAnyRight(left, right) : Throw("StructuralRight");
}
function FromAnyRight(left, right) {
  return ExtendsResult.True;
}
function FromAny(left, right) {
  return type_exports.IsIntersect(right) ? FromIntersectRight(left, right) : type_exports.IsUnion(right) && right.anyOf.some((schema) => type_exports.IsAny(schema) || type_exports.IsUnknown(schema)) ? ExtendsResult.True : type_exports.IsUnion(right) ? ExtendsResult.Union : type_exports.IsUnknown(right) ? ExtendsResult.True : type_exports.IsAny(right) ? ExtendsResult.True : ExtendsResult.Union;
}
function FromArrayRight(left, right) {
  return type_exports.IsUnknown(left) ? ExtendsResult.False : type_exports.IsAny(left) ? ExtendsResult.Union : type_exports.IsNever(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromArray5(left, right) {
  return type_exports.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !type_exports.IsArray(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
}
function FromAsyncIterator2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !type_exports.IsAsyncIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
}
function FromBigInt(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsBigInt(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBooleanRight(left, right) {
  return type_exports.IsLiteralBoolean(left) ? ExtendsResult.True : type_exports.IsBoolean(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBoolean(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsBoolean(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromConstructor2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : !type_exports.IsConstructor(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit3(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.returns, right.returns));
}
function FromDate(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsDate(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromFunction2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : !type_exports.IsFunction(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit3(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.returns, right.returns));
}
function FromIntegerRight(left, right) {
  return type_exports.IsLiteral(left) && value_exports2.IsNumber(left.const) ? ExtendsResult.True : type_exports.IsNumber(left) || type_exports.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromInteger(left, right) {
  return type_exports.IsInteger(right) || type_exports.IsNumber(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : ExtendsResult.False;
}
function FromIntersectRight(left, right) {
  return right.allOf.every((schema) => Visit3(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIntersect5(left, right) {
  return left.allOf.some((schema) => Visit3(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIterator2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !type_exports.IsIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
}
function FromLiteral2(left, right) {
  return type_exports.IsLiteral(right) && right.const === left.const ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsString(right) ? FromStringRight(left, right) : type_exports.IsNumber(right) ? FromNumberRight(left, right) : type_exports.IsInteger(right) ? FromIntegerRight(left, right) : type_exports.IsBoolean(right) ? FromBooleanRight(left, right) : ExtendsResult.False;
}
function FromNeverRight(left, right) {
  return ExtendsResult.False;
}
function FromNever(left, right) {
  return ExtendsResult.True;
}
function UnwrapTNot(schema) {
  let [current, depth] = [schema, 0];
  while (true) {
    if (!type_exports.IsNot(current))
      break;
    current = current.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current : Unknown();
}
function FromNot(left, right) {
  return type_exports.IsNot(left) ? Visit3(UnwrapTNot(left), right) : type_exports.IsNot(right) ? Visit3(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
}
function FromNull(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsNull(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumberRight(left, right) {
  return type_exports.IsLiteralNumber(left) ? ExtendsResult.True : type_exports.IsNumber(left) || type_exports.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumber(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsInteger(right) || type_exports.IsNumber(right) ? ExtendsResult.True : ExtendsResult.False;
}
function IsObjectPropertyCount(schema, count) {
  return Object.getOwnPropertyNames(schema.properties).length === count;
}
function IsObjectStringLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectSymbolLike(schema) {
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && type_exports.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (type_exports.IsString(schema.properties.description.anyOf[0]) && type_exports.IsUndefined(schema.properties.description.anyOf[1]) || type_exports.IsString(schema.properties.description.anyOf[1]) && type_exports.IsUndefined(schema.properties.description.anyOf[0]));
}
function IsObjectNumberLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBooleanLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBigIntLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectDateLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectUint8ArrayLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectFunctionLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit3(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectConstructorLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectArrayLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit3(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectPromiseLike(schema) {
  const then = Function([Any()], Any());
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit3(schema.properties["then"], then)) === ExtendsResult.True;
}
function Property(left, right) {
  return Visit3(left, right) === ExtendsResult.False ? ExtendsResult.False : type_exports.IsOptional(left) && !type_exports.IsOptional(right) ? ExtendsResult.False : ExtendsResult.True;
}
function FromObjectRight(left, right) {
  return type_exports.IsUnknown(left) ? ExtendsResult.False : type_exports.IsAny(left) ? ExtendsResult.Union : type_exports.IsNever(left) || type_exports.IsLiteralString(left) && IsObjectStringLike(right) || type_exports.IsLiteralNumber(left) && IsObjectNumberLike(right) || type_exports.IsLiteralBoolean(left) && IsObjectBooleanLike(right) || type_exports.IsSymbol(left) && IsObjectSymbolLike(right) || type_exports.IsBigInt(left) && IsObjectBigIntLike(right) || type_exports.IsString(left) && IsObjectStringLike(right) || type_exports.IsSymbol(left) && IsObjectSymbolLike(right) || type_exports.IsNumber(left) && IsObjectNumberLike(right) || type_exports.IsInteger(left) && IsObjectNumberLike(right) || type_exports.IsBoolean(left) && IsObjectBooleanLike(right) || type_exports.IsUint8Array(left) && IsObjectUint8ArrayLike(right) || type_exports.IsDate(left) && IsObjectDateLike(right) || type_exports.IsConstructor(left) && IsObjectConstructorLike(right) || type_exports.IsFunction(left) && IsObjectFunctionLike(right) ? ExtendsResult.True : type_exports.IsRecord(left) && type_exports.IsString(RecordKey(left)) ? (() => {
    return right[Hint] === "Record" ? ExtendsResult.True : ExtendsResult.False;
  })() : type_exports.IsRecord(left) && type_exports.IsNumber(RecordKey(left)) ? (() => {
    return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
  })() : ExtendsResult.False;
}
function FromObject2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : !type_exports.IsObject(right) ? ExtendsResult.False : (() => {
    for (const key of Object.getOwnPropertyNames(right.properties)) {
      if (!(key in left.properties) && !type_exports.IsOptional(right.properties[key])) {
        return ExtendsResult.False;
      }
      if (type_exports.IsOptional(right.properties[key])) {
        return ExtendsResult.True;
      }
      if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })();
}
function FromPromise3(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True : !type_exports.IsPromise(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.item, right.item));
}
function RecordKey(schema) {
  return PatternNumberExact in schema.patternProperties ? Number2() : PatternStringExact in schema.patternProperties ? String() : Throw("Unknown record key pattern");
}
function RecordValue(schema) {
  return PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] : PatternStringExact in schema.patternProperties ? schema.patternProperties[PatternStringExact] : Throw("Unable to get record value schema");
}
function FromRecordRight(left, right) {
  const [Key, Value3] = [RecordKey(right), RecordValue(right)];
  return type_exports.IsLiteralString(left) && type_exports.IsNumber(Key) && IntoBooleanResult(Visit3(left, Value3)) === ExtendsResult.True ? ExtendsResult.True : type_exports.IsUint8Array(left) && type_exports.IsNumber(Key) ? Visit3(left, Value3) : type_exports.IsString(left) && type_exports.IsNumber(Key) ? Visit3(left, Value3) : type_exports.IsArray(left) && type_exports.IsNumber(Key) ? Visit3(left, Value3) : type_exports.IsObject(left) ? (() => {
    for (const key of Object.getOwnPropertyNames(left.properties)) {
      if (Property(Value3, left.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })() : ExtendsResult.False;
}
function FromRecord(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : !type_exports.IsRecord(right) ? ExtendsResult.False : Visit3(RecordValue(left), RecordValue(right));
}
function FromRegExp(left, right) {
  const L = type_exports.IsRegExp(left) ? String() : left;
  const R = type_exports.IsRegExp(right) ? String() : right;
  return Visit3(L, R);
}
function FromStringRight(left, right) {
  return type_exports.IsLiteral(left) && value_exports2.IsString(left.const) ? ExtendsResult.True : type_exports.IsString(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromString(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsString(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromSymbol(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsSymbol(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromTemplateLiteral2(left, right) {
  return type_exports.IsTemplateLiteral(left) ? Visit3(TemplateLiteralToUnion(left), right) : type_exports.IsTemplateLiteral(right) ? Visit3(left, TemplateLiteralToUnion(right)) : Throw("Invalid fallthrough for TemplateLiteral");
}
function IsArrayOfTuple(left, right) {
  return type_exports.IsArray(right) && left.items !== void 0 && left.items.every((schema) => Visit3(schema, right.items) === ExtendsResult.True);
}
function FromTupleRight(left, right) {
  return type_exports.IsNever(left) ? ExtendsResult.True : type_exports.IsUnknown(left) ? ExtendsResult.False : type_exports.IsAny(left) ? ExtendsResult.Union : ExtendsResult.False;
}
function FromTuple4(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : type_exports.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True : !type_exports.IsTuple(right) ? ExtendsResult.False : value_exports2.IsUndefined(left.items) && !value_exports2.IsUndefined(right.items) || !value_exports2.IsUndefined(left.items) && value_exports2.IsUndefined(right.items) ? ExtendsResult.False : value_exports2.IsUndefined(left.items) && !value_exports2.IsUndefined(right.items) ? ExtendsResult.True : left.items.every((schema, index) => Visit3(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUint8Array(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsUint8Array(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUndefined(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsVoid(right) ? FromVoidRight(left, right) : type_exports.IsUndefined(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnionRight(left, right) {
  return right.anyOf.some((schema) => Visit3(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnion7(left, right) {
  return left.anyOf.every((schema) => Visit3(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnknownRight(left, right) {
  return ExtendsResult.True;
}
function FromUnknown(left, right) {
  return type_exports.IsNever(right) ? FromNeverRight(left, right) : type_exports.IsIntersect(right) ? FromIntersectRight(left, right) : type_exports.IsUnion(right) ? FromUnionRight(left, right) : type_exports.IsAny(right) ? FromAnyRight(left, right) : type_exports.IsString(right) ? FromStringRight(left, right) : type_exports.IsNumber(right) ? FromNumberRight(left, right) : type_exports.IsInteger(right) ? FromIntegerRight(left, right) : type_exports.IsBoolean(right) ? FromBooleanRight(left, right) : type_exports.IsArray(right) ? FromArrayRight(left, right) : type_exports.IsTuple(right) ? FromTupleRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsUnknown(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoidRight(left, right) {
  return type_exports.IsUndefined(left) ? ExtendsResult.True : type_exports.IsUndefined(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoid(left, right) {
  return type_exports.IsIntersect(right) ? FromIntersectRight(left, right) : type_exports.IsUnion(right) ? FromUnionRight(left, right) : type_exports.IsUnknown(right) ? FromUnknownRight(left, right) : type_exports.IsAny(right) ? FromAnyRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsVoid(right) ? ExtendsResult.True : ExtendsResult.False;
}
function Visit3(left, right) {
  return (
    // resolvable
    type_exports.IsTemplateLiteral(left) || type_exports.IsTemplateLiteral(right) ? FromTemplateLiteral2(left, right) : type_exports.IsRegExp(left) || type_exports.IsRegExp(right) ? FromRegExp(left, right) : type_exports.IsNot(left) || type_exports.IsNot(right) ? FromNot(left, right) : (
      // standard
      type_exports.IsAny(left) ? FromAny(left, right) : type_exports.IsArray(left) ? FromArray5(left, right) : type_exports.IsBigInt(left) ? FromBigInt(left, right) : type_exports.IsBoolean(left) ? FromBoolean(left, right) : type_exports.IsAsyncIterator(left) ? FromAsyncIterator2(left, right) : type_exports.IsConstructor(left) ? FromConstructor2(left, right) : type_exports.IsDate(left) ? FromDate(left, right) : type_exports.IsFunction(left) ? FromFunction2(left, right) : type_exports.IsInteger(left) ? FromInteger(left, right) : type_exports.IsIntersect(left) ? FromIntersect5(left, right) : type_exports.IsIterator(left) ? FromIterator2(left, right) : type_exports.IsLiteral(left) ? FromLiteral2(left, right) : type_exports.IsNever(left) ? FromNever(left, right) : type_exports.IsNull(left) ? FromNull(left, right) : type_exports.IsNumber(left) ? FromNumber(left, right) : type_exports.IsObject(left) ? FromObject2(left, right) : type_exports.IsRecord(left) ? FromRecord(left, right) : type_exports.IsString(left) ? FromString(left, right) : type_exports.IsSymbol(left) ? FromSymbol(left, right) : type_exports.IsTuple(left) ? FromTuple4(left, right) : type_exports.IsPromise(left) ? FromPromise3(left, right) : type_exports.IsUint8Array(left) ? FromUint8Array(left, right) : type_exports.IsUndefined(left) ? FromUndefined(left, right) : type_exports.IsUnion(left) ? FromUnion7(left, right) : type_exports.IsUnknown(left) ? FromUnknown(left, right) : type_exports.IsVoid(left) ? FromVoid(left, right) : Throw(`Unknown left type operand '${left[Kind]}'`)
    )
  );
}
function ExtendsCheck(left, right) {
  return Visit3(left, right);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-result.mjs
function FromProperties9(P, Right, True, False, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extends(P[K2], Right, True, False, options);
  return Acc;
}
function FromMappedResult6(Left, Right, True, False, options) {
  return FromProperties9(Left.properties, Right, True, False, options);
}
function ExtendsFromMappedResult(Left, Right, True, False, options) {
  const P = FromMappedResult6(Left, Right, True, False, options);
  return MappedResult(P);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/extends/extends.mjs
function ExtendsResolve(left, right, trueType, falseType) {
  const R = ExtendsCheck(left, right);
  return R === ExtendsResult.Union ? Union([trueType, falseType]) : R === ExtendsResult.True ? trueType : falseType;
}
function Extends(L, R, T, F, options = {}) {
  return IsMappedResult(L) ? ExtendsFromMappedResult(L, R, T, F, options) : IsMappedKey(L) ? CloneType(ExtendsFromMappedKey(L, R, T, F, options)) : CloneType(ExtendsResolve(L, R, T, F), options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-key.mjs
function FromPropertyKey(K, U, L, R, options) {
  return {
    [K]: Extends(Literal(K), U, L, R, options)
  };
}
function FromPropertyKeys(K, U, L, R, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };
  }, {});
}
function FromMappedKey2(K, U, L, R, options) {
  return FromPropertyKeys(K.keys, U, L, R, options);
}
function ExtendsFromMappedKey(T, U, L, R, options) {
  const P = FromMappedKey2(T, U, L, R, options);
  return MappedResult(P);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-template-literal.mjs
function ExcludeFromTemplateLiteral(L, R) {
  return Exclude(TemplateLiteralToUnion(L), R);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/exclude/exclude.mjs
function ExcludeRest(L, R) {
  const excluded = L.filter((inner) => ExtendsCheck(inner, R) === ExtendsResult.False);
  return excluded.length === 1 ? excluded[0] : Union(excluded);
}
function Exclude(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CloneType(ExcludeFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CloneType(ExcludeFromMappedResult(L, R), options);
  return CloneType(IsUnion(L) ? ExcludeRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? Never() : L, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-mapped-result.mjs
function FromProperties10(P, U) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Exclude(P[K2], U);
  return Acc;
}
function FromMappedResult7(R, T) {
  return FromProperties10(R.properties, T);
}
function ExcludeFromMappedResult(R, T) {
  const P = FromMappedResult7(R, T);
  return MappedResult(P);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-template-literal.mjs
function ExtractFromTemplateLiteral(L, R) {
  return Extract(TemplateLiteralToUnion(L), R);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/extract/extract.mjs
function ExtractRest(L, R) {
  const extracted = L.filter((inner) => ExtendsCheck(inner, R) !== ExtendsResult.False);
  return extracted.length === 1 ? extracted[0] : Union(extracted);
}
function Extract(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CloneType(ExtractFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CloneType(ExtractFromMappedResult(L, R), options);
  return CloneType(IsUnion(L) ? ExtractRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? L : Never(), options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-mapped-result.mjs
function FromProperties11(P, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extract(P[K2], T);
  return Acc;
}
function FromMappedResult8(R, T) {
  return FromProperties11(R.properties, T);
}
function ExtractFromMappedResult(R, T) {
  const P = FromMappedResult8(R, T);
  return MappedResult(P);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/instance-type/instance-type.mjs
function InstanceType(schema, options = {}) {
  return CloneType(schema.returns, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/integer/integer.mjs
function Integer(options = {}) {
  return {
    ...options,
    [Kind]: "Integer",
    type: "integer"
  };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic-from-mapped-key.mjs
function MappedIntrinsicPropertyKey(K, M, options) {
  return {
    [K]: Intrinsic(Literal(K), M, options)
  };
}
function MappedIntrinsicPropertyKeys(K, M, options) {
  return K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
  }, {});
}
function MappedIntrinsicProperties(T, M, options) {
  return MappedIntrinsicPropertyKeys(T["keys"], M, options);
}
function IntrinsicFromMappedKey(T, M, options) {
  const P = MappedIntrinsicProperties(T, M, options);
  return MappedResult(P);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic.mjs
function ApplyUncapitalize(value) {
  const [first, rest] = [value.slice(0, 1), value.slice(1)];
  return [first.toLowerCase(), rest].join("");
}
function ApplyCapitalize(value) {
  const [first, rest] = [value.slice(0, 1), value.slice(1)];
  return [first.toUpperCase(), rest].join("");
}
function ApplyUppercase(value) {
  return value.toUpperCase();
}
function ApplyLowercase(value) {
  return value.toLowerCase();
}
function FromTemplateLiteral3(schema, mode, options) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  const finite = IsTemplateLiteralExpressionFinite(expression);
  if (!finite)
    return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate(expression)];
  const literals = strings.map((value) => Literal(value));
  const mapped = FromRest6(literals, mode);
  const union = Union(mapped);
  return TemplateLiteral([union], options);
}
function FromLiteralValue(value, mode) {
  return typeof value === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize(value) : mode === "Capitalize" ? ApplyCapitalize(value) : mode === "Uppercase" ? ApplyUppercase(value) : mode === "Lowercase" ? ApplyLowercase(value) : value : value.toString();
}
function FromRest6(T, M) {
  return T.map((L) => Intrinsic(L, M));
}
function Intrinsic(schema, mode, options = {}) {
  return (
    // Intrinsic-Mapped-Inference
    IsMappedKey(schema) ? IntrinsicFromMappedKey(schema, mode, options) : (
      // Standard-Inference
      IsTemplateLiteral(schema) ? FromTemplateLiteral3(schema, mode, schema) : IsUnion(schema) ? Union(FromRest6(schema.anyOf, mode), options) : IsLiteral(schema) ? Literal(FromLiteralValue(schema.const, mode), options) : schema
    )
  );
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/intrinsic/capitalize.mjs
function Capitalize(T, options = {}) {
  return Intrinsic(T, "Capitalize", options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/intrinsic/lowercase.mjs
function Lowercase(T, options = {}) {
  return Intrinsic(T, "Lowercase", options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/intrinsic/uncapitalize.mjs
function Uncapitalize(T, options = {}) {
  return Intrinsic(T, "Uncapitalize", options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/intrinsic/uppercase.mjs
function Uppercase(T, options = {}) {
  return Intrinsic(T, "Uppercase", options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/not/not.mjs
function Not(schema, options) {
  return {
    ...options,
    [Kind]: "Not",
    not: CloneType(schema)
  };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-result.mjs
function FromProperties12(P, K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Omit(P[K2], K, options);
  return Acc;
}
function FromMappedResult9(R, K, options) {
  return FromProperties12(R.properties, K, options);
}
function OmitFromMappedResult(R, K, options) {
  const P = FromMappedResult9(R, K, options);
  return MappedResult(P);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/omit/omit.mjs
function FromIntersect6(T, K) {
  return T.map((T2) => OmitResolve(T2, K));
}
function FromUnion8(T, K) {
  return T.map((T2) => OmitResolve(T2, K));
}
function FromProperty2(T, K) {
  const { [K]: _, ...R } = T;
  return R;
}
function FromProperties13(T, K) {
  return K.reduce((T2, K2) => FromProperty2(T2, K2), T);
}
function OmitResolve(T, K) {
  return IsIntersect(T) ? Intersect(FromIntersect6(T.allOf, K)) : IsUnion(T) ? Union(FromUnion8(T.anyOf, K)) : IsObject2(T) ? Object2(FromProperties13(T.properties, K)) : Object2({});
}
function Omit(T, K, options = {}) {
  if (IsMappedKey(K))
    return OmitFromMappedKey(T, K, options);
  if (IsMappedResult(T))
    return OmitFromMappedResult(T, K, options);
  const I = IsSchema(K) ? IndexPropertyKeys(K) : K;
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(OmitResolve(T, I), options);
  return { ...D, ...R };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-key.mjs
function FromPropertyKey2(T, K, options) {
  return {
    [K]: Omit(T, [K], options)
  };
}
function FromPropertyKeys2(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey2(T, LK, options) };
  }, {});
}
function FromMappedKey3(T, K, options) {
  return FromPropertyKeys2(T, K.keys, options);
}
function OmitFromMappedKey(T, K, options) {
  const P = FromMappedKey3(T, K, options);
  return MappedResult(P);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/parameters/parameters.mjs
function Parameters(schema, options = {}) {
  return Tuple(CloneRest(schema.parameters), { ...options });
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/partial/partial.mjs
function FromRest7(T) {
  return T.map((L) => PartialResolve(L));
}
function FromProperties14(T) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(T))
    Acc[K] = Optional(T[K]);
  return Acc;
}
function PartialResolve(T) {
  return IsIntersect(T) ? Intersect(FromRest7(T.allOf)) : IsUnion(T) ? Union(FromRest7(T.anyOf)) : IsObject2(T) ? Object2(FromProperties14(T.properties)) : Object2({});
}
function Partial(T, options = {}) {
  if (IsMappedResult(T))
    return PartialFromMappedResult(T, options);
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(PartialResolve(T), options);
  return { ...D, ...R };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/partial/partial-from-mapped-result.mjs
function FromProperties15(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Partial(K[K2], options);
  return Acc;
}
function FromMappedResult10(R, options) {
  return FromProperties15(R.properties, options);
}
function PartialFromMappedResult(R, options) {
  const P = FromMappedResult10(R, options);
  return MappedResult(P);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-result.mjs
function FromProperties16(P, K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Pick(P[K2], K, options);
  return Acc;
}
function FromMappedResult11(R, K, options) {
  return FromProperties16(R.properties, K, options);
}
function PickFromMappedResult(R, K, options) {
  const P = FromMappedResult11(R, K, options);
  return MappedResult(P);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/pick/pick.mjs
function FromIntersect7(T, K) {
  return T.map((T2) => PickResolve(T2, K));
}
function FromUnion9(T, K) {
  return T.map((T2) => PickResolve(T2, K));
}
function FromProperties17(T, K) {
  const Acc = {};
  for (const K2 of K)
    if (K2 in T)
      Acc[K2] = T[K2];
  return Acc;
}
function PickResolve(T, K) {
  return IsIntersect(T) ? Intersect(FromIntersect7(T.allOf, K)) : IsUnion(T) ? Union(FromUnion9(T.anyOf, K)) : IsObject2(T) ? Object2(FromProperties17(T.properties, K)) : Object2({});
}
function Pick(T, K, options = {}) {
  if (IsMappedKey(K))
    return PickFromMappedKey(T, K, options);
  if (IsMappedResult(T))
    return PickFromMappedResult(T, K, options);
  const I = IsSchema(K) ? IndexPropertyKeys(K) : K;
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(PickResolve(T, I), options);
  return { ...D, ...R };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-key.mjs
function FromPropertyKey3(T, K, options) {
  return {
    [K]: Pick(T, [K], options)
  };
}
function FromPropertyKeys3(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey3(T, LK, options) };
  }, {});
}
function FromMappedKey4(T, K, options) {
  return FromPropertyKeys3(T, K.keys, options);
}
function PickFromMappedKey(T, K, options) {
  const P = FromMappedKey4(T, K, options);
  return MappedResult(P);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/readonly-optional/readonly-optional.mjs
function ReadonlyOptional(schema) {
  return Readonly(Optional(schema));
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/record/record.mjs
function RecordCreateFromPattern(pattern, T, options) {
  return {
    ...options,
    [Kind]: "Record",
    type: "object",
    patternProperties: { [pattern]: CloneType(T) }
  };
}
function RecordCreateFromKeys(K, T, options) {
  const Acc = {};
  for (const K2 of K)
    Acc[K2] = CloneType(T);
  return Object2(Acc, { ...options, [Hint]: "Record" });
}
function FromTemplateLiteralKey(K, T, options) {
  return IsTemplateLiteralFinite(K) ? RecordCreateFromKeys(IndexPropertyKeys(K), T, options) : RecordCreateFromPattern(K.pattern, T, options);
}
function FromUnionKey(K, T, options) {
  return RecordCreateFromKeys(IndexPropertyKeys(Union(K)), T, options);
}
function FromLiteralKey(K, T, options) {
  return RecordCreateFromKeys([K.toString()], T, options);
}
function FromRegExpKey(K, T, options) {
  return RecordCreateFromPattern(K.source, T, options);
}
function FromStringKey(K, T, options) {
  const pattern = IsUndefined(K.pattern) ? PatternStringExact : K.pattern;
  return RecordCreateFromPattern(pattern, T, options);
}
function FromAnyKey(K, T, options) {
  return RecordCreateFromPattern(PatternStringExact, T, options);
}
function FromNeverKey(K, T, options) {
  return RecordCreateFromPattern(PatternNeverExact, T, options);
}
function FromIntegerKey(_, T, options) {
  return RecordCreateFromPattern(PatternNumberExact, T, options);
}
function FromNumberKey(_, T, options) {
  return RecordCreateFromPattern(PatternNumberExact, T, options);
}
function Record(K, T, options = {}) {
  return IsUnion(K) ? FromUnionKey(K.anyOf, T, options) : IsTemplateLiteral(K) ? FromTemplateLiteralKey(K, T, options) : IsLiteral(K) ? FromLiteralKey(K.const, T, options) : IsInteger(K) ? FromIntegerKey(K, T, options) : IsNumber2(K) ? FromNumberKey(K, T, options) : IsRegExp2(K) ? FromRegExpKey(K, T, options) : IsString2(K) ? FromStringKey(K, T, options) : IsAny(K) ? FromAnyKey(K, T, options) : IsNever(K) ? FromNeverKey(K, T, options) : Never(options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/recursive/recursive.mjs
var Ordinal = 0;
function Recursive(callback, options = {}) {
  if (IsUndefined(options.$id))
    options.$id = `T${Ordinal++}`;
  const thisType = callback({ [Kind]: "This", $ref: `${options.$id}` });
  thisType.$id = options.$id;
  return CloneType({ ...options, [Hint]: "Recursive", ...thisType });
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/ref/ref.mjs
function Ref(unresolved, options = {}) {
  if (IsString(unresolved))
    return { ...options, [Kind]: "Ref", $ref: unresolved };
  if (IsUndefined(unresolved.$id))
    throw new Error("Reference target type must specify an $id");
  return {
    ...options,
    [Kind]: "Ref",
    $ref: unresolved.$id
  };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/regexp/regexp.mjs
function RegExp2(unresolved, options = {}) {
  const expr = IsString(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return { ...options, [Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/required/required.mjs
function FromRest8(T) {
  return T.map((L) => RequiredResolve(L));
}
function FromProperties18(T) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(T))
    Acc[K] = Discard(T[K], [OptionalKind]);
  return Acc;
}
function RequiredResolve(T) {
  return IsIntersect(T) ? Intersect(FromRest8(T.allOf)) : IsUnion(T) ? Union(FromRest8(T.anyOf)) : IsObject2(T) ? Object2(FromProperties18(T.properties)) : Object2({});
}
function Required(T, options = {}) {
  if (IsMappedResult(T)) {
    return RequiredFromMappedResult(T, options);
  } else {
    const D = Discard(T, [TransformKind, "$id", "required"]);
    const R = CloneType(RequiredResolve(T), options);
    return { ...D, ...R };
  }
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/required/required-from-mapped-result.mjs
function FromProperties19(P, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Required(P[K2], options);
  return Acc;
}
function FromMappedResult12(R, options) {
  return FromProperties19(R.properties, options);
}
function RequiredFromMappedResult(R, options) {
  const P = FromMappedResult12(R, options);
  return MappedResult(P);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/rest/rest.mjs
function RestResolve(T) {
  return IsIntersect(T) ? CloneRest(T.allOf) : IsUnion(T) ? CloneRest(T.anyOf) : IsTuple(T) ? CloneRest(T.items ?? []) : [];
}
function Rest(T) {
  return CloneRest(RestResolve(T));
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/return-type/return-type.mjs
function ReturnType(schema, options = {}) {
  return CloneType(schema.returns, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/strict/strict.mjs
function Strict(schema) {
  return JSON.parse(JSON.stringify(schema));
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/transform/transform.mjs
var TransformDecodeBuilder = class {
  constructor(schema) {
    this.schema = schema;
  }
  Decode(decode) {
    return new TransformEncodeBuilder(this.schema, decode);
  }
};
var TransformEncodeBuilder = class {
  constructor(schema, decode) {
    this.schema = schema;
    this.decode = decode;
  }
  EncodeTransform(encode, schema) {
    const Encode = (value) => schema[TransformKind].Encode(encode(value));
    const Decode = (value) => this.decode(schema[TransformKind].Decode(value));
    const Codec = { Encode, Decode };
    return { ...schema, [TransformKind]: Codec };
  }
  EncodeSchema(encode, schema) {
    const Codec = { Decode: this.decode, Encode: encode };
    return { ...schema, [TransformKind]: Codec };
  }
  Encode(encode) {
    const schema = CloneType(this.schema);
    return IsTransform(schema) ? this.EncodeTransform(encode, schema) : this.EncodeSchema(encode, schema);
  }
};
function Transform(schema) {
  return new TransformDecodeBuilder(schema);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/unsafe/unsafe.mjs
function Unsafe(options = {}) {
  return {
    ...options,
    [Kind]: options[Kind] ?? "Unsafe"
  };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/void/void.mjs
function Void(options = {}) {
  return {
    ...options,
    [Kind]: "Void",
    type: "void"
  };
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/type/type.mjs
var type_exports3 = {};
__export(type_exports3, {
  Any: () => Any,
  Array: () => Array2,
  AsyncIterator: () => AsyncIterator,
  Awaited: () => Awaited,
  BigInt: () => BigInt2,
  Boolean: () => Boolean,
  Capitalize: () => Capitalize,
  Composite: () => Composite,
  Const: () => Const,
  Constructor: () => Constructor,
  ConstructorParameters: () => ConstructorParameters,
  Date: () => Date2,
  Deref: () => Deref,
  Enum: () => Enum,
  Exclude: () => Exclude,
  Extends: () => Extends,
  Extract: () => Extract,
  Function: () => Function,
  Index: () => Index,
  InstanceType: () => InstanceType,
  Integer: () => Integer,
  Intersect: () => Intersect,
  Iterator: () => Iterator,
  KeyOf: () => KeyOf,
  Literal: () => Literal,
  Lowercase: () => Lowercase,
  Mapped: () => Mapped,
  Never: () => Never,
  Not: () => Not,
  Null: () => Null,
  Number: () => Number2,
  Object: () => Object2,
  Omit: () => Omit,
  Optional: () => Optional,
  Parameters: () => Parameters,
  Partial: () => Partial,
  Pick: () => Pick,
  Promise: () => Promise2,
  Readonly: () => Readonly,
  ReadonlyOptional: () => ReadonlyOptional,
  Record: () => Record,
  Recursive: () => Recursive,
  Ref: () => Ref,
  RegExp: () => RegExp2,
  Required: () => Required,
  Rest: () => Rest,
  ReturnType: () => ReturnType,
  Strict: () => Strict,
  String: () => String,
  Symbol: () => Symbol2,
  TemplateLiteral: () => TemplateLiteral,
  Transform: () => Transform,
  Tuple: () => Tuple,
  Uint8Array: () => Uint8Array2,
  Uncapitalize: () => Uncapitalize,
  Undefined: () => Undefined,
  Union: () => Union,
  Unknown: () => Unknown,
  Unsafe: () => Unsafe,
  Uppercase: () => Uppercase,
  Void: () => Void
});

// ../../node_modules/.pnpm/@sinclair+typebox@0.32.35/node_modules/@sinclair/typebox/build/esm/type/type/index.mjs
var Type = type_exports3;

// src/data.ts
var Constr = class {
  constructor(index, fields) {
    this.index = index;
    this.fields = fields;
  }
};
function isVoidConstructor(shape) {
  return shape.index === 0 && shape.fields.length === 0;
}
function isBoolean(bEnum) {
  return bEnum.anyOf.length === 2 && bEnum.anyOf.some(
    (s) => "dataType" in s && s["dataType"] == "constructor" && s["fields"].length == 0 && s.title === "True"
  ) && bEnum.anyOf.some(
    (s) => "dataType" in s && s["dataType"] == "constructor" && s["fields"].length == 0 && s.title === "False"
  );
}
function isOptional(bEnum) {
  return bEnum.anyOf.length === 2 && bEnum.anyOf.some(
    (s) => "dataType" in s && s["dataType"] == "constructor" && s["fields"].length == 1 && s.title === "Some"
  ) && bEnum.anyOf.some(
    (s) => "dataType" in s && s["dataType"] == "constructor" && s["fields"].length == 0 && s.title === "None"
  );
}
function replaceProperties(object, properties) {
  Object.keys(object).forEach((key) => {
    delete object[key];
  });
  Object.assign(object, properties);
}
var Data = {
  Integer: function(options) {
    const integer = Type.Unsafe({ dataType: "integer" });
    if (options) {
      Object.entries(options).forEach(([key, value]) => {
        integer[key] = value;
      });
    }
    return integer;
  },
  Bytes: function(options) {
    const bytes = Type.Unsafe({ dataType: "bytes" });
    if (options) {
      Object.entries(options).forEach(([key, value]) => {
        bytes[key] = value;
      });
    }
    return bytes;
  },
  Boolean: function() {
    return Type.Unsafe({
      anyOf: [
        {
          title: "False",
          dataType: "constructor",
          index: 0,
          fields: []
        },
        {
          title: "True",
          dataType: "constructor",
          index: 1,
          fields: []
        }
      ]
    });
  },
  Any: function() {
    return Type.Unsafe({ description: "Any Data." });
  },
  Array: function(items, options) {
    const array = Type.Array(items);
    replaceProperties(array, { dataType: "list", items });
    if (options) {
      Object.entries(options).forEach(([key, value]) => {
        array[key] = value;
      });
    }
    return array;
  },
  Map: function(keys, values, options) {
    const map = Type.Unsafe({
      dataType: "map",
      keys,
      values
    });
    if (options) {
      Object.entries(options).forEach(([key, value]) => {
        map[key] = value;
      });
    }
    return map;
  },
  /**
   * Object applies by default a PlutusData Constr with index 0.\
   * Set 'hasConstr' to false to serialize Object as PlutusData List.
   */
  Object: function(properties, options) {
    const object = Type.Object(properties);
    replaceProperties(object, {
      anyOf: [
        {
          dataType: "constructor",
          index: 0,
          // Will be replaced when using Data.Enum
          fields: Object.entries(properties).map(([title, p]) => ({
            ...p,
            title
          }))
        }
      ]
    });
    object["anyOf"][0].hasConstr = typeof options?.hasConstr === "undefined" || options.hasConstr;
    return object;
  },
  Enum: function(items) {
    const union = Type.Union(items);
    replaceProperties(union, {
      anyOf: items.map(
        (item, index) => item["anyOf"][0].fields.length === 0 ? {
          ...item["anyOf"][0],
          index
        } : {
          dataType: "constructor",
          title: (() => {
            const title = item["anyOf"][0].fields[0].title;
            if (title.charAt(0) !== title.charAt(0).toUpperCase()) {
              throw new Error(
                `Enum '${title}' needs to start with an uppercase letter.`
              );
            }
            return item["anyOf"][0].fields[0].title;
          })(),
          index,
          fields: item["anyOf"][0].fields[0].items || item["anyOf"][0].fields[0].anyOf[0].fields
        }
      )
    });
    return union;
  },
  /**
   * Tuple is by default a PlutusData List.\
   * Set 'hasConstr' to true to apply a PlutusData Constr with index 0.
   */
  Tuple: function(items, options) {
    const tuple = Type.Tuple(items);
    replaceProperties(tuple, {
      dataType: "list",
      items
    });
    if (options) {
      Object.entries(options).forEach(([key, value]) => {
        tuple[key] = value;
      });
    }
    return tuple;
  },
  Literal: function(title) {
    if (title.charAt(0) !== title.charAt(0).toUpperCase()) {
      throw new Error(
        `Enum '${title}' needs to start with an uppercase letter.`
      );
    }
    const literal = Type.Literal(title);
    replaceProperties(literal, {
      anyOf: [
        {
          dataType: "constructor",
          title,
          index: 0,
          // Will be replaced in Data.Enum
          fields: []
        }
      ]
    });
    return literal;
  },
  Nullable: function(item) {
    return Type.Unsafe({
      anyOf: [
        {
          title: "Some",
          description: "An optional value.",
          dataType: "constructor",
          index: 0,
          fields: [item]
        },
        {
          title: "None",
          description: "Nothing.",
          dataType: "constructor",
          index: 1,
          fields: []
        }
      ]
    });
  },
  void: () => PlutusData2.newConstrPlutusData(new ConstrPlutusData(0n, new PlutusList())),
  castFrom,
  castTo,
  to,
  from
};
function to(data, type, recType) {
  if (type === void 0 || type.description == "Any Data.") {
    if (typeof data == "bigint") {
      return PlutusData2.newInteger(data);
    } else if (typeof data === "string") {
      return PlutusData2.newBytes(fromHex(data));
    } else if (typeof data === "boolean") {
      return PlutusData2.newConstrPlutusData(
        new ConstrPlutusData(BigInt(data ? 1 : 0), new PlutusList())
      );
    } else if (typeof data == "object") {
      if (data instanceof Array) {
        const list = new PlutusList();
        for (let i = 0; i < data.length; i++) {
          list.add(to(data[i]));
        }
        return PlutusData2.newList(list);
      } else if (data instanceof Map) {
        const plutusMap = new PlutusMap();
        for (const [key, value] of data.entries()) {
          plutusMap.insert(to(key), to(value));
        }
        return PlutusData2.newMap(plutusMap);
      } else if (data instanceof Constr) {
        return PlutusData2.newConstrPlutusData(
          new ConstrPlutusData(BigInt(data.index), to(data.fields).asList())
        );
      }
    }
  }
  return castTo(data, type, recType);
}
function from(data, type) {
  if (type == void 0 || type != null && typeof type == "object" && "description" in type && type.description == "Any Data.") {
    const kind = data.getKind();
    if (kind == PlutusDataKind.Integer) {
      return data.asInteger();
    } else if (kind == PlutusDataKind.Bytes) {
      return toHex(data.asBoundedBytes());
    } else if (kind == PlutusDataKind.ConstrPlutusData) {
      const constr = data.asConstrPlutusData();
      const list = from(PlutusData2.newList(constr.getData()));
      return new Constr(
        Number(constr.getAlternative()),
        list
      );
    } else if (kind == PlutusDataKind.List) {
      const list = data.asList();
      const returnList = [];
      for (let i = 0; i < list.getLength(); i++) {
        returnList.push(from(list.get(i)));
      }
      return returnList;
    } else if (kind == PlutusDataKind.Map) {
      const map = /* @__PURE__ */ new Map();
      const plutusMap = data.asMap();
      const keys = plutusMap.getKeys();
      for (let i = 0; i < plutusMap.getLength(); i++) {
        const key = keys.get(i);
        map.set(from(key), from(plutusMap.get(key)));
      }
      return map;
    }
  }
  return castFrom(
    data,
    type
  );
}
function castTo(struct, schemaType, recType, recShape) {
  if (!schemaType) throw new Error("Could not type cast struct.");
  let schema = schemaType;
  let shapeType = (schema.anyOf ? "enum" : "") || schema.dataType;
  if (recType === schema.title) {
    recShape = { recType, shape: schema, shapeType };
  } else if (recShape && schema.$ref) {
    schema = recShape.shape;
    shapeType = recShape.shapeType;
  }
  if (struct instanceof PlutusData2) {
    return struct;
  }
  if ("anyOf" in schema) {
    const schemaEnum = schema;
    if (schema["anyOf"].length === 1) {
      return castTo(struct, schema["anyOf"][0], recType, recShape);
    }
    if (isBoolean(schemaEnum)) {
      if (typeof struct !== "boolean") {
        throw new Error("Could not type cast to boolean.");
      }
      const trueIdx = schemaEnum["anyOf"].find((s) => s.title === "True")["index"];
      const falseIdx = schemaEnum["anyOf"].find((s) => s.title === "False")["index"];
      return PlutusData2.newConstrPlutusData(
        new ConstrPlutusData(
          struct ? BigInt(trueIdx) : BigInt(falseIdx),
          new PlutusList()
        )
      );
    } else if (isOptional(schemaEnum)) {
      const someIdx = schemaEnum["anyOf"].find((s) => s.title === "Some")["index"];
      const noneIdx = schemaEnum["anyOf"].find((s) => s.title === "None")["index"];
      if (struct === null) {
        return PlutusData2.newConstrPlutusData(
          new ConstrPlutusData(BigInt(noneIdx), new PlutusList())
        );
      } else {
        const fields = schema["anyOf"][0].fields;
        if (fields.length !== 1) {
          throw new Error("Could not type cast to nullable object.");
        }
        const someList = new PlutusList();
        someList.add(castTo(struct, fields[someIdx], recType, recShape));
        return PlutusData2.newConstrPlutusData(
          new ConstrPlutusData(BigInt(someIdx), someList)
        );
      }
    }
    switch (typeof struct) {
      case "string": {
        if (!/[A-Z]/.test(struct[0])) {
          throw new Error(
            "Could not type cast to enum. Enum needs to start with an uppercase letter."
          );
        }
        const enumIndex = schemaEnum["anyOf"].findIndex(
          (s) => s["dataType"] === "constructor" && s["fields"].length === 0 && s.title === struct
        );
        if (enumIndex === -1) throw new Error("Could not type cast to enum.");
        return PlutusData2.newConstrPlutusData(
          new ConstrPlutusData(BigInt(enumIndex), new PlutusList())
        );
      }
      case "object": {
        if (struct === null) throw new Error("Could not type cast to enum.");
        const structTitle = Object.keys(struct)[0];
        if (!/[A-Z]/.test(structTitle)) {
          throw new Error(
            "Could not type cast to enum. Enum needs to start with an uppercase letter."
          );
        }
        const enumEntry = schemaEnum["anyOf"].find(
          (s) => s["dataType"] === "constructor" && s.title === structTitle
        );
        if (!enumEntry) throw new Error("Could not type cast to enum.");
        const args = struct[structTitle];
        const fields = args instanceof Array ? args.map(
          (item, index) => castTo(item, enumEntry["fields"][index], recType, recShape)
        ) : enumEntry["fields"].map((entry) => {
          const [, item] = Object.entries(args).find(
            ([title]) => "title" in entry && title === entry.title
          );
          return castTo(item, entry, recType, recShape);
        });
        const plutusList = new PlutusList();
        fields.forEach((f) => plutusList.add(f));
        return PlutusData2.newConstrPlutusData(
          new ConstrPlutusData(BigInt(enumEntry["index"]), plutusList)
        );
      }
    }
  }
  if (!("dataType" in schema)) {
    throw new Error("Could not type cast struct.");
  }
  switch (schema["dataType"]) {
    case "integer": {
      if (typeof struct !== "bigint") {
        throw new Error("Could not type cast to integer.");
      }
      return PlutusData2.newInteger(struct);
    }
    case "bytes": {
      if (typeof struct !== "string") {
        throw new Error("Could not type cast to bytes.");
      }
      return PlutusData2.newBytes(fromHex(struct));
    }
    case "constructor": {
      if (schema["fields"].length == 0 && typeof struct == "string") {
        if (struct != schema.title) {
          throw new Error(
            `Could not cast string ${struct} to constructor with title ${schema.title}`
          );
        }
        return PlutusData2.newConstrPlutusData(
          new ConstrPlutusData(BigInt(schema["index"]), new PlutusList())
        );
      }
      if (isVoidConstructor(schema)) {
        if (struct !== void 0) {
          throw new Error("Could not type cast to void.");
        }
        return PlutusData2.newConstrPlutusData(
          new ConstrPlutusData(0n, new PlutusList())
        );
      } else if (typeof struct !== "object" || struct === null || schema["fields"].length !== Object.keys(struct).length) {
        throw new Error("Could not type cast to constructor.");
      }
      const fields = new PlutusList();
      for (const field of schema["fields"]) {
        fields.add(
          castTo(
            struct["title" in field ? field.title : "wrapper"],
            field,
            recType,
            recShape
          )
        );
      }
      return PlutusData2.newConstrPlutusData(
        new ConstrPlutusData(BigInt(schema["index"]), fields)
      );
    }
    case "list": {
      if (!(struct instanceof Array)) {
        throw new Error("Could not type cast to array/tuple.");
      }
      if (schema["items"] instanceof Array) {
        const tupleItems = schema["items"];
        const fields = new PlutusList();
        if (tupleItems.length != struct.length) {
          throw new Error(
            `Could not cast wrong number of values (${struct.length}) to tuple of length ${tupleItems.length}`
          );
        }
        for (let index = 0; index < schema["items"].length; index++) {
          fields.add(
            castTo(struct[index], schema["items"][index], recType, recShape)
          );
        }
        return PlutusData2.newList(fields);
      } else {
        const arrayType = schema["items"];
        const list = new PlutusList();
        struct.forEach(
          (item) => list.add(castTo(item, arrayType, recType, recShape))
        );
        return PlutusData2.newList(list);
      }
    }
    case "map": {
      if (!(struct instanceof Map)) {
        throw new Error("Could not type cast to map.");
      }
      const map = new PlutusMap();
      for (const [key, value] of struct.entries()) {
        map.insert(
          castTo(key, schema["keys"], recType, recShape),
          castTo(value, schema["values"], recType, recShape)
        );
      }
      return PlutusData2.newMap(map);
    }
  }
  throw new Error("Could not type cast struct.");
}
function castFrom(rawData, schema) {
  if (!schema) throw new Error("Could not type cast data.");
  const kind = rawData.getKind();
  if ("anyOf" in schema) {
    const schemaEnum = schema;
    if (schemaEnum["anyOf"].length === 1) {
      return castFrom(rawData, schema["anyOf"][0]);
    }
    if (!(kind == PlutusDataKind.ConstrPlutusData)) {
      throw new Error("Could not type cast to enum.");
    }
    const data = rawData.asConstrPlutusData();
    const index = data.getAlternative();
    const fields = data.getData();
    const fieldsLen = fields.getLength();
    const enumShape = schemaEnum["anyOf"].find(
      (entry) => BigInt(entry["index"]) === index
    );
    if (!enumShape || enumShape["fields"].length !== fieldsLen) {
      throw new Error("Could not type cast to enum.");
    }
    if (isBoolean(schemaEnum)) {
      if (fieldsLen !== 0) {
        throw new Error("Could not type cast to boolean.");
      }
      switch (index) {
        case 0n:
          return false;
        case 1n:
          return true;
      }
      throw new Error("Could not type cast to boolean.");
    } else if (isOptional(schemaEnum)) {
      switch (index) {
        case 0n: {
          if (fieldsLen !== 1) {
            throw new Error("Could not type cast to nullable object.");
          }
          return castFrom(fields.get(0), schema["anyOf"][0].fields[0]);
        }
        case 1n: {
          if (fieldsLen !== 0) {
            throw new Error("Could not type cast to nullable object.");
          }
          return null;
        }
      }
      throw new Error("Could not type cast to nullable object.");
    }
    switch (enumShape["dataType"]) {
      case "constructor": {
        if (enumShape["fields"].length === 0) {
          if (/[A-Z]/.test(enumShape.title[0])) {
            return enumShape.title;
          }
          throw new Error("Could not type cast to enum.");
        } else {
          if (!/[A-Z]/.test(enumShape.title)) {
            throw new Error(
              "Could not type cast to enum. Enums need to start with an uppercase letter."
            );
          }
          if (enumShape["fields"].length !== fieldsLen) {
            throw new Error("Could not type cast to enum.");
          }
          const args = "title" in enumShape["fields"][0] ? Object.fromEntries(
            enumShape["fields"].map((field, index2) => [
              field.title,
              castFrom(fields.get(index2), field)
            ])
          ) : enumShape["fields"].map(
            (field, index2) => castFrom(fields.get(index2), field)
          );
          return {
            [enumShape.title]: args
          };
        }
      }
    }
  }
  switch (schema["dataType"]) {
    case "integer": {
      if (kind !== PlutusDataKind.Integer) {
        throw new Error("Could not type cast to integer.");
      }
      return rawData.asInteger();
    }
    case "bytes": {
      if (kind !== PlutusDataKind.Bytes) {
        throw new Error("Could not type cast to integer.");
      }
      return toHex(rawData.asBoundedBytes());
    }
    case "constructor": {
      if (kind !== PlutusDataKind.ConstrPlutusData) {
        throw new Error("Could not type cast to constructor.");
      }
      const constr = rawData.asConstrPlutusData();
      if (isVoidConstructor(schema)) {
        if (constr.getAlternative() !== 0n || constr.getData().getLength() !== 0) {
          throw new Error("Could not type cast to void.");
        }
        return void 0;
      } else if (constr.getAlternative() === BigInt(schema["index"])) {
        const fields = {};
        if (schema["fields"].length !== constr.getData().getLength()) {
          throw new Error(
            "Could not type cast to object. Fields do not match."
          );
        }
        schema["fields"].forEach((field, fieldIndex) => {
          const title = field.title || "wrapper";
          if (/[A-Z]/.test(title[0])) {
            throw new Error(
              "Could not type cast to object. Object properties need to start with a lowercase letter."
            );
          }
          fields[title] = castFrom(constr.getData().get(fieldIndex), field);
        });
        return fields;
      }
      throw new Error("Could not type cast to object.");
    }
    case "list": {
      if (kind !== PlutusDataKind.List) {
        throw new Error("Could not type cast to list.");
      }
      const data = rawData.asList();
      if (schema["items"] instanceof Array) {
        const res = [];
        for (let i = 0; i < data.getLength(); i++) {
          res.push(castFrom(data.get(i), schema["items"][i]));
        }
        return res;
      } else {
        const res = [];
        for (let i = 0; i < data.getLength(); i++) {
          res.push(castFrom(data.get(i), schema["items"]));
        }
        return res;
      }
    }
    case "map": {
      if (!(kind == PlutusDataKind.Map)) {
        throw new Error("Could not type cast to map.");
      }
      const data = rawData.asMap();
      const map = /* @__PURE__ */ new Map();
      const keys = data.getKeys();
      for (let i = 0; i < keys.getLength(); i++) {
        map.set(
          castFrom(keys.get(i), schema["keys"]),
          castFrom(data.get(keys.get(i)), schema["values"])
        );
      }
      return map;
    }
    case void 0: {
      return rawData;
    }
  }
  throw new Error("Could not type cast data.");
}
export {
  Constr,
  Data,
  TxBuilder,
  value_exports as Value,
  calculateReferenceScriptFee,
  computeScriptData,
  getScriptSize,
  makeValue
};
