import { Value, AssetId } from '@blaze-cardano/core';

/**
 * Merges two Value objects into a single Value object by combining their coins and multiassets.
 *
 * @param {Value} a - The first Value object.
 * @param {Value} b - The second Value object.
 * @returns {Value} - The resulting Value object after merging.
 */
declare function merge(a: Value, b: Value): Value;
/**
 * Negates the coin and multiasset values of a Value object.
 *
 * @param {Value} v - The Value object to negate.
 * @returns {Value} - The resulting Value object after negation.
 */
declare function negate(v: Value): Value;
/**
 * Subtracts the values of one Value object from another.
 *
 * @param {Value} a - The Value object to subtract from.
 * @param {Value} b - The Value object to subtract.
 * @returns {Value} - The resulting Value object after subtraction.
 */
declare function sub(a: Value, b: Value): Value;
/**
 * Determines the intersection of assets between two Value objects.
 *
 * @param {Value} a - The first Value object.
 * @param {Value} b - The second Value object.
 * @returns {number} - The count of intersecting assets.
 */
declare function intersect(a: Value, b: Value): number;
/**
 * Filters out the positive coin and multiasset values from a Value object.
 *
 * @param {Value} v - The Value object to filter.
 * @returns {Value} - A new Value object containing only positive values.
 */
declare function positives(v: Value): Value;
/**
 * Filters out the negative coin and multiasset values from a Value object.
 *
 * @param {Value} v - The Value object to filter.
 * @returns {Value} - A new Value object containing only negative values.
 */
declare function negatives(v: Value): Value;
/**
 * Lists all assets (including 'lovelace' if present) in a Value object.
 *
 * @param {Value} v - The Value object to inspect.
 * @returns {(AssetId | 'lovelace')[]} - An array of asset identifiers.
 */
declare function assets(v: Value): (AssetId | "lovelace")[];
/**
 * Counts the number of distinct asset types in a Value object.
 *
 * @param {Value} v - The Value object to count asset types in.
 * @returns {number} - The count of distinct asset types.
 */
declare function assetTypes(v: Value): number;
/**
 * Determines if a Value object is empty (no coin and no multiassets).
 *
 * @param {Value} v - The Value object to check.
 * @returns {boolean} - True if the Value object is empty, false otherwise.
 */
declare function empty(v: Value): boolean;
/**
 * A constant Value object with zero coins and no assets.
 *
 * @returns {Value} - The zero Value object.
 */
declare const zero: () => Value;
/**
 * Creates a new Value object with the specified amount of lovelace and assets.
 *
 * @param {bigint} lovelace - The amount of lovelace.
 * @param {...[string, bigint][]} assets - The assets to include in the Value object.
 * @returns {Value} - The newly created Value object.
 */
declare function makeValue(lovelace: bigint, ...assets: [string, bigint][]): Value;

declare const value_assetTypes: typeof assetTypes;
declare const value_assets: typeof assets;
declare const value_empty: typeof empty;
declare const value_intersect: typeof intersect;
declare const value_makeValue: typeof makeValue;
declare const value_merge: typeof merge;
declare const value_negate: typeof negate;
declare const value_negatives: typeof negatives;
declare const value_positives: typeof positives;
declare const value_sub: typeof sub;
declare const value_zero: typeof zero;
declare namespace value {
  export { value_assetTypes as assetTypes, value_assets as assets, value_empty as empty, value_intersect as intersect, value_makeValue as makeValue, value_merge as merge, value_negate as negate, value_negatives as negatives, value_positives as positives, value_sub as sub, value_zero as zero };
}

export { merge as a, negatives as b, assets as c, assetTypes as d, empty as e, intersect as i, makeValue as m, negate as n, positives as p, sub as s, value as v, zero as z };
