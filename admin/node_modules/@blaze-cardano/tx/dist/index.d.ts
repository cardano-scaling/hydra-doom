import { TransactionUnspentOutput, Value, Script, ProtocolParameters, HexBlob, Hash32ByteBase16, Redeemers, TransactionWitnessSet, Costmdls, Address, Evaluator, NetworkId, PlutusData, PolicyId, AssetName, TransactionOutput, Datum, Transaction, Credential, PoolId, Slot, RewardAccount, Ed25519KeyHashHex, AuxiliaryData } from '@blaze-cardano/core';
export { v as Value, m as makeValue } from './value-C_J_5qtu.js';
import * as _sinclair_typebox from '@sinclair/typebox';
import { TSchema, Static as Static$1, TProperties, TLiteralValue, TLiteral } from '@sinclair/typebox';

/**
 * The result of a coin selection operation.
 * It includes the selected inputs, the total value of the selected inputs, and the remaining inputs.
 */
type SelectionResult = {
    selectedInputs: TransactionUnspentOutput[];
    selectedValue: Value;
    inputs: TransactionUnspentOutput[];
};

declare function getScriptSize(script: Script): number;
/**
 * Calculates the fee for reference scripts in the transaction.
 * This method iterates through the reference inputs, finds the corresponding UTXOs,
 * and calculates the fee based on the size of the Plutus scripts referenced.
 *
 * The fee calculation follows a tiered approach where the base fee increases
 * for each range of script size, as defined in the protocol parameters.
 * See https://github.com/CardanoSolutions/ogmios/releases/tag/v6.5.0
 *
 * @param {readonly TransactionInput[]} refScripts - An array of reference inputs in the transaction.
 * @returns {number} The calculated fee for all reference scripts.
 * @throws {Error} If a reference input cannot be resolved or if a reference script is not a Plutus script.
 */
declare function calculateReferenceScriptFee(refScripts: Script[], params: ProtocolParameters): number;
interface IScriptData {
    redeemersEncoded: string;
    datumsEncoded: string | undefined;
    costModelsEncoded: string;
    hashedData: HexBlob;
    scriptDataHash: Hash32ByteBase16;
}
/**
 * Calculates the correct script data hash for a transaction
 *
 * Separate from the `getScriptData` method in `TxBuilder` to allow for more thorough testing
 * This is heavily documented here:
 * https://github.com/IntersectMBO/cardano-ledger/blob/master/eras/conway/impl/cddl-files/conway.cddl#L423-L490
 *
 * @param redeemers - The redeemers of the transaction
 * @param datums - The datums in the witness set of the transaction
 * @param usedCostModels - The cost models for any languages used in the transaction
 */
declare function computeScriptData(redeemers: Redeemers, datums: ReturnType<TransactionWitnessSet["plutusData"]>, // TODO: weird import shenanigans
usedCostModels: Costmdls): IScriptData | undefined;

/**
 * A builder class for constructing Cardano transactions with various components like inputs, outputs, and scripts.
 */
declare class TxBuilder {
    readonly params: ProtocolParameters;
    private preCompleteHooks;
    private body;
    private auxiliaryData?;
    private redeemers;
    private utxos;
    private utxoScope;
    private collateralUtxos;
    private scriptScope;
    private scriptSeen;
    private changeAddress?;
    private collateralChangeAddress?;
    private rewardAddress?;
    private networkId?;
    private changeOutputIndex?;
    private plutusData;
    private requiredWitnesses;
    private requiredNativeScripts;
    private requiredPlutusScripts;
    private usedLanguages;
    private extraneousDatums;
    private fee;
    private additionalSigners;
    private evaluator?;
    private consumedMintHashes;
    private consumedWithdrawalHashes;
    private consumedSpendInputs;
    private minimumFee;
    private feePadding;
    private coinSelector;
    private _burnAddress?;
    /**
     * Constructs a new instance of the TxBuilder class.
     * Initializes a new transaction body with an empty set of inputs, outputs, and no fee.
     */
    constructor(params: ProtocolParameters);
    get burnAddress(): Address;
    private insertSorted;
    /**
     * Sets the change address for the transaction.
     * This address will receive any remaining funds not allocated to outputs or fees.
     *
     * @param {Address} address - The address to receive the change.
     * @param {boolean} [override=true] - Whether to override the change address if one is already set.
     * @returns {TxBuilder} The same transaction builder
     */
    setChangeAddress(address: Address, override?: boolean): TxBuilder;
    /**
     * Sets the collateral change address for the transaction.
     * This address will receive the collateral change if there is any.
     *
     * @param {Address} address - The address to receive the collateral change.
     * @returns {TxBuilder} The same transaction builder
     */
    setCollateralChangeAddress(address: Address): TxBuilder;
    /**
     * Sets the reward address for the transaction.
     * This address will be used for delegation purposes and also stake key component of the transaction.
     *
     * @param {Address} address - The reward address
     * @returns {TxBuilder} The same transaction builder
     */
    setRewardAddress(address: Address): TxBuilder;
    /**
     * Sets the evaluator for the transaction builder.
     * The evaluator is used to execute Plutus scripts during transaction building.
     *
     * @param {Evaluator} evaluator - The evaluator to be used for script execution.
     * @param {boolean} [override=true] - Whether to override the evaluator if one is already set.
     * @returns {TxBuilder} The same transaction builder
     */
    useEvaluator(evaluator: Evaluator, override?: boolean): TxBuilder;
    /**
     * Sets a custom coin selector function for the transaction builder.
     * This function will be used to select inputs during the transaction building process.
     *
     * @param {(inputs: TransactionUnspentOutput[], dearth: Value): SelectionResult} selector - The coin selector function to use.
     * @returns {TxBuilder} The same transaction builder
     */
    useCoinSelector(selector: (inputs: TransactionUnspentOutput[], dearth: Value) => SelectionResult): TxBuilder;
    /**
     * Sets the network ID for the transaction builder.
     * The network ID is used to determine which network the transaction is intended for.
     *
     * @param {NetworkId} networkId - The network ID to set.
     * @returns {TxBuilder} The same transaction builder
     */
    setNetworkId(networkId: NetworkId): TxBuilder;
    /**
     * The additional signers field is used to add additional signing counts for fee calculation.
     * These will be included in the signing phase at a later stage.
     * This is needed due to native scripts signees being non-deterministic.
     * @param {number} amount - The amount of additional signers
     * @returns {TxBuilder} The same transaction builder
     */
    addAdditionalSigners(amount: number): TxBuilder;
    /**
     * Sets the minimum fee for the transaction.
     * This fee will be used during the transaction building process.
     *
     * @param {bigint} fee - The minimum fee to be set.
     * @returns {TxBuilder} The same transaction builder
     */
    setMinimumFee(fee: bigint): TxBuilder;
    /**
     * Sets an additional padding to add onto the transactions.
     * Use this only in emergencies, and please open a ticket at https://github.com/butaneprotocol/blaze-cardano so we can correct the fee calculation!
     *
     * @param {bigint} pad - The padding to add onto the transaction fee
     * @returns {TxBuilder} the same transaction builder
     */
    setFeePadding(pad: bigint): TxBuilder;
    /**
     * Adds a reference input to the transaction. Reference inputs are used to refer to outputs from previous transactions
     * without spending them, allowing scripts to read their data. This can be useful for various contract logic, such as
     * checking the state of a datum without consuming the UTxO that holds it.
     *
     * @param {TransactionUnspentOutput} utxo - The unspent transaction output to add as a reference input.
     * @returns {TxBuilder} The same transaction builder
     * @throws {Error} If the input to be added is already present in the list of reference inputs, to prevent duplicates.
     */
    addReferenceInput(utxo: TransactionUnspentOutput): TxBuilder;
    /**
     * Adds an input to the transaction. This method is responsible for including a new input, which represents
     * a reference to an unspent transaction output (UTxO) that will be consumed by the transaction. Optionally,
     * a redeemer and an unhashed datum can be provided for script validation purposes.
     *
     * @param {TransactionUnspentOutput} utxo - The UTxO to be consumed as an input.
     * @param {PlutusData} [redeemer] - Optional. The redeemer data for script validation, required for spending Plutus script-locked UTxOs.
     * @param {PlutusData} [unhashDatum] - Optional. The unhashed datum, required if the UTxO being spent includes a datum hash instead of inline datum.
     * @returns {TxBuilder} The same transaction builder
     * @throws {Error} If attempting to add a duplicate input, if the UTxO payment key is missing, if attempting to spend with a redeemer for a KeyHash credential,
     *                 if attempting to spend without a datum when required, or if providing both an inline datum and an unhashed datum.
     */
    addInput(utxo: TransactionUnspentOutput, redeemer?: PlutusData, unhashDatum?: PlutusData): TxBuilder;
    /**
     * Adds unspent transaction outputs (UTxOs) to the set of UTxOs available for this transaction.
     * These UTxOs can then be used for balancing the transaction, ensuring that inputs and outputs are equal.
     *
     * @param {TransactionUnspentOutput[]} utxos - The unspent transaction outputs to add.
     * @returns {TxBuilder} The same transaction builder
     */
    addUnspentOutputs(utxos: TransactionUnspentOutput[]): TxBuilder;
    /**
     * Adds unspent transaction outputs (UTxOs) to the set of collateral UTxOs available for this transaction.
     * These UTxOs can then be used to provide collateral for the transaction, if necessary. If provided, they will b
     * If there are specific, valid collateral UTxOs provided, Blaze will use them before using any other UTxO.
     *
     * @param {TransactionUnspentOutput[]} utxos - the UTxOs to add as collateral
     * @returns {TxBuilder} The same transaction builder
     */
    provideCollateral(utxos: TransactionUnspentOutput[]): this;
    /**
     * Adds minting information to the transaction. This includes specifying the policy under which assets are minted,
     * the assets to be minted, and an optional redeemer for Plutus scripts.
     *
     * @param {PolicyId} policy - The policy ID under which the assets are minted.
     * @param {Map<AssetName, bigint>} assets - A map of asset names to the amounts being minted.
     * @param {PlutusData} [redeemer] - Optional. A redeemer to be used if the minting policy requires Plutus script validation.
     */
    addMint(policy: PolicyId, assets: Map<AssetName, bigint>, redeemer?: PlutusData): this;
    /**
     * This methods calculates the minimum ada required for a transaction output.
     * @param {TransactionOutput} output - The transaction output to calculate the minimum ada for.
     * @returns {bigint} The minimum ada required for the output.
     */
    private calculateMinAda;
    /**
     * This method checks and alters the output of a transaction.
     * It ensures that the output meets the minimum ada requirements and does not exceed the maximum value size.
     *
     * @param {TransactionOutput} output - The transaction output to be checked and altered.
     * @returns {TransactionOutput} The altered transaction output.
     * @throws {Error} If the output does not meet the minimum ada requirements or exceeds the maximum value size.
     */
    private checkAndAlterOutput;
    /**
     * Adds a transaction output to the current transaction body. This method also ensures that the minimum ada
     * requirements are met for the output. After adding the output, it updates the transaction body's outputs.
     * It also checks if the output value exceeds the maximum value size.
     *
     * @param {TransactionOutput} output - The transaction output to be added.
     * @returns {TxBuilder} The same transaction builder
     */
    addOutput(output: TransactionOutput): TxBuilder;
    /**
     * Returns the number of transaction outputs in the current transaction body.
     *
     * @returns {number} The number of transaction outputs.
     */
    get outputsCount(): number;
    /**
     * Adds a payment in lovelace to the transaction output.
     * This method ensures that the address is valid and the payment is added to the transaction output.
     *
     * @param {Address} address - The address to send the payment to.
     * @param {bigint} lovelace - The amount of lovelace to send.
     * @param {Datum} [datum] - Optional datum to be associated with the paid assets.
     * @returns {TxBuilder} The same transaction builder
     */
    payLovelace(address: Address, lovelace: bigint, datum?: Datum): TxBuilder;
    /**
     * Adds a payment in assets to the transaction output.
     * This method ensures that the address is valid and the payment is added to the transaction output.
     *
     * @param {Address} address - The address to send the payment to.
     * @param {Value} value - The value of the assets to send.
     * @param {Datum} [datum] - Optional datum to be associated with the paid assets.
     * @returns {TxBuilder} The same transaction builder
     */
    payAssets(address: Address, value: Value, datum?: Datum): TxBuilder;
    /**
     * Locks a specified amount of lovelace to a script.
     * The difference between 'pay' and 'lock' is that you pay to a public key/user,
     * and you lock at a script.
     * This method ensures that the address is valid and the lovelace is locked to the script.
     *
     * @param {Address} address - The address to lock the lovelace to.
     * @param {bigint} lovelace - The amount of lovelace to lock.
     * @param {Datum} datum - The datum to be associated with the locked lovelace.
     * @param {Script} scriptReference - The reference to the script to lock the lovelace to.
     * @returns {TxBuilder} The same transaction builder
     */
    lockLovelace(address: Address, lovelace: bigint, datum: Datum, scriptReference?: Script): TxBuilder;
    /**
     * Locks a specified amount of assets to a script.
     * The difference between 'pay' and 'lock' is that you pay to a public key/user,
     * and you lock at a script.
     * This method ensures that the address is valid and the assets are locked to the script.
     *
     * @param {Address} address - The address to lock the assets to.
     * @param {Value} value - The value of the assets to lock.
     * @param {Datum} datum - The datum to be associated with the locked assets.
     * @param {Script} scriptReference - The reference to the script to lock the assets to.
     * @returns {TxBuilder} The same transaction builder
     */
    lockAssets(address: Address, value: Value, datum: Datum, scriptReference?: Script): TxBuilder;
    /**
     * Deploys a script by creating a new UTxO with the script as its reference.
     *
     * @param {Script} script - The script to be deployed.
     * @param {Address} [address] - The address to lock the script to. Defaults to a burn address where the UTxO will be unspendable.
     * @returns {TxBuilder} The same transaction builder.
     *
     *
     * @example
     * ```typescript
     * const myScript = Script.newPlutusV2Script(new PlutusV2Script("..."));
     * txBuilder.deployScript(myScript);
     * // or
     * txBuilder.deployScript(myScript, someAddress);
     * ```
     */
    deployScript(script: Script, address?: Address): TxBuilder;
    /**
     * Adds a Plutus datum to the transaction. This datum is not directly associated with any particular output but may be used
     * by scripts during transaction validation. This method is useful for including additional information that scripts may
     * need to validate the transaction without requiring it to be attached to a specific output.
     *
     * @param {PlutusData} datum - The Plutus datum to be added to the transaction.
     * @returns {TxBuilder} The same transaction builder
     */
    provideDatum(datum: PlutusData): TxBuilder;
    /**
     * Evaluates the scripts for the given draft transaction and calculates the execution units and fees required.
     * This function iterates over all UTXOs within the transaction's scope, simulates the execution of associated scripts,
     * and aggregates the execution units. It then calculates the total fee based on the execution units and updates the
     * transaction's redeemers with the new execution units.
     *
     * @param {Transaction} draft_tx - The draft transaction to evaluate.
     * @returns {Promise<bigint>} The total fee calculated based on the execution units of the scripts.
     */
    private evaluate;
    /**
     * Builds the transaction witness set required for the transaction.
     * This includes collecting all necessary scripts (native, Plutus V1, V2, V3),
     * vkey witnesses, redeemers, and Plutus data required for script validation.
     * It organizes these components into a structured format that can be
     * serialized and included in the transaction.
     *
     * @returns {TransactionWitnessSet} A constructed transaction witness set.
     * @throws {Error} If a required script cannot be resolved by its hash.
     */
    protected buildTransactionWitnessSet(): TransactionWitnessSet;
    /**
     * Calculates the net value difference between the inputs and outputs of a transaction,
     * including minted values, withdrawals, and subtracting a fixed fee amount.
     * This function is used to determine the excess value that needs to be returned as change.
     *
     * @returns {Value} The net value that represents the transaction's pitch.
     * @throws {Error} If a corresponding UTxO for an input cannot be found.
     */
    private getPitch;
    private balanced;
    /**
     * Generates a script data hash for the transaction if there are any datums or redeemers present.
     * This hash is crucial for the validation of Plutus scripts in the transaction.
     *
     * @param {TransactionWitnessSet} tw - The transaction witness set containing Plutus data.
     * @returns {IScriptData | undefined} The full lscript data if datums or redeemers are present, otherwise undefined.
     */
    protected getScriptData(tw: TransactionWitnessSet): IScriptData | undefined;
    /**
     * Helper method to just get the script data hash from a TransactionWitnessSet.
     *
     * @param {TransactionWitnessSet} tw - The transaction witness set containing Plutus data.
     * @returns {Hash32ByteBase16 | undefined} The script data hash if datums or redeemers are present, otherwise undefined.
     */
    private getScriptDataHash;
    /**
     * Adjusts the balance of the transaction by creating or updating a change output.
     * This method takes the excess value from the transaction, removes any zero-valued
     * tokens from the multiasset map, and then either creates a new change output or
     * updates an existing one with the adjusted value.
     *
     * @param {Value} excessValue - The excess value that needs to be returned as change.
     */
    private balanceChange;
    /**
     * Calculates the transaction fees based on the transaction size and parameters.
     * It updates the transaction body with the calculated fee.
     *
     * @param {Transaction} draft_tx - The draft transaction to calculate fees for.
     */
    private calculateFees;
    /**
     * Prepares the collateral for the transaction by selecting suitable UTXOs.
     * Throws an error if suitable collateral cannot be found or if some inputs cannot be resolved.
     */
    private prepareCollateral;
    /**
     * Returns the effective coin value of the utxo substracting the min utxo needed for the multiasset in the utxo
     *
     * @param {TransactionUnspentOutput} utxo - The utxo to calculate the effective coin value
     * @returns {bigint} The effective coin value of the utxo
     * */
    private getUtxoEffectiveCoin;
    /**
     * Adjusts the balance of the transaction by creating or updating a change output.
     * This method takes only the native assets from excess value from the transaction, removes any zero-valued
     * tokens from the multiasset map, and then creates change outputs that don't exceed the minValueSize.
     *
     * Updates the changeOutputIndex to the index of the last change output.
     *
     * @param {Value} excessValue - The excess value that needs to be returned as change.
     * returns {Value} The remaining excess value after creating change outputs. (Which should only be ADA)
     */
    private balanceMultiAssetChange;
    /**
     * Balances the collateral change by creating a transaction output that returns the excess collateral.
     * Throws an error if the change address is not set.
     */
    private balanceCollateralChange;
    /**
     * Prints the transaction cbor in its current state without trying to complete it
     * @returns {string} The CBOR representation of the transaction
     * */
    toCbor(): string;
    /**
     * Completes the transaction by performing several key operations:
     * - Verifies the presence of a change address.
     * - Gathers inputs and performs coin selection if necessary.
     * - Balances the change output.
     * - Builds the transaction witness set.
     * - Calculates the script data hash.
     * - Estimates and sets the transaction fee.
     * - Merges the fee value with the excess value and rebalances the change.
     *
     * @throws {Error} If the change address is not set, or if the coin selection fails to eliminate negative values,
     *                 or if balancing the change output fails.
     * @returns {Promise<Transaction>} A new Transaction object with all components set and ready for submission.
     */
    complete(): Promise<Transaction>;
    /**
     * Adds a certificate to delegate a staker to a pool
     *
     * @param {Credential} delegator - The credential of the staker to delegate.
     * @param {PoolId} poolId - The ID of the pool to delegate to.
     * @param {PlutusData} [redeemer] - Optional. A redeemer to be used if the delegation requires Plutus script validation.
     * @returns {TxBuilder} The updated transaction builder.
     */
    addDelegation(delegator: Credential, poolId: PoolId, redeemer?: PlutusData): TxBuilder;
    /**
     * This method delegates the selected reward address to a pool.
     * It first checks if the reward address is set and if it has a stake component.
     * If both conditions are met, it adds a delegation to the transaction.
     *
     * @param {PoolId} poolId - The ID of the pool to delegate the reward address to.
     * @throws {Error} If the reward address is not set or if the method is unimplemented.
     */
    delegate(poolId: PoolId, redeemer?: PlutusData): this;
    /**
     * Adds a certificate to register a staker.
     * @param {Credential} credential - The credential to register.
     * @throws {Error} Method not implemented.
     */
    addRegisterStake(credential: Credential): this;
    /**
     * Adds a certificate to deregister a staker.
     * @throws {Error} Method not implemented.
     */
    addDeregisterStake(): void;
    /**
     * Adds a certificate to register a pool.
     * @throws {Error} Method not implemented.
     */
    addRegisterPool(): void;
    /**
     * Adds a certificate to retire a pool.
     * @throws {Error} Method not implemented.
     */
    addRetirePool(): void;
    /**
     * Specifies the exact time when the transaction becomes valid.
     *
     * @param {Slot} validFrom - The slot from which the transaction becomes valid.
     * @throws {Error} If the validity start interval is already set.
     * @returns {TxBuilder} The instance of this TxBuilder for chaining.
     */
    setValidFrom(validFrom: Slot): TxBuilder;
    /**
     * Specifies the exact time when the transaction expires.
     *
     * @param {Slot} validUntil - The slot until which the transaction is valid.
     * @throws {Error} If the time to live is already set.
     * @returns {TxBuilder} The instance of this TxBuilder for chaining.
     */
    setValidUntil(validUntil: Slot): TxBuilder;
    /**
     * Adds a withdrawal to the transaction. This method allows for the withdrawal of funds from a staking reward account.
     * Optionally, a redeemer can be provided for script validation purposes.
     *
     * @param {C.Cardano.RewardAccount} address - The reward account from which to withdraw.
     * @param {bigint} amount - The amount of ADA to withdraw.
     * @param {PlutusData} [redeemer] - Optional. The redeemer data for script validation.
     * @returns {TxBuilder} The same transaction builder
     * @throws {Error} If the reward account does not have a stake credential or if any other error occurs.
     */
    addWithdrawal(address: RewardAccount, amount: bigint, redeemer?: PlutusData): TxBuilder;
    /**
     * Adds a required signer to the transaction. This is necessary for transactions that must be explicitly signed by a particular key.
     *
     * @param {Ed25519KeyHashHex} signer - The hash of the Ed25519 public key that is required to sign the transaction.
     * @returns {TxBuilder} The same transaction builder
     */
    addRequiredSigner(signer: Ed25519KeyHashHex): TxBuilder;
    /**
     * Computes the hash of the auxiliary data if it exists.
     *
     * @param {AuxiliaryData} auxiliaryData - The auxiliary data to hash.
     * @returns {Hash32ByteBase16 | undefined} The hash of the auxiliary data or undefined if no auxiliary data is provided.
     */
    private getAuxiliaryDataHash;
    /**
     * Sets the auxiliary data for the transaction and updates the transaction's auxiliary data hash.
     *
     * @param {AuxiliaryData} auxiliaryData - The auxiliary data to set.
     * @returns {TxBuilder} The same transaction builder
     */
    setAuxiliaryData(auxiliaryData: AuxiliaryData): TxBuilder;
    /**
     * Adds a script to the transaction's script scope. If the script is already provided via a reference script,
     * it will not be explicitly used again. This method ensures that each script is only included once in the
     * transaction, either directly or by reference, to optimize the transaction size and processing.
     *
     * @param {Script} script - The script to be added to the transaction's script scope.
     * @returns {TxBuilder} The same transaction builder
     */
    provideScript(script: Script): TxBuilder;
    /**
     * Adds a pre-complete hook to the transaction builder. This hook will be executed
     * before the transaction is finalized.
     *
     * Pre-complete hooks are useful for performing last-minute modifications or
     * validations on the transaction before it's completed. Multiple hooks can be
     * added, and they will be executed in the order they were added.
     *
     * @param {(tx: TxBuilder) => Promise<void>} hook - A function that takes the TxBuilder
     * instance as an argument and performs some operation. The hook should be asynchronous.
     * @returns {TxBuilder} The same transaction builder instance for method chaining.
     */
    addPreCompleteHook(hook: (tx: TxBuilder) => Promise<void>): TxBuilder;
}

declare class Constr<T> {
    index: number;
    fields: Array<T>;
    constructor(index: number, fields: T[]);
}
type PConstructor = {
    dataType: "constructor";
    index: number;
    fields: PSchema[];
    title?: string;
};
type PList = {
    dataType: "list";
    items: PSchema[] | PSchema;
    title?: string;
};
type PEnum = {
    title?: string;
    anyOf: PConstructor[];
};
type PMap = {
    dataType: "map";
    keys: PSchema;
    values: PSchema;
};
type PSchema = {
    dataType: "integer" | "bytes" | `#${"unit" | "boolean" | "integer" | "bytes" | "string" | "pair" | "list"}`;
} | PList | PConstructor | PEnum | PMap;
type Static<T extends TSchema, P extends unknown[] = []> = Static$1<T, P>;
type Data = bigint | string | Array<Data> | Map<Data, Data> | Constr<Data>;
declare const Data: {
    Integer: (options?: {
        minimum?: number;
        maximum?: number;
        exclusiveMinimum?: number;
        exclusiveMaximum?: number;
    }) => _sinclair_typebox.TUnsafe<bigint>;
    Bytes: (options?: {
        minLength?: number;
        maxLength?: number;
        enum?: string[];
    }) => _sinclair_typebox.TUnsafe<string>;
    Boolean: () => _sinclair_typebox.TUnsafe<boolean>;
    Any: () => TSchema;
    Array: <T extends TSchema>(items: T, options?: {
        minItems?: number;
        maxItems?: number;
        uniqueItems?: boolean;
    }) => _sinclair_typebox.TArray<T>;
    Map: <T extends TSchema, U extends TSchema>(keys: T, values: U, options?: {
        minItems?: number;
        maxItems?: number;
    }) => _sinclair_typebox.TUnsafe<Map<Static<T, []>, Static<U, []>>>;
    /**
     * Object applies by default a PlutusData Constr with index 0.\
     * Set 'hasConstr' to false to serialize Object as PlutusData List.
     */
    Object: <T extends TProperties>(properties: T, options?: {
        hasConstr?: boolean;
    }) => _sinclair_typebox.TObject<T>;
    Enum: <T extends TSchema>(items: T[]) => _sinclair_typebox.TUnion<T[]>;
    /**
     * Tuple is by default a PlutusData List.\
     * Set 'hasConstr' to true to apply a PlutusData Constr with index 0.
     */
    Tuple: <T extends TSchema[]>(items: [...T], options?: {
        hasConstr?: boolean;
    }) => _sinclair_typebox.TTuple<T>;
    Literal: <T extends TLiteralValue>(title: T) => TLiteral<T>;
    Nullable: <T extends TSchema>(item: T) => _sinclair_typebox.TUnsafe<Static<T, []> | null>;
    void: () => PlutusData;
    castFrom: typeof castFrom;
    castTo: typeof castTo;
    to: typeof to;
    from: typeof from;
};
type Exact<T> = T extends TSchema ? Static<T> : T;
declare function to<T>(data: Exact<T>, type: T, recType?: string): PlutusData;
declare function to(data: Data, type?: never): PlutusData;
declare function from<T = undefined>(data: PlutusData, type?: T): T extends undefined ? Data : Exact<T>;
declare function castTo<T extends TSchema>(struct: Exact<T>, schemaType: T, recType?: string, recShape?: {
    recType: string;
    shape: T;
    shapeType: string;
}): PlutusData;
declare function castFrom<T extends TSchema>(rawData: PlutusData, schema: T): Exact<T>;

export { Constr, Data, type Exact, type IScriptData, type PConstructor, type PList, type PSchema, type Static, TxBuilder, calculateReferenceScriptFee, computeScriptData, getScriptSize };
