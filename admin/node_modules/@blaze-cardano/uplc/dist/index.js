"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  applyParams: () => applyParams,
  applyParamsToScript: () => applyParamsToScript,
  cborToScript: () => cborToScript
});
module.exports = __toCommonJS(src_exports);

// src/utils.ts
var import_core5 = require("@blaze-cardano/core");
var import_core6 = require("@blaze-cardano/core");

// src/flat.ts
var import_core = require("@blaze-cardano/core");

// src/types.ts
var Byte = (number) => {
  if (Number.isInteger(number) && number >= 0 && number <= 255) {
    return number;
  }
  throw new Error("Number must be an integer within the byte range 0-255");
};
var TermNames = {
  var: "Var",
  lam: "Lambda",
  apply: "Apply",
  const: "Constant",
  builtin: "Builtin",
  delay: "Delay",
  force: "Force",
  constr: "Constr",
  case: "Case",
  error: "Error"
};
var DataType = {
  0: "Integer",
  1: "ByteString",
  2: "String",
  3: "Unit",
  4: "Bool",
  8: "Data"
};
var termTags = {
  [TermNames["var"]]: 0,
  [TermNames["delay"]]: 1,
  [TermNames["lam"]]: 2,
  [TermNames["apply"]]: 3,
  [TermNames["const"]]: 4,
  [TermNames["force"]]: 5,
  [TermNames["error"]]: 6,
  [TermNames["builtin"]]: 7,
  [TermNames["constr"]]: 8,
  [TermNames["case"]]: 9
  /* note: gt 9 should fail, reserved for future expansion */
};
var BuiltinFunctions = [
  "addInteger",
  "subtractInteger",
  "multiplyInteger",
  "divideInteger",
  "quotientInteger",
  "remainderInteger",
  "modInteger",
  "equalsInteger",
  "lessThanInteger",
  "lessThanEqualsInteger",
  "appendByteString",
  "consByteString",
  "sliceByteString",
  "lengthOfByteString",
  "indexByteString",
  "equalsByteString",
  "lessThanByteString",
  "lessThanEqualsByteString",
  "sha2_256",
  "sha3_256",
  "blake2b_256",
  "verifyEd25519Signature",
  "appendString",
  "equalsString",
  "encodeUtf8",
  "decodeUtf8",
  "ifThenElse",
  "chooseUnit",
  "trace",
  "fstPair",
  "sndPair",
  "chooseList",
  "mkCons",
  "headList",
  "tailList",
  "nullList",
  "chooseData",
  "constrData",
  "mapData",
  "listData",
  "iData",
  "bData",
  "unConstrData",
  "unMapData",
  "unListData",
  "unIData",
  "unBData",
  "equalsData",
  "mkPairData",
  "mkNilData",
  "mkNilPairData",
  "serialiseData",
  "verifyEcdsaSecp256k1Signature",
  "verifySchnorrSecp256k1Signature"
];

// src/flat.ts
var _bytes, _index, _bitAccessor;
var Parser = class {
  // Start with the highest bit in a byte
  constructor(bytes) {
    __privateAdd(this, _bytes);
    __privateAdd(this, _index, 0);
    __privateAdd(this, _bitAccessor, 128);
    __privateSet(this, _bytes, bytes);
  }
  static fromHex(hex) {
    return new this((0, import_core.fromHex)(hex));
  }
  popBit() {
    if (__privateGet(this, _bitAccessor) < 1) {
      __privateSet(this, _bitAccessor, 128);
      __privateSet(this, _index, __privateGet(this, _index) + 1);
    }
    if (__privateGet(this, _index) < __privateGet(this, _bytes).length) {
      const ret = __privateGet(this, _bytes)[__privateGet(this, _index)] & __privateGet(this, _bitAccessor) ? 1 : 0;
      __privateSet(this, _bitAccessor, __privateGet(this, _bitAccessor) >> 1);
      return ret;
    } else {
      throw new Error("Flat Parser: popBit failed end-of-array.");
    }
  }
  popBits(n) {
    if (n > 8) {
      throw new Error("Flat Parser: popBits cannot pop more than 8");
    }
    let l = 0;
    while (n > 0) {
      l = l << 1 | this.popBit();
      n--;
    }
    return Byte(l);
  }
  popByte() {
    if (__privateGet(this, _bitAccessor) !== 128) {
      console.warn("Flat Parser: popByte unaligned, trailing bits discarded.");
      __privateSet(this, _bitAccessor, 128);
      __privateSet(this, _index, __privateGet(this, _index) + 1);
    }
    if (__privateGet(this, _index) < __privateGet(this, _bytes).length) {
      const ret = __privateGet(this, _bytes)[__privateGet(this, _index)];
      __privateSet(this, _index, __privateGet(this, _index) + 1);
      return Byte(ret);
    } else {
      throw new Error("Flat Parser: popByte failed end-of-array.");
    }
  }
  takeBytes(n) {
    if (__privateGet(this, _index) + n > __privateGet(this, _bytes).length) {
      throw new Error("Flat Parser: takeBytes failed end-of-array.");
    }
    if (__privateGet(this, _bitAccessor) != 128) {
      throw new Error(
        "Flat Parser: takeBytes failed without resetting bit accessor."
      );
    }
    const slice = __privateGet(this, _bytes).slice(__privateGet(this, _index), __privateGet(this, _index) + n);
    __privateSet(this, _index, __privateGet(this, _index) + n);
    return slice;
  }
  skipByte() {
    if (__privateGet(this, _bitAccessor) < 1) {
      __privateSet(this, _bitAccessor, 128);
      __privateSet(this, _index, __privateGet(this, _index) + 1);
    }
    __privateSet(this, _index, __privateGet(this, _index) + 1);
    __privateSet(this, _bitAccessor, 128);
  }
};
_bytes = new WeakMap();
_index = new WeakMap();
_bitAccessor = new WeakMap();
var Encoder = class {
  constructor() {
    this.buffer = [];
    this.currentByte = 0;
    this.bitIndex = 0;
  }
  pushBit(bit) {
    this.currentByte = this.currentByte << 1 | bit;
    this.bitIndex++;
    if (this.bitIndex === 8) {
      this.buffer.push(this.currentByte);
      this.currentByte = 0;
      this.bitIndex = 0;
    }
  }
  pushBits(value, numBits) {
    for (let i = numBits - 1; i >= 0; i--) {
      this.pushBit(value >> i & 1);
    }
  }
  pushByte(byte) {
    if (this.bitIndex !== 0) {
      this.buffer.push(this.currentByte);
      throw new Error(
        "pushByte called when not byte-aligned. This may lead to unexpected results."
      );
    }
    this.buffer.push(byte);
    this.currentByte = 0;
    this.bitIndex = 0;
  }
  pad() {
    if (this.bitIndex === 0) {
      this.pushByte(1);
      return;
    }
    while (this.bitIndex < 7) {
      this.pushBit(0);
    }
    this.pushBit(1);
  }
  getBytes() {
    return new Uint8Array(this.buffer);
  }
};

// src/decoder.ts
var import_core2 = require("@blaze-cardano/core");
var import_core3 = require("@blaze-cardano/core");
var _UPLCDecoder_instances, decodeVersion_fn, decodeList_fn, decodeList2_fn, decodeNatural_fn, decodeInteger_fn, decodeByteString_fn, decodeBool_fn, decodeCborData_fn, decodeData_fn, decodeType_fn, decodeConst_fn, decodeTerm_fn, decodeProgram_fn;
var _UPLCDecoder = class _UPLCDecoder extends Parser {
  constructor() {
    super(...arguments);
    __privateAdd(this, _UPLCDecoder_instances);
  }
  /**
   * Public method to decode a UPLC program from the UPLCDecoder instance
   * @returns {ParsedProgram} The decoded UPLC program.
   */
  decode() {
    return __privateMethod(this, _UPLCDecoder_instances, decodeProgram_fn).call(this);
  }
  /**
   * Creates a UPLCDecoder instance from a hexadecimal string.
   * @param {string} hex Hexadecimal string of a UPLC program's binary data.
   * @returns {UPLCDecoder} Initialized UPLCDecoder with the decoded data.
   */
  static fromHex(hex) {
    return new _UPLCDecoder((0, import_core3.fromHex)(hex));
  }
  /**
   * Decodes a UPLC program from a hexadecimal string.
   * This method utilizes the `fromHex` method to create an instance of UPLCDecoder
   * and then decodes the program using the `decode` method.
   *
   * @param {string} hex - The hexadecimal string representing the binary data of a UPLC program.
   * @returns {ParsedProgram} - The decoded UPLC program.
   */
  static decodeFromHex(hex) {
    return this.fromHex(hex).decode();
  }
};
_UPLCDecoder_instances = new WeakSet();
/**
 * Decodes a version number from the binary stream.
 * @returns {SemVer} The decoded semantic versioning number as a string.
 */
decodeVersion_fn = function() {
  const major = this.popByte();
  const minor = this.popByte();
  const patch = this.popByte();
  return `${major}.${minor}.${patch}`;
};
/**
 * Decodes a list of items from the binary stream.
 * @template Item The type of items in the list.
 * @param {() => Item} decodeItem A function to decode a single item.
 * @returns {Item[]} The decoded list of items.
 */
decodeList_fn = function(decodeItem) {
  const list = [];
  let cont = this.popBit();
  while (cont == 1) {
    list.push(decodeItem());
    cont = this.popBit();
  }
  return list;
};
/**
 * Decodes a list of items where the list is expected to have at least one item.
 * @template Item The type of items in the list.
 * @param {() => Item} decodeItem A function to decode a single item.
 * @returns {Item[]} The decoded list of items.
 */
decodeList2_fn = function(decodeItem) {
  const list = [];
  let cont = this.popBit();
  while (cont == 1) {
    list.push(decodeItem());
    cont = this.popBit();
  }
  list.push(decodeItem());
  return list;
};
/**
 * Decodes a natural number from the binary stream.
 * @returns {bigint} The decoded natural number.
 */
decodeNatural_fn = function() {
  const bytes = __privateMethod(this, _UPLCDecoder_instances, decodeList2_fn).call(this, () => this.popBits(7));
  let val = 0n;
  for (let i = 0; i < bytes.length; i += 1) {
    val += BigInt(bytes[i]) << BigInt(i) * 7n;
  }
  return val;
};
/**
 * Decodes an integer from the binary stream.
 * @returns {bigint} The decoded integer.
 */
decodeInteger_fn = function() {
  const nat = __privateMethod(this, _UPLCDecoder_instances, decodeNatural_fn).call(this);
  return nat % 2n === 0n ? nat / 2n : -((nat + 1n) / 2n);
};
/**
 * Decodes a byte string from the binary stream.
 * @returns {Uint8Array} The decoded byte array.
 */
decodeByteString_fn = function() {
  this.skipByte();
  let blockLength = this.popByte();
  if (blockLength == 0) {
    return new Uint8Array();
  }
  let arr;
  while (blockLength != 0) {
    if (arr == void 0) {
      arr = this.takeBytes(blockLength);
    } else {
      const takenSlice = this.takeBytes(blockLength);
      const newArray = new Uint8Array(arr.length + takenSlice.length);
      newArray.set(arr, 0);
      newArray.set(takenSlice, arr.length);
      arr = newArray;
    }
    blockLength = this.takeBytes(1)[0];
  }
  if (arr == void 0) {
    throw new Error(
      "UPLCDecoder #decodeByteString: failed to decode any length."
    );
  }
  return arr;
};
/**
 * Decodes a boolean value from the binary stream.
 * @returns {object} The decoded boolean value as a UPLC data structure.
 */
decodeBool_fn = function() {
  return import_core3.PlutusData.newConstrPlutusData(
    new import_core2.ConstrPlutusData(this.popBit() == 0 ? 0n : 1n, new import_core2.PlutusList())
  ).toCore();
};
/**
 * Decodes CBOR data from the binary stream.
 * @returns {PlutusData} The decoded data in Plutus core format.
 */
decodeCborData_fn = function() {
  const cbor = __privateMethod(this, _UPLCDecoder_instances, decodeByteString_fn).call(this);
  return import_core3.PlutusData.fromCbor((0, import_core3.HexBlob)((0, import_core3.toHex)(cbor))).toCore();
};
/**
 * Decodes data based on the specified data type.
 * @param {DataType} dataType The type of data to decode.
 * @returns {Data} The decoded data.
 */
decodeData_fn = function(dataType) {
  if (dataType == "Integer") {
    return __privateMethod(this, _UPLCDecoder_instances, decodeInteger_fn).call(this);
  } else if (dataType == "ByteString") {
    return __privateMethod(this, _UPLCDecoder_instances, decodeByteString_fn).call(this);
  } else if (dataType == "String") {
    console.warn("ByteString needs to be decoded to string");
    return __privateMethod(this, _UPLCDecoder_instances, decodeByteString_fn).call(this);
  } else if (dataType == "Unit") {
    return 0n;
  } else if (dataType == "Bool") {
    return __privateMethod(this, _UPLCDecoder_instances, decodeBool_fn).call(this);
  } else if (dataType == "Data") {
    return __privateMethod(this, _UPLCDecoder_instances, decodeCborData_fn).call(this);
  } else if ("list" in dataType) {
    return { items: __privateMethod(this, _UPLCDecoder_instances, decodeList_fn).call(this, () => __privateMethod(this, _UPLCDecoder_instances, decodeData_fn).call(this, dataType.list)) };
  } else if (typeof dataType == "object" && "pair" in dataType) {
    return {
      items: [
        __privateMethod(this, _UPLCDecoder_instances, decodeData_fn).call(this, dataType.pair[0]),
        __privateMethod(this, _UPLCDecoder_instances, decodeData_fn).call(this, dataType.pair[1])
      ]
    };
  } else {
    throw new Error(`Cannot decode type ${JSON.stringify(dataType)}`);
  }
};
/**
 * Decodes a type from the binary stream.
 * @param {Byte[]} type The binary representation of the type.
 * @returns {[DataType, Byte[]]} The decoded data type and the remaining bytes.
 */
decodeType_fn = function(type) {
  if (type.length == 0) {
    return ["Unit", type];
  } else {
    const head = type.at(0);
    if (head == 7) {
      const subtype = type.at(1);
      if (subtype == 5) {
        const [innerType, remainer] = __privateMethod(this, _UPLCDecoder_instances, decodeType_fn).call(this, type.slice(2));
        return [{ list: innerType }, remainer];
      } else if (subtype == 7 && type.at(2) == 6) {
        const [innerType, remainer] = __privateMethod(this, _UPLCDecoder_instances, decodeType_fn).call(this, type.slice(3));
        const [innerType2, remainer2] = __privateMethod(this, _UPLCDecoder_instances, decodeType_fn).call(this, remainer);
        return [{ pair: [innerType, innerType2] }, remainer2];
      } else {
        throw new Error("UPLCDecoder #decodeType: invalid type application");
      }
    } else {
      return [DataType[head], type.slice(1)];
    }
  }
};
/**
 * Decodes a constant from the binary stream.
 * @returns {Data} The decoded constant.
 */
decodeConst_fn = function() {
  const bits = __privateMethod(this, _UPLCDecoder_instances, decodeList_fn).call(this, () => this.popBits(4));
  const [dataType, remainder] = __privateMethod(this, _UPLCDecoder_instances, decodeType_fn).call(this, bits);
  if (remainder.length != 0) {
    throw new Error("UPLCDecoder #decodeConst: invalid type application");
  }
  const result = __privateMethod(this, _UPLCDecoder_instances, decodeData_fn).call(this, dataType);
  return [dataType, result];
};
/**
 * Decodes a term from the binary stream.
 * @param {bigint} lamDepth The current lambda depth in the term structure.
 * @returns {ParsedTerm} The decoded term.
 */
decodeTerm_fn = function(lamDepth) {
  const termTag = this.popBits(4);
  const maybeTerm = Object.entries(
    termTags
  ).find(([, tag]) => tag == termTag);
  if (!maybeTerm) {
    throw new Error(`UPLCDecoder: could not decode the term tag ${termTag}`);
  }
  const term = maybeTerm[0];
  if (term == "Var") {
    return {
      type: "Var",
      name: __privateMethod(this, _UPLCDecoder_instances, decodeNatural_fn).call(this)
    };
  }
  if (term == "Lambda") {
    return {
      type: "Lambda",
      name: lamDepth,
      body: __privateMethod(this, _UPLCDecoder_instances, decodeTerm_fn).call(this, lamDepth + 1n)
    };
  } else if (term == "Apply") {
    return {
      type: "Apply",
      function: __privateMethod(this, _UPLCDecoder_instances, decodeTerm_fn).call(this, lamDepth),
      argument: __privateMethod(this, _UPLCDecoder_instances, decodeTerm_fn).call(this, lamDepth)
    };
  } else if (term == "Constant") {
    const result = __privateMethod(this, _UPLCDecoder_instances, decodeConst_fn).call(this);
    return {
      type: "Constant",
      valueType: result[0],
      value: result[1]
    };
  } else if (term == "Builtin") {
    return {
      type: "Builtin",
      function: BuiltinFunctions[this.popBits(7)]
    };
  } else if (term == "Delay") {
    return {
      type: "Delay",
      term: __privateMethod(this, _UPLCDecoder_instances, decodeTerm_fn).call(this, lamDepth)
    };
  } else if (term == "Force") {
    return {
      type: "Force",
      term: __privateMethod(this, _UPLCDecoder_instances, decodeTerm_fn).call(this, lamDepth)
    };
  } else if (term == "Constr") {
    throw new Error(
      `UPLCDecoder: decoder is not implemented for tag ${termTag} or term (${term})`
    );
  } else if (term == "Case") {
    throw new Error(
      `UPLCDecoder: decoder is not implemented for tag ${termTag} or term (${term})`
    );
  } else if (term == "Error") {
    return {
      type: "Error"
    };
  } else {
    throw new Error(
      "UPLCDecoder: decoder no matching termType, UNREACHABLE!"
    );
  }
};
/**
 * Decodes the entire UPLC program from the binary stream.
 * @returns {ParsedProgram} The decoded program.
 */
decodeProgram_fn = function() {
  const version = __privateMethod(this, _UPLCDecoder_instances, decodeVersion_fn).call(this);
  const body = __privateMethod(this, _UPLCDecoder_instances, decodeTerm_fn).call(this, 0n);
  return {
    version,
    body
  };
};
var UPLCDecoder = _UPLCDecoder;

// src/encoder.ts
var import_core4 = require("@blaze-cardano/core");
var UPLCEncoder = class extends Encoder {
  /**
   * Encodes a semantic version number.
   * @param version - The semantic version as a string (e.g., "1.0.0").
   * @throws {Error} If the version format is invalid.
   */
  encodeVersion(version) {
    const [major, minor, patch] = version.split(".").map(Number);
    if (major === void 0 || minor === void 0 || patch === void 0) {
      throw new Error("Invalid version format");
    }
    this.pushByte(major);
    this.pushByte(minor);
    this.pushByte(patch);
  }
  /**
   * Encodes a natural number (non-negative integer).
   * @param n - The natural number to encode.
   */
  encodeNatural(n) {
    if (n == 0n) {
      this.pushBits(0, 8);
      return;
    }
    const bits = [];
    while (n > 0) {
      bits.push(Number(n & 0x7fn));
      n >>= 7n;
    }
    for (let i = 0; i < bits.length; i++) {
      this.pushBit(i !== bits.length - 1 ? 1 : 0);
      this.pushBits(bits[i], 7);
    }
  }
  /**
   * Encodes an integer (positive or negative).
   * @param i - The integer to encode.
   */
  encodeInteger(i) {
    const n = i >= 0 ? i * 2n : -i * 2n - 1n;
    this.encodeNatural(n);
  }
  /**
   * Encodes a byte string.
   * @param bytes - The byte string to encode as a Uint8Array.
   */
  encodeByteString(bytes) {
    this.pad();
    if (bytes.length === 0) {
      this.pushByte(0);
      return;
    }
    const chunks = [];
    for (let i = 0; i < bytes.length; i += 255) {
      chunks.push(bytes.slice(i, i + 255));
    }
    for (const chunk of chunks) {
      this.pushByte(chunk.length);
      for (const byte of chunk) {
        this.pushByte(byte);
      }
    }
    this.pushByte(0);
  }
  /**
   * Encodes a boolean value.
   * @param value - The boolean value to encode.
   */
  encodeBool(value) {
    this.pushBit(value ? 1 : 0);
  }
  /**
   * Encodes data based on its type.
   * @param type - The type of the data to encode.
   * @param data - The data to encode.
   * @throws {Error} If the data type is not supported.
   */
  encodeData(type, data) {
    if (type === "Integer") {
      this.encodeInteger(data);
    } else if (type === "ByteString") {
      this.encodeByteString(data);
    } else if (type === "String") {
      this.encodeByteString(data);
    } else if (type === "Unit") {
    } else if (type === "Bool") {
      if (typeof data == "object" && "constructor" in data) {
        this.encodeBool(data.constructor === 1n);
      } else {
        throw new Error(`Cannot encode data of type ${JSON.stringify(type)}`);
      }
    } else if (type === "Data") {
      this.encodeByteString((0, import_core4.fromHex)(import_core4.PlutusData.fromCore(data).toCbor()));
    } else if (typeof type === "object" && "list" in type) {
      if (typeof data == "object" && "items" in data) {
        const list = data.items;
        for (let i = 0; i < list.length; i++) {
          this.pushBit(1);
          this.encodeData(type.list, list[i]);
        }
        this.pushBit(0);
      } else {
        throw new Error(`Cannot encode data of type ${JSON.stringify(type)}`);
      }
    } else if (typeof type === "object" && "pair" in type) {
      if (typeof data == "object" && "items" in data) {
        const pair = data.items;
        this.encodeData(type.pair[0], pair[0]);
        this.encodeData(type.pair[1], pair[1]);
      } else {
        throw new Error(`Cannot encode data of type ${JSON.stringify(type)}`);
      }
    } else {
      throw new Error(`Cannot encode data of type ${JSON.stringify(type)}`);
    }
  }
  /**
   * Encodes a data type.
   * @param type - The data type to encode.
   * @returns An array of numbers representing the encoded type.
   * @throws {Error} If the type cannot be encoded.
   */
  encodeType(type) {
    if (typeof type === "string") {
      const typeCode = Object.entries(DataType).find(
        ([, v]) => v === type
      )?.[0];
      if (typeCode) {
        return [Number(typeCode)];
      } else {
        throw new Error(`Unknown data type: ${type}`);
      }
    } else if ("list" in type) {
      return [7, 5, ...this.encodeType(type.list)];
    } else if ("pair" in type) {
      return [
        7,
        7,
        6,
        ...this.encodeType(type.pair[0]),
        ...this.encodeType(type.pair[1])
      ];
    } else {
      throw new Error(`Cannot encode type ${JSON.stringify(type)}`);
    }
  }
  /**
   * Encodes a constant value with its type.
   * @param type - The type of the constant.
   * @param value - The value of the constant.
   */
  encodeConst(type, value) {
    const type_numbers = this.encodeType(type);
    for (let i = 0; i < type_numbers.length; i += 1) {
      this.pushBit(1);
      this.pushBits(type_numbers[i], 4);
    }
    this.pushBit(0);
    this.encodeData(type, value);
  }
  /**
   * Encodes a UPLC term.
   * @param term - The parsed term to encode.
   * @throws {Error} If the term type is not supported.
   */
  encodeTerm(term) {
    const termTag = termTags[term.type];
    this.pushBits(termTag, 4);
    if (term.type === TermNames.var) {
      this.encodeNatural(term.name);
    } else if (term.type === TermNames.lam) {
      this.encodeTerm(term.body);
    } else if (term.type === TermNames.apply) {
      this.encodeTerm(term.function);
      this.encodeTerm(term.argument);
    } else if (term.type === TermNames.const) {
      this.encodeConst(term.valueType, term.value);
    } else if (term.type === TermNames.builtin) {
      const builtinIndex = BuiltinFunctions.indexOf(term.function);
      this.pushBits(builtinIndex, 7);
    } else if (term.type === TermNames.delay) {
      this.encodeTerm(term.term);
    } else if (term.type === TermNames.force) {
      this.encodeTerm(term.term);
    } else if (term.type === TermNames.error) {
    } else {
      throw new Error(`Unsupported term type: ${term.type}`);
    }
  }
  /**
   * Encodes a complete UPLC program.
   * @param program - The parsed program to encode.
   * @returns A Uint8Array containing the encoded program.
   */
  encodeProgram(program) {
    this.encodeVersion(program.version);
    this.encodeTerm(program.body);
    this.pad();
    return this.getBytes();
  }
};

// src/utils.ts
var import_tx = require("@blaze-cardano/tx");
function applyParams(hex, ...params) {
  const reader = new import_core5.CborReader(hex);
  const flatString = reader.readByteString();
  const ast = new UPLCDecoder(flatString).decode();
  for (const param of params) {
    const newBody = {
      type: TermNames["apply"],
      function: ast.body,
      argument: {
        type: TermNames["const"],
        value: param.toCore(),
        valueType: "Data"
      }
    };
    ast.body = newBody;
  }
  const newFlatString = new UPLCEncoder().encodeProgram(ast);
  const writer = new import_core5.CborWriter();
  writer.writeByteString(newFlatString);
  return writer.encodeAsHex();
}
function stripCbor(cbor) {
  const cborReader = new import_core5.CborReader((0, import_core6.HexBlob)(cbor));
  while (cborReader.peekState() != import_core5.CborReaderState.ByteString) {
    cborReader.readTag();
  }
  const cborBytes = cborReader.readByteString();
  const cborWriter = new import_core5.CborWriter();
  cborWriter.writeByteString(cborBytes);
  const cborHex = cborWriter.encodeAsHex();
  return cborHex;
}
function applyParamsToScript(plutusScript, params, type) {
  const p = import_tx.Data.castTo(params, type).asList();
  const paramsList = [];
  for (let i = 0; i < p.getLength(); i++) {
    paramsList.push(p.get(i));
  }
  return applyParams((0, import_core6.HexBlob)(stripCbor(plutusScript)), ...paramsList);
}
function cborToScript(cbor, type) {
  if (type === "Native") {
    return import_core5.Script.newNativeScript(import_core5.NativeScript.fromCbor((0, import_core6.HexBlob)(cbor)));
  } else {
    const cborReader = new import_core5.CborReader((0, import_core6.HexBlob)(cbor));
    while (cborReader.peekState() != import_core5.CborReaderState.ByteString) {
      cborReader.readTag();
    }
    const cborBytes = cborReader.readByteString();
    const cborWriter = new import_core5.CborWriter();
    cborWriter.writeByteString(cborBytes);
    const cborHex = cborWriter.encodeAsHex();
    if (type === "PlutusV1") {
      return import_core5.Script.newPlutusV1Script(new import_core5.PlutusV1Script(cborHex));
    } else if (type === "PlutusV2") {
      return import_core5.Script.newPlutusV2Script(new import_core5.PlutusV2Script(cborHex));
    } else if (type == "PlutusV3") {
      return import_core5.Script.newPlutusV3Script(new import_core5.PlutusV3Script(cborHex));
    } else {
      throw new Error("Unsupported script type");
    }
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  applyParams,
  applyParamsToScript,
  cborToScript
});
