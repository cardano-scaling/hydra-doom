"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  makeUplcEvaluator: () => makeUplcEvaluator
});
module.exports = __toCommonJS(src_exports);

// src/vm.ts
var import_core = require("@blaze-cardano/core");
var U = __toESM(require("uplc-node"));
function makeUplcEvaluator(params, overEstimateSteps, overEstimateMem, slotConfig = import_core.SLOT_CONFIG_NETWORK.Mainnet) {
  return (draft_tx, allUtxos) => {
    const uplcResults = U.eval_phase_two_raw(
      (0, import_core.fromHex)(draft_tx.toCbor()),
      // Convert the draft transaction to CBOR and hex format.
      allUtxos.map((x) => (0, import_core.fromHex)(x.input().toCbor())),
      // Convert all input UTXOs to CBOR and hex format.
      allUtxos.map((x) => (0, import_core.fromHex)(x.output().toCbor())),
      // Convert all output UTXOs to CBOR and hex format.
      (0, import_core.fromHex)(import_core.Costmdls.fromCore(params.costModels).toCbor()),
      // Convert the cost models to hex format.
      BigInt(
        Math.floor(
          params.maxExecutionUnitsPerTransaction.steps / (overEstimateSteps ?? 1)
        )
      ),
      // Calculate the estimated max execution steps.
      BigInt(
        Math.floor(
          params.maxExecutionUnitsPerTransaction.memory / (overEstimateMem ?? 1)
        )
      ),
      // Calculate the estimated max memory.
      BigInt(slotConfig.zeroTime),
      // Network-specific zero time for slot calculation.
      BigInt(slotConfig.zeroSlot),
      // Network-specific zero slot.
      slotConfig.slotLength
      // Network-specific slot length.
    );
    const redeemerValues = [];
    for (const redeemerBytes of uplcResults) {
      const redeemer = import_core.Redeemer.fromCbor((0, import_core.HexBlob)((0, import_core.toHex)(redeemerBytes)));
      const exUnits = redeemer.exUnits();
      exUnits.setSteps(
        BigInt(Math.round(Number(exUnits.steps()) * overEstimateSteps))
      );
      exUnits.setMem(
        BigInt(Math.round(Number(exUnits.mem()) * overEstimateMem))
      );
      redeemer.setExUnits(exUnits);
      redeemerValues.push(redeemer);
    }
    const redeemers = import_core.Redeemers.fromCore([]);
    redeemers.setValues(redeemerValues);
    return Promise.resolve(redeemers);
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  makeUplcEvaluator
});
