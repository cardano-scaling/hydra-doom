// src/maestro.ts
import { NetworkId, RedeemerTag as RedeemerTag2 } from "@blaze-cardano/core";
import {
  TransactionUnspentOutput,
  Address,
  TransactionInput,
  PlutusData,
  TransactionId,
  TransactionOutput,
  HexBlob,
  PlutusLanguageVersion,
  fromHex,
  AddressType,
  Redeemers,
  ExUnits
} from "@blaze-cardano/core";

// src/provider.ts
import {
  RedeemerPurpose,
  RedeemerTag,
  Script,
  getBurnAddress
} from "@blaze-cardano/core";
var Provider = class {
  constructor(network) {
    this.network = network;
  }
  /**
   * Resolves the script deployment by finding a UTxO containing the script reference.
   *
   * @param {Script | Hash28ByteBase16} script - The script or its hash to resolve.
   * @param {Address} [address] - The address to search for the script deployment. Defaults to a burn address.
   * @returns {Promise<TransactionUnspentOutput | undefined>} - The UTxO containing the script reference, or undefined if not found.
   *
   * @remarks
   * This is a default implementation that works but may not be optimal.
   * Subclasses of Provider should implement their own version for better performance.
   *
   * The method searches for a UTxO at the given address (or a burn address by default)
   * that contains a script reference matching the provided script or script hash.
   *
   * @example
   * ```typescript
   * const scriptUtxo = await provider.resolveScriptRef(myScript);
   * if (scriptUtxo) {
   *   console.log("Script found in UTxO:", scriptUtxo.input().toCore());
   * } else {
   *   console.log("Script not found");
   * }
   * ```
   */
  async resolveScriptRef(script, address = getBurnAddress(this.network)) {
    const utxos = await this.getUnspentOutputs(address);
    if (script instanceof Script) {
      script = script.hash();
    }
    return utxos.find((utxo) => utxo.output().scriptRef()?.hash() === script);
  }
};
var purposeToTag = {
  [RedeemerPurpose.spend]: RedeemerTag.Spend,
  [RedeemerPurpose.mint]: RedeemerTag.Mint,
  [RedeemerPurpose.certificate]: RedeemerTag.Cert,
  [RedeemerPurpose.withdrawal]: RedeemerTag.Reward,
  [RedeemerPurpose.vote]: RedeemerTag.Voting,
  [RedeemerPurpose.propose]: RedeemerTag.Proposing
};

// src/maestro.ts
var Maestro = class extends Provider {
  constructor({
    network,
    apiKey
  }) {
    super(network == "mainnet" ? NetworkId.Mainnet : NetworkId.Testnet);
    this.url = `https://${network}.gomaestro-api.org/v1`;
    this.apiKey = apiKey;
  }
  headers() {
    return { "api-key": this.apiKey };
  }
  /**
   * This method fetches the protocol parameters from the Maestro API.
   * It constructs the query URL, sends a GET request with the appropriate headers, and processes the response.
   * The response is parsed into a ProtocolParameters object, which is then returned.
   * If the response is not in the expected format, an error is thrown.
   * @returns A Promise that resolves to a ProtocolParameters object.
   */
  getParameters() {
    const query = `/protocol-parameters`;
    return fetch(`${this.url}${query}`, { headers: this.headers() }).then((resp) => resp.json()).then((json) => {
      if (json) {
        const response = json;
        if ("message" in response) {
          throw new Error(
            `getUnspentOutputs: Maestro threw "${response.message}"`
          );
        }
        const params = response.data;
        const costModels = /* @__PURE__ */ new Map();
        for (const cm of Object.keys(
          params.plutus_cost_models
        )) {
          costModels.set(
            fromMaestroLanguageVersion(cm),
            params.plutus_cost_models[cm]
          );
        }
        const parseRatio = (ratio) => {
          const [numerator, denominator] = ratio.split("/").map(Number);
          return numerator / denominator;
        };
        return {
          coinsPerUtxoByte: params.min_utxo_deposit_coefficient,
          maxTxSize: params.max_transaction_size.bytes,
          minFeeCoefficient: params.min_fee_coefficient,
          minFeeConstant: params.min_fee_constant.ada.lovelace,
          maxBlockBodySize: params.max_block_body_size.bytes,
          maxBlockHeaderSize: params.max_block_header_size.bytes,
          stakeKeyDeposit: params.stake_credential_deposit.ada.lovelace,
          poolDeposit: params.stake_pool_deposit.ada.lovelace,
          poolRetirementEpochBound: params.stake_pool_retirement_epoch_bound,
          desiredNumberOfPools: params.desired_number_of_stake_pools,
          poolInfluence: params.stake_pool_pledge_influence,
          monetaryExpansion: params.monetary_expansion,
          treasuryExpansion: params.treasury_expansion,
          minPoolCost: params.min_stake_pool_cost.ada.lovelace,
          protocolVersion: params.version,
          maxValueSize: params.max_value_size.bytes,
          collateralPercentage: params.collateral_percentage,
          maxCollateralInputs: params.max_collateral_inputs,
          costModels,
          prices: {
            memory: parseRatio(params.script_execution_prices.memory),
            steps: parseRatio(params.script_execution_prices.cpu)
          },
          maxExecutionUnitsPerTransaction: {
            memory: params.max_execution_units_per_transaction.memory,
            steps: params.max_execution_units_per_transaction.cpu
          },
          maxExecutionUnitsPerBlock: {
            memory: params.max_execution_units_per_block.memory,
            steps: params.max_execution_units_per_block.cpu
          }
        };
      }
      throw new Error("getParameters: Could not parse response json");
    });
  }
  getUnspentOutputs(address) {
    const query = address instanceof Address ? `/addresses/${address.toBech32()}/` : `/addresses/cred/${new Address({
      type: AddressType.EnterpriseKey,
      paymentPart: address.toCore()
    }).toBech32()}/`;
    return fetch(`${this.url}${query}utxos?with_cbor=true&count=100`, {
      headers: this.headers()
    }).then((resp) => resp.json()).then((json) => {
      if (json) {
        const response = json;
        if ("message" in response) {
          throw new Error(
            `getUnspentOutputs: Maestro threw "${response.message}"`
          );
        }
        const utxos = [];
        for (const maestroUTxO of response.data) {
          const txIn = new TransactionInput(
            TransactionId(maestroUTxO.tx_hash),
            BigInt(maestroUTxO.index)
          );
          const txOut = TransactionOutput.fromCbor(
            HexBlob(maestroUTxO.txout_cbor)
          );
          utxos.push(new TransactionUnspentOutput(txIn, txOut));
        }
        return utxos;
      }
      throw new Error("getUnspentOutputs: Could not parse response json");
    });
  }
  getUnspentOutputsWithAsset(address, unit) {
    const query = address instanceof Address ? `/addresses/${address.toBech32()}/` : `/addresses/cred/${new Address({
      type: AddressType.EnterpriseKey,
      paymentPart: address
    }).toBech32()}/`;
    const asset = unit;
    console.log("asset", asset);
    return fetch(
      `${this.url}${query}utxos?with_cbor=true&count=100&asset=${asset}`,
      {
        headers: this.headers()
      }
    ).then((resp) => resp.json()).then((json) => {
      if (json) {
        const response = json;
        if ("message" in response) {
          throw new Error(
            `getUnspentOutputs: Maestro threw "${response.message}"`
          );
        }
        const utxos = [];
        for (const maestroUTxO of response.data) {
          const txIn = new TransactionInput(
            TransactionId(maestroUTxO.tx_hash),
            BigInt(maestroUTxO.index)
          );
          const txOut = TransactionOutput.fromCbor(
            HexBlob(maestroUTxO.txout_cbor)
          );
          utxos.push(new TransactionUnspentOutput(txIn, txOut));
        }
        return utxos;
      }
      throw new Error("getUnspentOutputs: Could not parse response json");
    });
  }
  getUnspentOutputByNFT(unit) {
    return fetch(`${this.url}/assets/${unit}/utxos?count=2`, {
      headers: this.headers()
    }).then((resp) => resp.json()).then((json) => {
      if (json) {
        const response = json;
        if ("message" in response) {
          throw new Error(
            `getUnspentOutputs: Maestro threw "${response.message}"`
          );
        }
        const utxo = response.data[0];
        if (response.data.length !== 1 || !utxo) {
          throw new Error(
            "getUnspentOutputByNFT: Expected 1 UTxO, got " + response.data.length
          );
        }
        return utxo;
      } else {
        throw new Error("getUnspentOutputs: Could not parse response json");
      }
    }).then((utxo) => {
      const txIn = new TransactionInput(
        TransactionId(utxo.tx_hash),
        BigInt(utxo.index)
      );
      const query = `/transactions/${utxo.tx_hash}/outputs/${utxo.index}/txo`;
      return fetch(`${this.url}${query}?with_cbor=true`, {
        headers: this.headers()
      }).then((resp) => resp.json()).then((json) => {
        if (json) {
          const response = json;
          if ("message" in response) {
            throw new Error(
              `getUnspentOutputs: Maestro threw "${response.message}"`
            );
          }
          const txOut = TransactionOutput.fromCbor(
            HexBlob(response.data.txout_cbor)
          );
          return new TransactionUnspentOutput(txIn, txOut);
        } else {
          throw new Error(
            "getUnspentOutputByNFT: Could not parse response json"
          );
        }
      });
    }).then((x) => x);
  }
  async resolveUnspentOutputs(txIns) {
    const query = `/transactions/outputs?with_cbor=true`;
    const txInStrings = txIns.map(
      (txIn) => `${txIn.transactionId()}#${txIn.index()}`
    );
    try {
      const response = await fetch(`${this.url}${query}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json",
          ...this.headers()
        },
        body: JSON.stringify(txInStrings)
      });
      if (!response.ok) {
        throw new Error(
          `resolveUnspentOutputs: Failed to resolve unspent outputs from Maestro endpoint. Status code ${response.status}`
        );
      }
      const json = await response.json();
      if ("message" in json) {
        throw new Error(
          `resolveUnspentOutputs: Maestro threw "${json.message}"`
        );
      }
      const resolvedOutputs = json.data.map(
        (output) => {
          const txIn = new TransactionInput(
            TransactionId(output.tx_hash),
            BigInt(output.index)
          );
          const txOut = TransactionOutput.fromCbor(HexBlob(output.txout_cbor));
          return new TransactionUnspentOutput(txIn, txOut);
        }
      );
      return resolvedOutputs;
    } catch (error) {
      console.error("resolveUnspentOutputs:", error);
      throw new Error("resolveUnspentOutputs: Unexpected error occurred");
    }
  }
  resolveDatum(datumHash) {
    const query = `/datums/${datumHash}`;
    return fetch(`${this.url}${query}`, {
      headers: this.headers()
    }).then((resp) => resp.json()).then((json) => {
      if (json) {
        return PlutusData.fromCbor(HexBlob(json.data.bytes));
      }
      throw new Error("resolveDatum: Could not parse response json");
    });
  }
  async awaitTransactionConfirmation(txId, timeout) {
    const startTime = Date.now();
    let finalResponse = false;
    const checkConfirmation = async () => {
      const response = await fetch(`${this.url}/transactions/${txId}/cbor`);
      if (response.ok) {
        finalResponse = true;
      } else if (Date.now() - startTime < (timeout || 0)) {
        await setTimeout(checkConfirmation, 2e4);
      }
    };
    await checkConfirmation();
    return Promise.resolve(finalResponse);
  }
  async postTransactionToChain(tx) {
    const query = `/txmanager`;
    console.log("attempting to submit ", tx.toCbor());
    return fetch(`${this.url}${query}`, {
      method: "POST",
      headers: {
        "Content-Type": "application/cbor",
        Accept: "text/plain",
        ...this.headers()
      },
      body: fromHex(tx.toCbor())
    }).then(async (resp) => {
      if (!resp.ok) {
        console.log(JSON.stringify(resp));
        const body = await resp.text();
        throw new Error(
          `postTransactionToChain: failed to submit transaction to Maestro endpoint. Status code ${body}`
        );
      }
      return resp.text();
    }).then((result) => TransactionId(result));
  }
  async evaluateTransaction(tx, additionalUtxos) {
    const query = `/transactions/evaluate`;
    const request = {
      additional_utxos: additionalUtxos.map((x) => ({
        txout_cbor: x.output().toCbor(),
        index: Number(x.input().index()),
        tx_hash: x.input().transactionId()
      })),
      cbor: tx.toCbor()
    };
    const response = await fetch(`${this.url}${query}`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
        ...this.headers()
      },
      body: JSON.stringify(request)
    });
    if (!response.ok) {
      console.log(JSON.stringify(response));
      const body = await response.text();
      throw new Error(
        `evaluateTransaction: failed to evaluate transaction with Maestro endpoint. Status code ${body}`
      );
    }
    const result = await response.json();
    const redeemers = tx.witnessSet().redeemers()?.values();
    if (!redeemers) {
      throw new Error("Cannot evaluate without redeemers!");
    }
    const lightRedeemers = result;
    for (const redeemerData of lightRedeemers) {
      const index = BigInt(redeemerData.redeemer_index);
      const purpose = purposeFromTag(redeemerData.redeemer_tag);
      const exUnits = ExUnits.fromCore({
        memory: redeemerData.ex_units.mem,
        steps: redeemerData.ex_units.steps
      });
      const redeemer = redeemers.find(
        (x) => x.tag() == purpose && x.index() == index
      );
      if (!redeemer) {
        throw new Error(
          "evaluateTransaction: Maestro endpoint had extraneous redeemer data"
        );
      }
      redeemer.setExUnits(exUnits);
    }
    return Redeemers.fromCore(redeemers.map((x) => x.toCore()));
  }
};
var fromMaestroLanguageVersion = (x) => {
  if (x == "plutus_v1") {
    return PlutusLanguageVersion.V1;
  } else if (x == "plutus_v2") {
    return PlutusLanguageVersion.V2;
  } else if (x == "plutus_v3") {
    return PlutusLanguageVersion.V3;
  }
  throw new Error("fromMaestroLanguageVersion: Unreachable!");
};
function purposeFromTag(tag) {
  const tagMap = {
    spend: RedeemerTag2.Spend,
    mint: RedeemerTag2.Mint,
    cert: RedeemerTag2.Cert,
    wdrl: RedeemerTag2.Reward
  };
  const normalizedTag = tag.toLowerCase();
  if (normalizedTag in tagMap) {
    return tagMap[normalizedTag];
  } else {
    throw new Error(`Invalid tag: ${tag}.`);
  }
}

// src/blockfrost.ts
import {
  Address as Address2,
  AddressType as AddressType2,
  AssetId,
  Datum,
  DatumHash,
  ExUnits as ExUnits2,
  fromHex as fromHex2,
  hardCodedProtocolParams,
  Hash28ByteBase16,
  HexBlob as HexBlob2,
  NetworkId as NetworkId2,
  PlutusData as PlutusData2,
  PlutusV1Script,
  PlutusV2Script,
  Redeemers as Redeemers2,
  Script as Script2,
  TransactionId as TransactionId2,
  TransactionInput as TransactionInput2,
  TransactionOutput as TransactionOutput2,
  TransactionUnspentOutput as TransactionUnspentOutput2,
  Value
} from "@blaze-cardano/core";
import { PlutusLanguageVersion as PlutusLanguageVersion2 } from "@blaze-cardano/core";
var Blockfrost = class extends Provider {
  constructor({
    network,
    projectId
  }) {
    super(network == "cardano-mainnet" ? NetworkId2.Mainnet : NetworkId2.Testnet);
    this.url = `https://${network}.blockfrost.io/api/v0/`;
    this.projectId = projectId;
  }
  headers() {
    return { project_id: this.projectId };
  }
  /**
   * This method fetches the protocol parameters from the Blockfrost API.
   * It constructs the query URL, sends a GET request with the appropriate headers, and processes the response.
   * The response is parsed into a ProtocolParameters object, which is then returned.
   * If the response is not in the expected format, an error is thrown.
   * @returns A Promise that resolves to a ProtocolParameters object.
   */
  async getParameters() {
    const query = "epochs/latest/parameters";
    const json = await fetch(`${this.url}${query}`, {
      headers: this.headers()
    }).then((resp) => resp.json());
    if (!json) {
      throw new Error("getParameters: Could not parse response json");
    }
    const response = json;
    if ("message" in response) {
      throw new Error(`getParameters: Blockfrost threw "${response.message}"`);
    }
    const costModels = /* @__PURE__ */ new Map();
    for (const [key, value] of Object.entries(response.cost_models_raw)) {
      costModels.set(
        fromBlockfrostLanguageVersion(key),
        value
      );
    }
    return {
      coinsPerUtxoByte: response.coins_per_utxo_size,
      maxTxSize: response.max_tx_size,
      minFeeCoefficient: response.min_fee_a,
      minFeeConstant: response.min_fee_b,
      maxBlockBodySize: response.max_block_size,
      maxBlockHeaderSize: response.max_block_header_size,
      stakeKeyDeposit: response.key_deposit,
      poolDeposit: response.pool_deposit,
      poolRetirementEpochBound: response.e_max,
      desiredNumberOfPools: response.n_opt,
      poolInfluence: response.a0,
      monetaryExpansion: response.rho,
      treasuryExpansion: response.tau,
      minPoolCost: response.min_pool_cost,
      protocolVersion: {
        major: response.protocol_major_ver,
        minor: response.protocol_minor_ver
      },
      maxValueSize: response.max_val_size,
      collateralPercentage: response.collateral_percent,
      maxCollateralInputs: response.max_collateral_inputs,
      costModels,
      prices: {
        memory: parseFloat(response.price_mem),
        steps: parseFloat(response.price_step)
      },
      maxExecutionUnitsPerTransaction: {
        memory: response.max_tx_ex_mem,
        steps: response.max_tx_ex_steps
      },
      maxExecutionUnitsPerBlock: {
        memory: response.max_block_ex_mem,
        steps: response.max_block_ex_steps
      },
      minFeeReferenceScripts: response.min_fee_ref_script_cost_per_byte ? {
        ...hardCodedProtocolParams.minFeeReferenceScripts,
        base: response.min_fee_ref_script_cost_per_byte
      } : void 0
    };
  }
  /**
   * This method fetches the UTxOs under a given address.
   * The response is parsed into a TransactionUnspentOutput[] type, which is
   * then returned.
   * If the response is not in the expected format, an error is thrown.
   * @param address - The Address or Payment Credential
   * @returns A Promise that resolves to TransactionUnspentOutput[].
   */
  async getUnspentOutputs(address) {
    const maxPageCount = 100;
    let page = 1;
    const bech32 = address instanceof Address2 ? address.toBech32() : new Address2({
      type: AddressType2.EnterpriseKey,
      paymentPart: address.toCore()
    }).toBech32();
    const buildTxUnspentOutput = this.buildTransactionUnspentOutput(
      Address2.fromBech32(bech32)
    );
    const results = /* @__PURE__ */ new Set();
    for (; ; ) {
      const pagination = `count=${maxPageCount}&page=${page}`;
      const query = `/addresses/${bech32}/utxos?${pagination}`;
      const json = await fetch(`${this.url}${query}`, {
        headers: this.headers()
      }).then((resp) => resp.json());
      if (!json) {
        throw new Error("getUnspentOutputs: Could not parse response json");
      }
      const response = json;
      if ("message" in response) {
        throw new Error(
          `getUnspentOutputs: Blockfrost threw "${response.message}"`
        );
      }
      for (const blockfrostUTxO of response) {
        results.add(await buildTxUnspentOutput(blockfrostUTxO));
      }
      if (response.length < maxPageCount) {
        break;
      } else {
        page = page + 1;
      }
    }
    return Array.from(results);
  }
  /**
   * This method fetches the UTxOs under a given address that hold
   * a particular asset.
   * The response is parsed into a TransactionUnspentOutput[] type, which is
   * then returned.
   * If the response is not in the expected format, an error is thrown.
   * @param address - Address or Payment Credential.
   * @param unit - The AssetId
   * @returns A Promise that resolves to TransactionUnspentOutput[].
   */
  async getUnspentOutputsWithAsset(address, unit) {
    const maxPageCount = 100;
    let page = 1;
    const bech32 = address instanceof Address2 ? address.toBech32() : new Address2({
      type: AddressType2.EnterpriseKey,
      paymentPart: address.toCore()
    }).toBech32();
    const buildTxUnspentOutput = this.buildTransactionUnspentOutput(
      Address2.fromBech32(bech32)
    );
    const asset = AssetId.getPolicyId(unit) + AssetId.getAssetName(unit);
    const results = /* @__PURE__ */ new Set();
    for (; ; ) {
      const pagination = `count=${maxPageCount}&page=${page}`;
      const query = `/addresses/${bech32}/utxos/${asset}?${pagination}`;
      const json = await fetch(`${this.url}${query}`, {
        headers: this.headers()
      }).then((resp) => resp.json());
      if (!json) {
        throw new Error(
          "getUnspentOutputsWithAsset: Could not parse response json"
        );
      }
      const response = json;
      if ("message" in response) {
        throw new Error(
          `getUnspentOutputsWithAsset: Blockfrost threw "${response.message}"`
        );
      }
      for (const blockfrostUTxO of response) {
        results.add(await buildTxUnspentOutput(blockfrostUTxO));
      }
      if (response.length < maxPageCount) {
        break;
      } else {
        page = page + 1;
      }
    }
    return Array.from(results);
  }
  /**
   * This method fetches the UTxO that holds a particular NFT given as
   * argument.
   * The response is parsed into a TransactionUnspentOutput type, which is
   * then returned.
   * If the response is not in the expected format, an error is thrown.
   * @param nft - The AssetId for the NFT
   * @returns A Promise that resolves to TransactionUnspentOutput.
   */
  async getUnspentOutputByNFT(nft) {
    const asset = AssetId.getPolicyId(nft) + AssetId.getAssetName(nft);
    const query = `/assets/${asset}/addresses`;
    const json = await fetch(`${this.url}${query}`, {
      headers: this.headers()
    }).then((resp) => resp.json());
    if (!json) {
      throw new Error("getUnspentOutputByNFT: Could not parse response json");
    }
    const response = json;
    if ("message" in response) {
      throw new Error(
        `getUnspentOutputByNFT: Blockfrost threw "${response.message}"`
      );
    }
    if (response.length === 0) {
      throw new Error(
        "getUnspentOutputByNFT: No addresses found holding the asset."
      );
    }
    if (response.length > 1) {
      throw new Error(
        "getUnspentOutputByNFT: Asset must be held by only one address. Multiple found."
      );
    }
    const utxo = response[0];
    const address = Address2.fromBech32(utxo.address);
    const utxos = await this.getUnspentOutputsWithAsset(address, nft);
    if (utxos.length !== 1) {
      throw new Error(
        "getUnspentOutputByNFT: Asset must be present in only one UTxO. Multiple found."
      );
    }
    return utxos[0];
  }
  /**
   * This method resolves transaction outputs from a list of transaction
   * inputs given as argument.
   * The response is parsed into a TransactionUnspentOutput[] type, which is
   * then returned.
   * If the response is not in the expected format, an error is thrown.
   * @param txIns - A list of TransactionInput
   * @returns A Promise that resolves to TransactionUnspentOutput[].
   */
  async resolveUnspentOutputs(txIns) {
    const results = /* @__PURE__ */ new Set();
    for (const txIn of txIns) {
      const query = `/txs/${txIn.transactionId()}/utxos`;
      const json = await fetch(`${this.url}${query}`, {
        headers: this.headers()
      }).then((resp) => resp.json());
      if (!json) {
        throw new Error("resolveUnspentOutputs: Could not parse response json");
      }
      const response = json;
      if ("message" in response) {
        throw new Error(
          `resolveUnspentOutputs: Blockfrost threw "${response.message}"`
        );
      }
      const txIndex = BigInt(txIn.index());
      for (const blockfrostUTxO of response.outputs) {
        if (BigInt(blockfrostUTxO.output_index) !== txIndex) {
          continue;
        }
        blockfrostUTxO.tx_hash = txIn.transactionId();
        const buildTxUnspentOutput = this.buildTransactionUnspentOutput(
          Address2.fromBech32(blockfrostUTxO.address)
        );
        results.add(await buildTxUnspentOutput(blockfrostUTxO));
      }
    }
    return Array.from(results);
  }
  /**
   * This method returns the datum for the datum hash given as argument.
   * The response is parsed into a PlutusData type, which is then returned.
   * If the response is not in the expected format, an error is thrown.
   * @param datumHash - The hash of a datum
   * @returns A Promise that resolves to PlutusData
   */
  async resolveDatum(datumHash) {
    const query = `/scripts/datum/${datumHash}/cbor`;
    const json = await fetch(`${this.url}${query}`, {
      headers: this.headers()
    }).then((resp) => resp.json());
    if (!json) {
      throw new Error("resolveDatum: Could not parse response json");
    }
    const response = json;
    if ("message" in response) {
      throw new Error(`resolveDatum: Blockfrost threw "${response.message}"`);
    }
    return PlutusData2.fromCbor(HexBlob2(response.cbor));
  }
  /**
   * This method awaits confirmation of the transaction given as argument.
   * The response is parsed into a boolean, which is then returned.
   * If tx is not confirmed at first and no value for timeout is provided,
   * then false is returned.
   * If tx is not confirmed at first and a value for timeout (in ms) is given,
   * then subsequent checks will be performed at a 20 second interval until
   * timeout is reached.
   * @param txId - The hash of a transaction
   * @param timeout - An optional timeout for waiting for confirmation. This
   * value should be greater than average block time of 20000 ms
   * @returns A Promise that resolves to a boolean
   */
  async awaitTransactionConfirmation(txId, timeout) {
    const averageBlockTime = 2e4;
    if (timeout && timeout < averageBlockTime) {
      console.log("Warning: timeout given is less than average block time.");
    }
    const query = `/txs/${txId}/metadata/cbor`;
    const startTime = Date.now();
    const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
    const checkConfirmation = async () => {
      const response = await fetch(`${this.url}${query}`, {
        headers: this.headers()
      });
      return response.ok;
    };
    if (await checkConfirmation()) {
      return true;
    }
    if (timeout) {
      while (Date.now() - startTime < timeout) {
        await delay(averageBlockTime);
        if (await checkConfirmation()) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * This method submits a transaction to the chain.
   * @param tx - The Transaction
   * @returns A Promise that resolves to a TransactionId type
   */
  async postTransactionToChain(tx) {
    const query = "/tx/submit";
    const response = await fetch(`${this.url}${query}`, {
      method: "POST",
      headers: {
        "Content-Type": "application/cbor",
        ...this.headers()
      },
      body: fromHex2(tx.toCbor())
    });
    if (!response.ok) {
      const error = await response.text();
      throw new Error(
        `postTransactionToChain: failed to submit transaction to Blockfrost endpoint.
Error ${error}`
      );
    }
    const txId = await response.json();
    return TransactionId2(txId);
  }
  /**
   * This method evaluates how much execution units a transaction requires.
   * Optionally, additional outputs can be provided. These are added to the
   * evaluation without checking for their presence on-chain. This is useful
   * when performing transaction chaining, where some outputs used as inputs
   * to a transaction will have not yet been submitted to the network.
   * @param tx - The Transaction
   * @param additionalUtxos - Optional utxos to be added to the evaluation.
   * @returns A Promise that resolves to a Redeemers type
   */
  async evaluateTransaction(tx, additionalUtxos) {
    const currentRedeemers = tx.witnessSet().redeemers()?.values();
    if (!currentRedeemers || currentRedeemers.length === 0) {
      throw new Error(
        `evaluateTransaction: No Redeemers found in transaction"`
      );
    }
    const additionalUtxoSet = /* @__PURE__ */ new Set();
    for (const utxo of additionalUtxos || []) {
      const txIn = {
        txId: utxo.input().transactionId(),
        index: utxo.input().index()
      };
      const output = utxo.output();
      const value = output.amount();
      const txOut = {
        address: output.address(),
        value: {
          coins: value.coin(),
          assets: value.multiasset()
        },
        datum_hash: output.datum()?.asDataHash(),
        datum: output.datum()?.asInlineData()?.toCbor(),
        script: output.scriptRef()?.toCbor()
      };
      additionalUtxoSet.add([txIn, txOut]);
    }
    const payload = {
      cbor: tx.toCbor(),
      additionalUtxoset: Array.from(additionalUtxoSet)
    };
    const query = "/utils/txs/evaluate/utxos";
    const response = await fetch(`${this.url}${query}`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
        ...this.headers()
      },
      body: JSON.stringify(
        payload,
        (_, value) => typeof value === "bigint" ? value.toString() : value
      )
    });
    if (!response.ok) {
      const error = await response.text();
      throw new Error(
        `evaluateTransaction: failed to evaluate transaction with additional UTxO set in Blockfrost endpoint.
Error ${error}`
      );
    }
    const json = await response.json();
    if ("message" in json) {
      throw new Error(
        `evaluateTransaction: Blockfrost threw "${json.message}"`
      );
    }
    const evaledRedeemers = /* @__PURE__ */ new Set();
    if (!("EvaluationResult" in json.result)) {
      throw new Error(
        `evaluateTransaction: Blockfrost endpoint returned evaluation failure.`
      );
    }
    const result = json.result.EvaluationResult;
    for (const redeemerPointer in result) {
      const [pTag, pIndex] = redeemerPointer.split(":");
      const purpose = purposeToTag[pTag];
      const index = BigInt(pIndex);
      const data = result[redeemerPointer];
      const exUnits = ExUnits2.fromCore({
        memory: data.memory,
        steps: data.steps
      });
      const redeemer = currentRedeemers.find(
        (x) => x.tag() == purpose && x.index() == index
      );
      if (!redeemer) {
        throw new Error(
          "evaluateTransaction: Blockfrost endpoint had extraneous redeemer data"
        );
      }
      redeemer.setExUnits(exUnits);
      evaledRedeemers.add(redeemer);
    }
    return Redeemers2.fromCore(
      Array.from(evaledRedeemers).map((x) => x.toCore())
    );
  }
  async getScriptRef(scriptHash) {
    const typeQuery = `/scripts/${scriptHash}`;
    const typeJson = await fetch(`${this.url}${typeQuery}`, {
      headers: this.headers()
    }).then((resp) => resp.json());
    if (!typeJson) {
      throw new Error("getScriptRef: Could not parse response json");
    }
    const typeResponse = typeJson;
    if ("message" in typeResponse) {
      throw new Error(
        `getScriptRef: Blockfrost threw "${typeResponse.message}"`
      );
    }
    const type = typeResponse.type;
    if (type == "timelock") {
      throw new Error("getScriptRef: Native scripts are not yet supported.");
    }
    const cborQuery = `/scripts/${scriptHash}/cbor`;
    const cborJson = await fetch(`${this.url}${cborQuery}`, {
      headers: this.headers()
    }).then((resp) => resp.json());
    if (!cborJson) {
      throw new Error("getScriptRef: Could not parse response json");
    }
    const cborResponse = cborJson;
    if ("message" in cborResponse) {
      throw new Error(
        `getScriptRef: Blockfrost threw "${cborResponse.message}"`
      );
    }
    const cbor = HexBlob2(cborResponse.cbor);
    switch (type) {
      case "plutusV1":
        return Script2.newPlutusV1Script(new PlutusV1Script(cbor));
      case "plutusV2":
        return Script2.newPlutusV2Script(new PlutusV2Script(cbor));
    }
  }
  // Partially applies address in order to avoid sending it
  // as argument repeatedly when building TransactionUnspentOutput
  buildTransactionUnspentOutput(address) {
    return async (blockfrostUTxO) => {
      const txIn = new TransactionInput2(
        TransactionId2(blockfrostUTxO.tx_hash),
        BigInt(blockfrostUTxO.output_index)
      );
      const tokenMap = /* @__PURE__ */ new Map();
      let lovelace = 0n;
      for (const { unit, quantity } of blockfrostUTxO.amount) {
        if (unit === "lovelace") {
          lovelace = BigInt(quantity);
        } else {
          tokenMap.set(unit, BigInt(quantity));
        }
      }
      const txOut = new TransactionOutput2(
        address,
        new Value(lovelace, tokenMap)
      );
      const datum = blockfrostUTxO.inline_datum ? Datum.newInlineData(
        PlutusData2.fromCbor(HexBlob2(blockfrostUTxO.inline_datum))
      ) : blockfrostUTxO.data_hash ? Datum.newDataHash(DatumHash(blockfrostUTxO.data_hash)) : void 0;
      if (datum) txOut.setDatum(datum);
      if (blockfrostUTxO.reference_script_hash)
        txOut.setScriptRef(
          await this.getScriptRef(
            Hash28ByteBase16(blockfrostUTxO.reference_script_hash)
          )
        );
      return new TransactionUnspentOutput2(txIn, txOut);
    };
  }
};
var fromBlockfrostLanguageVersion = (x) => {
  if (x == "PlutusV1") {
    return PlutusLanguageVersion2.V1;
  } else if (x == "PlutusV2") {
    return PlutusLanguageVersion2.V2;
  } else if (x == "PlutusV3") {
    return PlutusLanguageVersion2.V3;
  }
  throw new Error("fromBlockfrostLanguageVersion: Unreachable!");
};

// src/kupmios.ts
import {
  TransactionUnspentOutput as TransactionUnspentOutput3,
  Address as Address3,
  AssetId as AssetId2,
  TransactionInput as TransactionInput3,
  TransactionId as TransactionId3,
  TransactionOutput as TransactionOutput3,
  Value as Value2,
  Redeemers as Redeemers3,
  PlutusData as PlutusData3,
  Datum as Datum2,
  ExUnits as ExUnits3,
  Script as Script3,
  NativeScript,
  PlutusV1Script as PlutusV1Script2,
  PlutusV2Script as PlutusV2Script2,
  PlutusV3Script,
  NetworkId as NetworkId3
} from "@blaze-cardano/core";
var _Kupmios = class _Kupmios extends Provider {
  /**
   * Constructor to initialize Kupmios instance.
   * @param kupoUrl - URL of the Kupo service.
   * @param ogmiosUrl - URL of the Ogmios service.
   */
  constructor(kupoUrl, ogmios) {
    super(
      ogmios.url.includes("mainnet-v6") ? NetworkId3.Mainnet : NetworkId3.Testnet
    );
    this.kupoUrl = kupoUrl;
    this.ogmios = ogmios;
  }
  /**
   * Parses a fractional string into a number.
   * @param fraction - Fractional string in the format "numerator/denominator".
   * @returns The parsed fraction as a number.
   */
  parseFraction(fraction) {
    const [numerator, denominator] = fraction.split("/").map(Number);
    return numerator / denominator;
  }
  /**
   * Fetches unspent outputs using Kupo API.
   * @param prefix - Prefix for the URL.
   * @param postfix - Postfix for the URL.
   * @returns A promise that resolves to an array of fully resolved unspent outputs.
   */
  async _getUnspentOutputs(prefix, postfix) {
    const url = `${this.kupoUrl}/matches/${prefix ? prefix : "*"}?unspent${postfix ? postfix : ""}`;
    const result = await fetch(url).then((res) => res.json());
    return await Promise.all(
      result.map(async (utxo) => {
        const transactionId = utxo.transaction_id;
        const outputIndex = BigInt(utxo.output_index);
        const address = Address3.fromBech32(utxo.address);
        const coins = BigInt(utxo.value.coins);
        const assets = utxo.value.assets;
        const tokenMap = Object.keys(assets).reduce((map, unit) => {
          map.set(AssetId2(unit), BigInt(assets[unit]));
          return map;
        }, /* @__PURE__ */ new Map());
        const value = new Value2(coins, tokenMap);
        const output = new TransactionOutput3(address, value);
        if (utxo.datum_hash) {
          const datum = utxo.datum_type === "hash" ? new Datum2(utxo.datum_hash, void 0) : new Datum2(void 0, await this.resolveDatum(utxo.datum_hash));
          output.setDatum(datum);
        }
        if (utxo.script_hash) {
          const scriptRef = await this.resolveScript(utxo.script_hash);
          output.setScriptRef(scriptRef);
        }
        return new TransactionUnspentOutput3(
          new TransactionInput3(TransactionId3(transactionId), outputIndex),
          output
        );
      })
    );
  }
  /**
   * Gets unspent outputs for a given address.
   * @param address - Address to fetch unspent outputs for.
   * @returns A promise that resolves to an array of unspent outputs.
   */
  async getUnspentOutputs(address) {
    const prefix = address.toBech32();
    return this._getUnspentOutputs(prefix, null);
  }
  /**
   * Gets unspent outputs containing a specific asset.
   * @param address - Address to fetch unspent outputs for.
   * @param unit - Asset ID to filter by.
   * @returns A promise that resolves to an array of unspent outputs.
   */
  async getUnspentOutputsWithAsset(address, unit) {
    const policyId = unit.slice(0, 56);
    const assetName = unit.slice(56);
    const prefix = address ? address.toBech32() : `${policyId}.${assetName}`;
    const postfix = address ? `&policy_id=${policyId}&asset_name=${assetName}` : "";
    return this._getUnspentOutputs(prefix, postfix);
  }
  /**
   * Gets an unspent output containing a specific NFT.
   * @param unit - Asset ID of the NFT.
   * @returns A promise that resolves to the unspent output.
   */
  async getUnspentOutputByNFT(unit) {
    const res = await this.getUnspentOutputsWithAsset(null, unit);
    if (res.length === 1) {
      return res[0];
    } else {
      throw new Error(`Error fetching unspent outputs ${unit}`);
    }
  }
  /**
   * Resolves unspent outputs for given transaction inputs.
   * @param txIns - Array of transaction inputs.
   * @returns A promise that resolves to an array of unspent outputs.
   */
  async resolveUnspentOutputs(txIns) {
    const results = /* @__PURE__ */ new Set();
    await Promise.all(
      txIns.map(async (txIn) => {
        const prefix = `${txIn.index()}@${txIn.transactionId()}`;
        const outputs = await this._getUnspentOutputs(prefix, null);
        if (outputs.length === 1) {
          results.add(outputs[0]);
        }
      })
    );
    const resultArray = Array.from(results);
    if (txIns.length !== resultArray.length) {
      throw new Error("Inconsistent transaction inputs");
    }
    return resultArray;
  }
  /**
   * Gets the protocol parameters from the blockchain.
   * @returns A promise that resolves to the protocol parameters.
   */
  async getParameters() {
    return this.ogmios.queryLedgerStateProtocolParameters().then((result) => {
      const createCostModels = (versions, result2) => {
        const costModels2 = /* @__PURE__ */ new Map();
        versions.forEach((version, index) => {
          costModels2.set(
            index,
            result2.plutusCostModels?.[version] ? result2.plutusCostModels[version].map((val) => val) : []
          );
        });
        return costModels2;
      };
      const costModels = createCostModels(_Kupmios.plutusVersions, result);
      return {
        coinsPerUtxoByte: result.minUtxoDepositCoefficient,
        maxTxSize: result.maxTransactionSize?.bytes || 0,
        minFeeCoefficient: result.minFeeCoefficient,
        minFeeConstant: Number(result.minFeeConstant.ada.lovelace),
        maxBlockBodySize: result.maxBlockBodySize.bytes,
        maxBlockHeaderSize: result.maxBlockHeaderSize.bytes,
        stakeKeyDeposit: Number(result.stakeCredentialDeposit.ada.lovelace),
        poolDeposit: result.stakePoolDeposit ? Number(result.stakePoolDeposit.ada.lovelace) : null,
        poolRetirementEpochBound: result.stakePoolRetirementEpochBound,
        desiredNumberOfPools: result.desiredNumberOfStakePools,
        poolInfluence: result.stakePoolPledgeInfluence.toString(),
        monetaryExpansion: result.monetaryExpansion.toString(),
        treasuryExpansion: result.treasuryExpansion.toString(),
        minPoolCost: Number(result.minStakePoolCost.ada.lovelace),
        protocolVersion: {
          major: result.version.major,
          minor: result.version.minor
        },
        maxValueSize: result.maxValueSize?.bytes || 0,
        collateralPercentage: result.collateralPercentage || 0,
        maxCollateralInputs: result.maxCollateralInputs || 0,
        costModels: costModels || {},
        prices: {
          steps: this.parseFraction(result.scriptExecutionPrices.cpu),
          memory: this.parseFraction(result.scriptExecutionPrices.memory)
        },
        maxExecutionUnitsPerTransaction: {
          steps: result.maxExecutionUnitsPerTransaction.cpu,
          memory: result.maxExecutionUnitsPerTransaction.memory
        },
        maxExecutionUnitsPerBlock: {
          steps: result.maxExecutionUnitsPerBlock.cpu,
          memory: result.maxExecutionUnitsPerBlock.memory
        },
        minFeeReferenceScripts: result.minFeeReferenceScripts
      };
    });
  }
  /**
   * Resolves the datum for a given datum hash.
   * @param datumHash - Hash of the datum to resolve.
   * @returns A promise that resolves to the Plutus data.
   */
  async resolveDatum(datumHash) {
    const url = `${this.kupoUrl}/datums/${datumHash}`;
    const result = await fetch(url).then((res) => res.json());
    if (!result || !result.datum) {
      throw new Error(`No datum found for datum hash: ${datumHash}`);
    }
    return PlutusData3.fromCbor(result.datum);
  }
  /**
   * Awaits confirmation of a transaction.
   * @param txId - ID of the transaction to await confirmation for.
   * @param timeout - Optional timeout in milliseconds.
   * @returns A promise that resolves to a boolean indicating confirmation status.
   */
  async awaitTransactionConfirmation(txId, timeout = 5 * _Kupmios.confirmationTimeout) {
    const startTime = Date.now();
    const checkConfirmation = async () => {
      const response = await fetch(`${this.kupoUrl}/matches/0@${txId}`);
      if (response.ok && (await response.json().then((res) => res.length), (_res) => false)) {
        return true;
      } else if (Date.now() - startTime < timeout) {
        await new Promise(
          (resolve) => setTimeout(resolve, _Kupmios.confirmationTimeout)
        );
        return checkConfirmation();
      }
      return false;
    };
    return await checkConfirmation();
  }
  /**
   * Posts a transaction to the blockchain.
   * @param tx - Transaction to post.
   * @returns A promise that resolves to the transaction ID.
   */
  async postTransactionToChain(tx) {
    return this.ogmios.submitTransaction({ cbor: tx.toCbor() }).then((result) => {
      return TransactionId3(result.transaction.id);
    });
  }
  /**
   * Resolves the scripts for a given script hash.
   * @param scriptHash - Hash of the script to resolve.
   * @returns A promise that resolves to the JSON represenation of the scrip.
   * Note: we should reconsider creating a class for this as it could be expensive operation
   */
  async resolveScript(scriptHash) {
    const url = `${this.kupoUrl}/scripts/${scriptHash}`;
    const result = await fetch(url).then((res) => res.json());
    if (!result || !result.language || !result.script) {
      throw new Error(`No script found for script hash: ${scriptHash}`);
    }
    switch (result.language) {
      case "native":
        return Script3.newNativeScript(NativeScript.fromCbor(result.script));
      case "plutus:v1":
        return Script3.newPlutusV1Script(new PlutusV1Script2(result.script));
      case "plutus:v2":
        return Script3.newPlutusV2Script(new PlutusV2Script2(result.script));
      case "plutus:v3":
        return Script3.newPlutusV3Script(new PlutusV3Script(result.script));
      default:
        throw new Error(`Unsupported script language: ${result.language}`);
    }
  }
  /**
   * Evaluates a transaction.
   * @param tx - Transaction to evaluate.
   * @param additionalUtxos - Additional UTXOs to consider.
   * @returns A promise that resolves to the redeemers.
   */
  async evaluateTransaction(tx, additionalUtxos) {
    try {
      const redeemers = tx.witnessSet().redeemers()?.values();
      if (!redeemers) {
        throw new Error("Cannot evaluate without redeemers!");
      }
      const additionalInputs = additionalUtxos.map((utxo) => utxo.input());
      const utxosToDrop = await this.resolveUnspentOutputs(additionalInputs);
      const additional_utxos = _Kupmios.serializeUtxos(
        additionalUtxos.filter((utxo) => {
          return !utxosToDrop.includes(utxo);
        })
      );
      return this.ogmios.evaluateTransaction({ cbor: tx.toCbor() }, additional_utxos).then((results) => {
        if (results.length !== redeemers.length) {
          throw new Error(
            "Kupmios endpoint returned inconsistent length of the redeemers"
          );
        }
        const updatedRedeemers = results.map((redeemerData) => {
          const exUnits = ExUnits3.fromCore({
            memory: redeemerData.budget.memory,
            steps: redeemerData.budget.cpu
          });
          const redeemer = redeemers.find(
            (x) => Number(x.index()) === redeemerData.validator.index && // TODO: RedeemerPurpose enum's indexes are still inconsistent. They are not the same as RedeemerTag values.
            x.tag() === purposeToTag[redeemerData.validator.purpose]
          );
          if (!redeemer) {
            throw new Error(
              "Kupmios endpoint returned extraneous redeemer data"
            );
          }
          redeemer.setExUnits(exUnits);
          return redeemer.toCore();
        });
        return Redeemers3.fromCore(updatedRedeemers);
      });
    } catch (error) {
      console.error("Error evaluating transaction:", error);
      throw error;
    }
  }
  /**
   * Serialize unspent outputs to JSON format.
   * @param unspentOutputs - Unspent outputs to serialize.
   * @returns the serialized unspent outputs.
   */
  static serializeUtxos(unspentOutputs) {
    return unspentOutputs.map((output) => {
      const out = output.output();
      const address = out.address().toBech32();
      const ada = out.amount().coin().valueOf();
      const value = { ada: { lovelace: ada } };
      const multiAsset = out.amount().multiasset?.();
      multiAsset?.forEach((assets, assetId) => {
        const policyID = AssetId2.getPolicyId(assetId);
        const assetName = AssetId2.getAssetName(assetId);
        value[policyID] ?? (value[policyID] = {});
        value[policyID][assetName] = assets;
      });
      const datumHash = out.datum()?.asDataHash()?.toString();
      const datum = out.datum()?.asInlineData()?.toCbor();
      const scriptRef = out.scriptRef();
      let script;
      if (scriptRef) {
        const langIndex = scriptRef.language();
        const language = _Kupmios.plutusVersions[langIndex - 1];
        script = {
          language: language || "native",
          cbor: langIndex === 0 ? scriptRef.toCbor() : scriptRef[`asPlutusV${langIndex}`]().rawBytes()
        };
      }
      return {
        transaction: {
          id: output.input().transactionId().toString()
        },
        index: Number(output.input().index()),
        address,
        value,
        datumHash,
        datum,
        script
      };
    });
  }
};
_Kupmios.plutusVersions = [
  "plutus:v1",
  "plutus:v2",
  "plutus:v3"
];
_Kupmios.confirmationTimeout = 2e4;
var Kupmios = _Kupmios;
export {
  Blockfrost,
  Kupmios,
  Maestro,
  Provider,
  fromBlockfrostLanguageVersion,
  purposeToTag
};
