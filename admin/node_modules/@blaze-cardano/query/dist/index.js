"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Blockfrost: () => Blockfrost,
  Kupmios: () => Kupmios,
  Maestro: () => Maestro,
  Provider: () => Provider,
  fromBlockfrostLanguageVersion: () => fromBlockfrostLanguageVersion,
  purposeToTag: () => purposeToTag
});
module.exports = __toCommonJS(src_exports);

// src/maestro.ts
var import_core2 = require("@blaze-cardano/core");
var import_core3 = require("@blaze-cardano/core");

// src/provider.ts
var import_core = require("@blaze-cardano/core");
var Provider = class {
  constructor(network) {
    this.network = network;
  }
  /**
   * Resolves the script deployment by finding a UTxO containing the script reference.
   *
   * @param {Script | Hash28ByteBase16} script - The script or its hash to resolve.
   * @param {Address} [address] - The address to search for the script deployment. Defaults to a burn address.
   * @returns {Promise<TransactionUnspentOutput | undefined>} - The UTxO containing the script reference, or undefined if not found.
   *
   * @remarks
   * This is a default implementation that works but may not be optimal.
   * Subclasses of Provider should implement their own version for better performance.
   *
   * The method searches for a UTxO at the given address (or a burn address by default)
   * that contains a script reference matching the provided script or script hash.
   *
   * @example
   * ```typescript
   * const scriptUtxo = await provider.resolveScriptRef(myScript);
   * if (scriptUtxo) {
   *   console.log("Script found in UTxO:", scriptUtxo.input().toCore());
   * } else {
   *   console.log("Script not found");
   * }
   * ```
   */
  async resolveScriptRef(script, address = (0, import_core.getBurnAddress)(this.network)) {
    const utxos = await this.getUnspentOutputs(address);
    if (script instanceof import_core.Script) {
      script = script.hash();
    }
    return utxos.find((utxo) => utxo.output().scriptRef()?.hash() === script);
  }
};
var purposeToTag = {
  [import_core.RedeemerPurpose.spend]: import_core.RedeemerTag.Spend,
  [import_core.RedeemerPurpose.mint]: import_core.RedeemerTag.Mint,
  [import_core.RedeemerPurpose.certificate]: import_core.RedeemerTag.Cert,
  [import_core.RedeemerPurpose.withdrawal]: import_core.RedeemerTag.Reward,
  [import_core.RedeemerPurpose.vote]: import_core.RedeemerTag.Voting,
  [import_core.RedeemerPurpose.propose]: import_core.RedeemerTag.Proposing
};

// src/maestro.ts
var Maestro = class extends Provider {
  constructor({
    network,
    apiKey
  }) {
    super(network == "mainnet" ? import_core2.NetworkId.Mainnet : import_core2.NetworkId.Testnet);
    this.url = `https://${network}.gomaestro-api.org/v1`;
    this.apiKey = apiKey;
  }
  headers() {
    return { "api-key": this.apiKey };
  }
  /**
   * This method fetches the protocol parameters from the Maestro API.
   * It constructs the query URL, sends a GET request with the appropriate headers, and processes the response.
   * The response is parsed into a ProtocolParameters object, which is then returned.
   * If the response is not in the expected format, an error is thrown.
   * @returns A Promise that resolves to a ProtocolParameters object.
   */
  getParameters() {
    const query = `/protocol-parameters`;
    return fetch(`${this.url}${query}`, { headers: this.headers() }).then((resp) => resp.json()).then((json) => {
      if (json) {
        const response = json;
        if ("message" in response) {
          throw new Error(
            `getUnspentOutputs: Maestro threw "${response.message}"`
          );
        }
        const params = response.data;
        const costModels = /* @__PURE__ */ new Map();
        for (const cm of Object.keys(
          params.plutus_cost_models
        )) {
          costModels.set(
            fromMaestroLanguageVersion(cm),
            params.plutus_cost_models[cm]
          );
        }
        const parseRatio = (ratio) => {
          const [numerator, denominator] = ratio.split("/").map(Number);
          return numerator / denominator;
        };
        return {
          coinsPerUtxoByte: params.min_utxo_deposit_coefficient,
          maxTxSize: params.max_transaction_size.bytes,
          minFeeCoefficient: params.min_fee_coefficient,
          minFeeConstant: params.min_fee_constant.ada.lovelace,
          maxBlockBodySize: params.max_block_body_size.bytes,
          maxBlockHeaderSize: params.max_block_header_size.bytes,
          stakeKeyDeposit: params.stake_credential_deposit.ada.lovelace,
          poolDeposit: params.stake_pool_deposit.ada.lovelace,
          poolRetirementEpochBound: params.stake_pool_retirement_epoch_bound,
          desiredNumberOfPools: params.desired_number_of_stake_pools,
          poolInfluence: params.stake_pool_pledge_influence,
          monetaryExpansion: params.monetary_expansion,
          treasuryExpansion: params.treasury_expansion,
          minPoolCost: params.min_stake_pool_cost.ada.lovelace,
          protocolVersion: params.version,
          maxValueSize: params.max_value_size.bytes,
          collateralPercentage: params.collateral_percentage,
          maxCollateralInputs: params.max_collateral_inputs,
          costModels,
          prices: {
            memory: parseRatio(params.script_execution_prices.memory),
            steps: parseRatio(params.script_execution_prices.cpu)
          },
          maxExecutionUnitsPerTransaction: {
            memory: params.max_execution_units_per_transaction.memory,
            steps: params.max_execution_units_per_transaction.cpu
          },
          maxExecutionUnitsPerBlock: {
            memory: params.max_execution_units_per_block.memory,
            steps: params.max_execution_units_per_block.cpu
          }
        };
      }
      throw new Error("getParameters: Could not parse response json");
    });
  }
  getUnspentOutputs(address) {
    const query = address instanceof import_core3.Address ? `/addresses/${address.toBech32()}/` : `/addresses/cred/${new import_core3.Address({
      type: import_core3.AddressType.EnterpriseKey,
      paymentPart: address.toCore()
    }).toBech32()}/`;
    return fetch(`${this.url}${query}utxos?with_cbor=true&count=100`, {
      headers: this.headers()
    }).then((resp) => resp.json()).then((json) => {
      if (json) {
        const response = json;
        if ("message" in response) {
          throw new Error(
            `getUnspentOutputs: Maestro threw "${response.message}"`
          );
        }
        const utxos = [];
        for (const maestroUTxO of response.data) {
          const txIn = new import_core3.TransactionInput(
            (0, import_core3.TransactionId)(maestroUTxO.tx_hash),
            BigInt(maestroUTxO.index)
          );
          const txOut = import_core3.TransactionOutput.fromCbor(
            (0, import_core3.HexBlob)(maestroUTxO.txout_cbor)
          );
          utxos.push(new import_core3.TransactionUnspentOutput(txIn, txOut));
        }
        return utxos;
      }
      throw new Error("getUnspentOutputs: Could not parse response json");
    });
  }
  getUnspentOutputsWithAsset(address, unit) {
    const query = address instanceof import_core3.Address ? `/addresses/${address.toBech32()}/` : `/addresses/cred/${new import_core3.Address({
      type: import_core3.AddressType.EnterpriseKey,
      paymentPart: address
    }).toBech32()}/`;
    const asset = unit;
    console.log("asset", asset);
    return fetch(
      `${this.url}${query}utxos?with_cbor=true&count=100&asset=${asset}`,
      {
        headers: this.headers()
      }
    ).then((resp) => resp.json()).then((json) => {
      if (json) {
        const response = json;
        if ("message" in response) {
          throw new Error(
            `getUnspentOutputs: Maestro threw "${response.message}"`
          );
        }
        const utxos = [];
        for (const maestroUTxO of response.data) {
          const txIn = new import_core3.TransactionInput(
            (0, import_core3.TransactionId)(maestroUTxO.tx_hash),
            BigInt(maestroUTxO.index)
          );
          const txOut = import_core3.TransactionOutput.fromCbor(
            (0, import_core3.HexBlob)(maestroUTxO.txout_cbor)
          );
          utxos.push(new import_core3.TransactionUnspentOutput(txIn, txOut));
        }
        return utxos;
      }
      throw new Error("getUnspentOutputs: Could not parse response json");
    });
  }
  getUnspentOutputByNFT(unit) {
    return fetch(`${this.url}/assets/${unit}/utxos?count=2`, {
      headers: this.headers()
    }).then((resp) => resp.json()).then((json) => {
      if (json) {
        const response = json;
        if ("message" in response) {
          throw new Error(
            `getUnspentOutputs: Maestro threw "${response.message}"`
          );
        }
        const utxo = response.data[0];
        if (response.data.length !== 1 || !utxo) {
          throw new Error(
            "getUnspentOutputByNFT: Expected 1 UTxO, got " + response.data.length
          );
        }
        return utxo;
      } else {
        throw new Error("getUnspentOutputs: Could not parse response json");
      }
    }).then((utxo) => {
      const txIn = new import_core3.TransactionInput(
        (0, import_core3.TransactionId)(utxo.tx_hash),
        BigInt(utxo.index)
      );
      const query = `/transactions/${utxo.tx_hash}/outputs/${utxo.index}/txo`;
      return fetch(`${this.url}${query}?with_cbor=true`, {
        headers: this.headers()
      }).then((resp) => resp.json()).then((json) => {
        if (json) {
          const response = json;
          if ("message" in response) {
            throw new Error(
              `getUnspentOutputs: Maestro threw "${response.message}"`
            );
          }
          const txOut = import_core3.TransactionOutput.fromCbor(
            (0, import_core3.HexBlob)(response.data.txout_cbor)
          );
          return new import_core3.TransactionUnspentOutput(txIn, txOut);
        } else {
          throw new Error(
            "getUnspentOutputByNFT: Could not parse response json"
          );
        }
      });
    }).then((x) => x);
  }
  async resolveUnspentOutputs(txIns) {
    const query = `/transactions/outputs?with_cbor=true`;
    const txInStrings = txIns.map(
      (txIn) => `${txIn.transactionId()}#${txIn.index()}`
    );
    try {
      const response = await fetch(`${this.url}${query}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json",
          ...this.headers()
        },
        body: JSON.stringify(txInStrings)
      });
      if (!response.ok) {
        throw new Error(
          `resolveUnspentOutputs: Failed to resolve unspent outputs from Maestro endpoint. Status code ${response.status}`
        );
      }
      const json = await response.json();
      if ("message" in json) {
        throw new Error(
          `resolveUnspentOutputs: Maestro threw "${json.message}"`
        );
      }
      const resolvedOutputs = json.data.map(
        (output) => {
          const txIn = new import_core3.TransactionInput(
            (0, import_core3.TransactionId)(output.tx_hash),
            BigInt(output.index)
          );
          const txOut = import_core3.TransactionOutput.fromCbor((0, import_core3.HexBlob)(output.txout_cbor));
          return new import_core3.TransactionUnspentOutput(txIn, txOut);
        }
      );
      return resolvedOutputs;
    } catch (error) {
      console.error("resolveUnspentOutputs:", error);
      throw new Error("resolveUnspentOutputs: Unexpected error occurred");
    }
  }
  resolveDatum(datumHash) {
    const query = `/datums/${datumHash}`;
    return fetch(`${this.url}${query}`, {
      headers: this.headers()
    }).then((resp) => resp.json()).then((json) => {
      if (json) {
        return import_core3.PlutusData.fromCbor((0, import_core3.HexBlob)(json.data.bytes));
      }
      throw new Error("resolveDatum: Could not parse response json");
    });
  }
  async awaitTransactionConfirmation(txId, timeout) {
    const startTime = Date.now();
    let finalResponse = false;
    const checkConfirmation = async () => {
      const response = await fetch(`${this.url}/transactions/${txId}/cbor`);
      if (response.ok) {
        finalResponse = true;
      } else if (Date.now() - startTime < (timeout || 0)) {
        await setTimeout(checkConfirmation, 2e4);
      }
    };
    await checkConfirmation();
    return Promise.resolve(finalResponse);
  }
  async postTransactionToChain(tx) {
    const query = `/txmanager`;
    console.log("attempting to submit ", tx.toCbor());
    return fetch(`${this.url}${query}`, {
      method: "POST",
      headers: {
        "Content-Type": "application/cbor",
        Accept: "text/plain",
        ...this.headers()
      },
      body: (0, import_core3.fromHex)(tx.toCbor())
    }).then(async (resp) => {
      if (!resp.ok) {
        console.log(JSON.stringify(resp));
        const body = await resp.text();
        throw new Error(
          `postTransactionToChain: failed to submit transaction to Maestro endpoint. Status code ${body}`
        );
      }
      return resp.text();
    }).then((result) => (0, import_core3.TransactionId)(result));
  }
  async evaluateTransaction(tx, additionalUtxos) {
    const query = `/transactions/evaluate`;
    const request = {
      additional_utxos: additionalUtxos.map((x) => ({
        txout_cbor: x.output().toCbor(),
        index: Number(x.input().index()),
        tx_hash: x.input().transactionId()
      })),
      cbor: tx.toCbor()
    };
    const response = await fetch(`${this.url}${query}`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
        ...this.headers()
      },
      body: JSON.stringify(request)
    });
    if (!response.ok) {
      console.log(JSON.stringify(response));
      const body = await response.text();
      throw new Error(
        `evaluateTransaction: failed to evaluate transaction with Maestro endpoint. Status code ${body}`
      );
    }
    const result = await response.json();
    const redeemers = tx.witnessSet().redeemers()?.values();
    if (!redeemers) {
      throw new Error("Cannot evaluate without redeemers!");
    }
    const lightRedeemers = result;
    for (const redeemerData of lightRedeemers) {
      const index = BigInt(redeemerData.redeemer_index);
      const purpose = purposeFromTag(redeemerData.redeemer_tag);
      const exUnits = import_core3.ExUnits.fromCore({
        memory: redeemerData.ex_units.mem,
        steps: redeemerData.ex_units.steps
      });
      const redeemer = redeemers.find(
        (x) => x.tag() == purpose && x.index() == index
      );
      if (!redeemer) {
        throw new Error(
          "evaluateTransaction: Maestro endpoint had extraneous redeemer data"
        );
      }
      redeemer.setExUnits(exUnits);
    }
    return import_core3.Redeemers.fromCore(redeemers.map((x) => x.toCore()));
  }
};
var fromMaestroLanguageVersion = (x) => {
  if (x == "plutus_v1") {
    return import_core3.PlutusLanguageVersion.V1;
  } else if (x == "plutus_v2") {
    return import_core3.PlutusLanguageVersion.V2;
  } else if (x == "plutus_v3") {
    return import_core3.PlutusLanguageVersion.V3;
  }
  throw new Error("fromMaestroLanguageVersion: Unreachable!");
};
function purposeFromTag(tag) {
  const tagMap = {
    spend: import_core2.RedeemerTag.Spend,
    mint: import_core2.RedeemerTag.Mint,
    cert: import_core2.RedeemerTag.Cert,
    wdrl: import_core2.RedeemerTag.Reward
  };
  const normalizedTag = tag.toLowerCase();
  if (normalizedTag in tagMap) {
    return tagMap[normalizedTag];
  } else {
    throw new Error(`Invalid tag: ${tag}.`);
  }
}

// src/blockfrost.ts
var import_core4 = require("@blaze-cardano/core");
var import_core5 = require("@blaze-cardano/core");
var Blockfrost = class extends Provider {
  constructor({
    network,
    projectId
  }) {
    super(network == "cardano-mainnet" ? import_core4.NetworkId.Mainnet : import_core4.NetworkId.Testnet);
    this.url = `https://${network}.blockfrost.io/api/v0/`;
    this.projectId = projectId;
  }
  headers() {
    return { project_id: this.projectId };
  }
  /**
   * This method fetches the protocol parameters from the Blockfrost API.
   * It constructs the query URL, sends a GET request with the appropriate headers, and processes the response.
   * The response is parsed into a ProtocolParameters object, which is then returned.
   * If the response is not in the expected format, an error is thrown.
   * @returns A Promise that resolves to a ProtocolParameters object.
   */
  async getParameters() {
    const query = "epochs/latest/parameters";
    const json = await fetch(`${this.url}${query}`, {
      headers: this.headers()
    }).then((resp) => resp.json());
    if (!json) {
      throw new Error("getParameters: Could not parse response json");
    }
    const response = json;
    if ("message" in response) {
      throw new Error(`getParameters: Blockfrost threw "${response.message}"`);
    }
    const costModels = /* @__PURE__ */ new Map();
    for (const [key, value] of Object.entries(response.cost_models_raw)) {
      costModels.set(
        fromBlockfrostLanguageVersion(key),
        value
      );
    }
    return {
      coinsPerUtxoByte: response.coins_per_utxo_size,
      maxTxSize: response.max_tx_size,
      minFeeCoefficient: response.min_fee_a,
      minFeeConstant: response.min_fee_b,
      maxBlockBodySize: response.max_block_size,
      maxBlockHeaderSize: response.max_block_header_size,
      stakeKeyDeposit: response.key_deposit,
      poolDeposit: response.pool_deposit,
      poolRetirementEpochBound: response.e_max,
      desiredNumberOfPools: response.n_opt,
      poolInfluence: response.a0,
      monetaryExpansion: response.rho,
      treasuryExpansion: response.tau,
      minPoolCost: response.min_pool_cost,
      protocolVersion: {
        major: response.protocol_major_ver,
        minor: response.protocol_minor_ver
      },
      maxValueSize: response.max_val_size,
      collateralPercentage: response.collateral_percent,
      maxCollateralInputs: response.max_collateral_inputs,
      costModels,
      prices: {
        memory: parseFloat(response.price_mem),
        steps: parseFloat(response.price_step)
      },
      maxExecutionUnitsPerTransaction: {
        memory: response.max_tx_ex_mem,
        steps: response.max_tx_ex_steps
      },
      maxExecutionUnitsPerBlock: {
        memory: response.max_block_ex_mem,
        steps: response.max_block_ex_steps
      },
      minFeeReferenceScripts: response.min_fee_ref_script_cost_per_byte ? {
        ...import_core4.hardCodedProtocolParams.minFeeReferenceScripts,
        base: response.min_fee_ref_script_cost_per_byte
      } : void 0
    };
  }
  /**
   * This method fetches the UTxOs under a given address.
   * The response is parsed into a TransactionUnspentOutput[] type, which is
   * then returned.
   * If the response is not in the expected format, an error is thrown.
   * @param address - The Address or Payment Credential
   * @returns A Promise that resolves to TransactionUnspentOutput[].
   */
  async getUnspentOutputs(address) {
    const maxPageCount = 100;
    let page = 1;
    const bech32 = address instanceof import_core4.Address ? address.toBech32() : new import_core4.Address({
      type: import_core4.AddressType.EnterpriseKey,
      paymentPart: address.toCore()
    }).toBech32();
    const buildTxUnspentOutput = this.buildTransactionUnspentOutput(
      import_core4.Address.fromBech32(bech32)
    );
    const results = /* @__PURE__ */ new Set();
    for (; ; ) {
      const pagination = `count=${maxPageCount}&page=${page}`;
      const query = `/addresses/${bech32}/utxos?${pagination}`;
      const json = await fetch(`${this.url}${query}`, {
        headers: this.headers()
      }).then((resp) => resp.json());
      if (!json) {
        throw new Error("getUnspentOutputs: Could not parse response json");
      }
      const response = json;
      if ("message" in response) {
        throw new Error(
          `getUnspentOutputs: Blockfrost threw "${response.message}"`
        );
      }
      for (const blockfrostUTxO of response) {
        results.add(await buildTxUnspentOutput(blockfrostUTxO));
      }
      if (response.length < maxPageCount) {
        break;
      } else {
        page = page + 1;
      }
    }
    return Array.from(results);
  }
  /**
   * This method fetches the UTxOs under a given address that hold
   * a particular asset.
   * The response is parsed into a TransactionUnspentOutput[] type, which is
   * then returned.
   * If the response is not in the expected format, an error is thrown.
   * @param address - Address or Payment Credential.
   * @param unit - The AssetId
   * @returns A Promise that resolves to TransactionUnspentOutput[].
   */
  async getUnspentOutputsWithAsset(address, unit) {
    const maxPageCount = 100;
    let page = 1;
    const bech32 = address instanceof import_core4.Address ? address.toBech32() : new import_core4.Address({
      type: import_core4.AddressType.EnterpriseKey,
      paymentPart: address.toCore()
    }).toBech32();
    const buildTxUnspentOutput = this.buildTransactionUnspentOutput(
      import_core4.Address.fromBech32(bech32)
    );
    const asset = import_core4.AssetId.getPolicyId(unit) + import_core4.AssetId.getAssetName(unit);
    const results = /* @__PURE__ */ new Set();
    for (; ; ) {
      const pagination = `count=${maxPageCount}&page=${page}`;
      const query = `/addresses/${bech32}/utxos/${asset}?${pagination}`;
      const json = await fetch(`${this.url}${query}`, {
        headers: this.headers()
      }).then((resp) => resp.json());
      if (!json) {
        throw new Error(
          "getUnspentOutputsWithAsset: Could not parse response json"
        );
      }
      const response = json;
      if ("message" in response) {
        throw new Error(
          `getUnspentOutputsWithAsset: Blockfrost threw "${response.message}"`
        );
      }
      for (const blockfrostUTxO of response) {
        results.add(await buildTxUnspentOutput(blockfrostUTxO));
      }
      if (response.length < maxPageCount) {
        break;
      } else {
        page = page + 1;
      }
    }
    return Array.from(results);
  }
  /**
   * This method fetches the UTxO that holds a particular NFT given as
   * argument.
   * The response is parsed into a TransactionUnspentOutput type, which is
   * then returned.
   * If the response is not in the expected format, an error is thrown.
   * @param nft - The AssetId for the NFT
   * @returns A Promise that resolves to TransactionUnspentOutput.
   */
  async getUnspentOutputByNFT(nft) {
    const asset = import_core4.AssetId.getPolicyId(nft) + import_core4.AssetId.getAssetName(nft);
    const query = `/assets/${asset}/addresses`;
    const json = await fetch(`${this.url}${query}`, {
      headers: this.headers()
    }).then((resp) => resp.json());
    if (!json) {
      throw new Error("getUnspentOutputByNFT: Could not parse response json");
    }
    const response = json;
    if ("message" in response) {
      throw new Error(
        `getUnspentOutputByNFT: Blockfrost threw "${response.message}"`
      );
    }
    if (response.length === 0) {
      throw new Error(
        "getUnspentOutputByNFT: No addresses found holding the asset."
      );
    }
    if (response.length > 1) {
      throw new Error(
        "getUnspentOutputByNFT: Asset must be held by only one address. Multiple found."
      );
    }
    const utxo = response[0];
    const address = import_core4.Address.fromBech32(utxo.address);
    const utxos = await this.getUnspentOutputsWithAsset(address, nft);
    if (utxos.length !== 1) {
      throw new Error(
        "getUnspentOutputByNFT: Asset must be present in only one UTxO. Multiple found."
      );
    }
    return utxos[0];
  }
  /**
   * This method resolves transaction outputs from a list of transaction
   * inputs given as argument.
   * The response is parsed into a TransactionUnspentOutput[] type, which is
   * then returned.
   * If the response is not in the expected format, an error is thrown.
   * @param txIns - A list of TransactionInput
   * @returns A Promise that resolves to TransactionUnspentOutput[].
   */
  async resolveUnspentOutputs(txIns) {
    const results = /* @__PURE__ */ new Set();
    for (const txIn of txIns) {
      const query = `/txs/${txIn.transactionId()}/utxos`;
      const json = await fetch(`${this.url}${query}`, {
        headers: this.headers()
      }).then((resp) => resp.json());
      if (!json) {
        throw new Error("resolveUnspentOutputs: Could not parse response json");
      }
      const response = json;
      if ("message" in response) {
        throw new Error(
          `resolveUnspentOutputs: Blockfrost threw "${response.message}"`
        );
      }
      const txIndex = BigInt(txIn.index());
      for (const blockfrostUTxO of response.outputs) {
        if (BigInt(blockfrostUTxO.output_index) !== txIndex) {
          continue;
        }
        blockfrostUTxO.tx_hash = txIn.transactionId();
        const buildTxUnspentOutput = this.buildTransactionUnspentOutput(
          import_core4.Address.fromBech32(blockfrostUTxO.address)
        );
        results.add(await buildTxUnspentOutput(blockfrostUTxO));
      }
    }
    return Array.from(results);
  }
  /**
   * This method returns the datum for the datum hash given as argument.
   * The response is parsed into a PlutusData type, which is then returned.
   * If the response is not in the expected format, an error is thrown.
   * @param datumHash - The hash of a datum
   * @returns A Promise that resolves to PlutusData
   */
  async resolveDatum(datumHash) {
    const query = `/scripts/datum/${datumHash}/cbor`;
    const json = await fetch(`${this.url}${query}`, {
      headers: this.headers()
    }).then((resp) => resp.json());
    if (!json) {
      throw new Error("resolveDatum: Could not parse response json");
    }
    const response = json;
    if ("message" in response) {
      throw new Error(`resolveDatum: Blockfrost threw "${response.message}"`);
    }
    return import_core4.PlutusData.fromCbor((0, import_core4.HexBlob)(response.cbor));
  }
  /**
   * This method awaits confirmation of the transaction given as argument.
   * The response is parsed into a boolean, which is then returned.
   * If tx is not confirmed at first and no value for timeout is provided,
   * then false is returned.
   * If tx is not confirmed at first and a value for timeout (in ms) is given,
   * then subsequent checks will be performed at a 20 second interval until
   * timeout is reached.
   * @param txId - The hash of a transaction
   * @param timeout - An optional timeout for waiting for confirmation. This
   * value should be greater than average block time of 20000 ms
   * @returns A Promise that resolves to a boolean
   */
  async awaitTransactionConfirmation(txId, timeout) {
    const averageBlockTime = 2e4;
    if (timeout && timeout < averageBlockTime) {
      console.log("Warning: timeout given is less than average block time.");
    }
    const query = `/txs/${txId}/metadata/cbor`;
    const startTime = Date.now();
    const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
    const checkConfirmation = async () => {
      const response = await fetch(`${this.url}${query}`, {
        headers: this.headers()
      });
      return response.ok;
    };
    if (await checkConfirmation()) {
      return true;
    }
    if (timeout) {
      while (Date.now() - startTime < timeout) {
        await delay(averageBlockTime);
        if (await checkConfirmation()) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * This method submits a transaction to the chain.
   * @param tx - The Transaction
   * @returns A Promise that resolves to a TransactionId type
   */
  async postTransactionToChain(tx) {
    const query = "/tx/submit";
    const response = await fetch(`${this.url}${query}`, {
      method: "POST",
      headers: {
        "Content-Type": "application/cbor",
        ...this.headers()
      },
      body: (0, import_core4.fromHex)(tx.toCbor())
    });
    if (!response.ok) {
      const error = await response.text();
      throw new Error(
        `postTransactionToChain: failed to submit transaction to Blockfrost endpoint.
Error ${error}`
      );
    }
    const txId = await response.json();
    return (0, import_core4.TransactionId)(txId);
  }
  /**
   * This method evaluates how much execution units a transaction requires.
   * Optionally, additional outputs can be provided. These are added to the
   * evaluation without checking for their presence on-chain. This is useful
   * when performing transaction chaining, where some outputs used as inputs
   * to a transaction will have not yet been submitted to the network.
   * @param tx - The Transaction
   * @param additionalUtxos - Optional utxos to be added to the evaluation.
   * @returns A Promise that resolves to a Redeemers type
   */
  async evaluateTransaction(tx, additionalUtxos) {
    const currentRedeemers = tx.witnessSet().redeemers()?.values();
    if (!currentRedeemers || currentRedeemers.length === 0) {
      throw new Error(
        `evaluateTransaction: No Redeemers found in transaction"`
      );
    }
    const additionalUtxoSet = /* @__PURE__ */ new Set();
    for (const utxo of additionalUtxos || []) {
      const txIn = {
        txId: utxo.input().transactionId(),
        index: utxo.input().index()
      };
      const output = utxo.output();
      const value = output.amount();
      const txOut = {
        address: output.address(),
        value: {
          coins: value.coin(),
          assets: value.multiasset()
        },
        datum_hash: output.datum()?.asDataHash(),
        datum: output.datum()?.asInlineData()?.toCbor(),
        script: output.scriptRef()?.toCbor()
      };
      additionalUtxoSet.add([txIn, txOut]);
    }
    const payload = {
      cbor: tx.toCbor(),
      additionalUtxoset: Array.from(additionalUtxoSet)
    };
    const query = "/utils/txs/evaluate/utxos";
    const response = await fetch(`${this.url}${query}`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
        ...this.headers()
      },
      body: JSON.stringify(
        payload,
        (_, value) => typeof value === "bigint" ? value.toString() : value
      )
    });
    if (!response.ok) {
      const error = await response.text();
      throw new Error(
        `evaluateTransaction: failed to evaluate transaction with additional UTxO set in Blockfrost endpoint.
Error ${error}`
      );
    }
    const json = await response.json();
    if ("message" in json) {
      throw new Error(
        `evaluateTransaction: Blockfrost threw "${json.message}"`
      );
    }
    const evaledRedeemers = /* @__PURE__ */ new Set();
    if (!("EvaluationResult" in json.result)) {
      throw new Error(
        `evaluateTransaction: Blockfrost endpoint returned evaluation failure.`
      );
    }
    const result = json.result.EvaluationResult;
    for (const redeemerPointer in result) {
      const [pTag, pIndex] = redeemerPointer.split(":");
      const purpose = purposeToTag[pTag];
      const index = BigInt(pIndex);
      const data = result[redeemerPointer];
      const exUnits = import_core4.ExUnits.fromCore({
        memory: data.memory,
        steps: data.steps
      });
      const redeemer = currentRedeemers.find(
        (x) => x.tag() == purpose && x.index() == index
      );
      if (!redeemer) {
        throw new Error(
          "evaluateTransaction: Blockfrost endpoint had extraneous redeemer data"
        );
      }
      redeemer.setExUnits(exUnits);
      evaledRedeemers.add(redeemer);
    }
    return import_core4.Redeemers.fromCore(
      Array.from(evaledRedeemers).map((x) => x.toCore())
    );
  }
  async getScriptRef(scriptHash) {
    const typeQuery = `/scripts/${scriptHash}`;
    const typeJson = await fetch(`${this.url}${typeQuery}`, {
      headers: this.headers()
    }).then((resp) => resp.json());
    if (!typeJson) {
      throw new Error("getScriptRef: Could not parse response json");
    }
    const typeResponse = typeJson;
    if ("message" in typeResponse) {
      throw new Error(
        `getScriptRef: Blockfrost threw "${typeResponse.message}"`
      );
    }
    const type = typeResponse.type;
    if (type == "timelock") {
      throw new Error("getScriptRef: Native scripts are not yet supported.");
    }
    const cborQuery = `/scripts/${scriptHash}/cbor`;
    const cborJson = await fetch(`${this.url}${cborQuery}`, {
      headers: this.headers()
    }).then((resp) => resp.json());
    if (!cborJson) {
      throw new Error("getScriptRef: Could not parse response json");
    }
    const cborResponse = cborJson;
    if ("message" in cborResponse) {
      throw new Error(
        `getScriptRef: Blockfrost threw "${cborResponse.message}"`
      );
    }
    const cbor = (0, import_core4.HexBlob)(cborResponse.cbor);
    switch (type) {
      case "plutusV1":
        return import_core4.Script.newPlutusV1Script(new import_core4.PlutusV1Script(cbor));
      case "plutusV2":
        return import_core4.Script.newPlutusV2Script(new import_core4.PlutusV2Script(cbor));
    }
  }
  // Partially applies address in order to avoid sending it
  // as argument repeatedly when building TransactionUnspentOutput
  buildTransactionUnspentOutput(address) {
    return async (blockfrostUTxO) => {
      const txIn = new import_core4.TransactionInput(
        (0, import_core4.TransactionId)(blockfrostUTxO.tx_hash),
        BigInt(blockfrostUTxO.output_index)
      );
      const tokenMap = /* @__PURE__ */ new Map();
      let lovelace = 0n;
      for (const { unit, quantity } of blockfrostUTxO.amount) {
        if (unit === "lovelace") {
          lovelace = BigInt(quantity);
        } else {
          tokenMap.set(unit, BigInt(quantity));
        }
      }
      const txOut = new import_core4.TransactionOutput(
        address,
        new import_core4.Value(lovelace, tokenMap)
      );
      const datum = blockfrostUTxO.inline_datum ? import_core4.Datum.newInlineData(
        import_core4.PlutusData.fromCbor((0, import_core4.HexBlob)(blockfrostUTxO.inline_datum))
      ) : blockfrostUTxO.data_hash ? import_core4.Datum.newDataHash((0, import_core4.DatumHash)(blockfrostUTxO.data_hash)) : void 0;
      if (datum) txOut.setDatum(datum);
      if (blockfrostUTxO.reference_script_hash)
        txOut.setScriptRef(
          await this.getScriptRef(
            (0, import_core4.Hash28ByteBase16)(blockfrostUTxO.reference_script_hash)
          )
        );
      return new import_core4.TransactionUnspentOutput(txIn, txOut);
    };
  }
};
var fromBlockfrostLanguageVersion = (x) => {
  if (x == "PlutusV1") {
    return import_core5.PlutusLanguageVersion.V1;
  } else if (x == "PlutusV2") {
    return import_core5.PlutusLanguageVersion.V2;
  } else if (x == "PlutusV3") {
    return import_core5.PlutusLanguageVersion.V3;
  }
  throw new Error("fromBlockfrostLanguageVersion: Unreachable!");
};

// src/kupmios.ts
var import_core6 = require("@blaze-cardano/core");
var _Kupmios = class _Kupmios extends Provider {
  /**
   * Constructor to initialize Kupmios instance.
   * @param kupoUrl - URL of the Kupo service.
   * @param ogmiosUrl - URL of the Ogmios service.
   */
  constructor(kupoUrl, ogmios) {
    super(
      ogmios.url.includes("mainnet-v6") ? import_core6.NetworkId.Mainnet : import_core6.NetworkId.Testnet
    );
    this.kupoUrl = kupoUrl;
    this.ogmios = ogmios;
  }
  /**
   * Parses a fractional string into a number.
   * @param fraction - Fractional string in the format "numerator/denominator".
   * @returns The parsed fraction as a number.
   */
  parseFraction(fraction) {
    const [numerator, denominator] = fraction.split("/").map(Number);
    return numerator / denominator;
  }
  /**
   * Fetches unspent outputs using Kupo API.
   * @param prefix - Prefix for the URL.
   * @param postfix - Postfix for the URL.
   * @returns A promise that resolves to an array of fully resolved unspent outputs.
   */
  async _getUnspentOutputs(prefix, postfix) {
    const url = `${this.kupoUrl}/matches/${prefix ? prefix : "*"}?unspent${postfix ? postfix : ""}`;
    const result = await fetch(url).then((res) => res.json());
    return await Promise.all(
      result.map(async (utxo) => {
        const transactionId = utxo.transaction_id;
        const outputIndex = BigInt(utxo.output_index);
        const address = import_core6.Address.fromBech32(utxo.address);
        const coins = BigInt(utxo.value.coins);
        const assets = utxo.value.assets;
        const tokenMap = Object.keys(assets).reduce((map, unit) => {
          map.set((0, import_core6.AssetId)(unit), BigInt(assets[unit]));
          return map;
        }, /* @__PURE__ */ new Map());
        const value = new import_core6.Value(coins, tokenMap);
        const output = new import_core6.TransactionOutput(address, value);
        if (utxo.datum_hash) {
          const datum = utxo.datum_type === "hash" ? new import_core6.Datum(utxo.datum_hash, void 0) : new import_core6.Datum(void 0, await this.resolveDatum(utxo.datum_hash));
          output.setDatum(datum);
        }
        if (utxo.script_hash) {
          const scriptRef = await this.resolveScript(utxo.script_hash);
          output.setScriptRef(scriptRef);
        }
        return new import_core6.TransactionUnspentOutput(
          new import_core6.TransactionInput((0, import_core6.TransactionId)(transactionId), outputIndex),
          output
        );
      })
    );
  }
  /**
   * Gets unspent outputs for a given address.
   * @param address - Address to fetch unspent outputs for.
   * @returns A promise that resolves to an array of unspent outputs.
   */
  async getUnspentOutputs(address) {
    const prefix = address.toBech32();
    return this._getUnspentOutputs(prefix, null);
  }
  /**
   * Gets unspent outputs containing a specific asset.
   * @param address - Address to fetch unspent outputs for.
   * @param unit - Asset ID to filter by.
   * @returns A promise that resolves to an array of unspent outputs.
   */
  async getUnspentOutputsWithAsset(address, unit) {
    const policyId = unit.slice(0, 56);
    const assetName = unit.slice(56);
    const prefix = address ? address.toBech32() : `${policyId}.${assetName}`;
    const postfix = address ? `&policy_id=${policyId}&asset_name=${assetName}` : "";
    return this._getUnspentOutputs(prefix, postfix);
  }
  /**
   * Gets an unspent output containing a specific NFT.
   * @param unit - Asset ID of the NFT.
   * @returns A promise that resolves to the unspent output.
   */
  async getUnspentOutputByNFT(unit) {
    const res = await this.getUnspentOutputsWithAsset(null, unit);
    if (res.length === 1) {
      return res[0];
    } else {
      throw new Error(`Error fetching unspent outputs ${unit}`);
    }
  }
  /**
   * Resolves unspent outputs for given transaction inputs.
   * @param txIns - Array of transaction inputs.
   * @returns A promise that resolves to an array of unspent outputs.
   */
  async resolveUnspentOutputs(txIns) {
    const results = /* @__PURE__ */ new Set();
    await Promise.all(
      txIns.map(async (txIn) => {
        const prefix = `${txIn.index()}@${txIn.transactionId()}`;
        const outputs = await this._getUnspentOutputs(prefix, null);
        if (outputs.length === 1) {
          results.add(outputs[0]);
        }
      })
    );
    const resultArray = Array.from(results);
    if (txIns.length !== resultArray.length) {
      throw new Error("Inconsistent transaction inputs");
    }
    return resultArray;
  }
  /**
   * Gets the protocol parameters from the blockchain.
   * @returns A promise that resolves to the protocol parameters.
   */
  async getParameters() {
    return this.ogmios.queryLedgerStateProtocolParameters().then((result) => {
      const createCostModels = (versions, result2) => {
        const costModels2 = /* @__PURE__ */ new Map();
        versions.forEach((version, index) => {
          costModels2.set(
            index,
            result2.plutusCostModels?.[version] ? result2.plutusCostModels[version].map((val) => val) : []
          );
        });
        return costModels2;
      };
      const costModels = createCostModels(_Kupmios.plutusVersions, result);
      return {
        coinsPerUtxoByte: result.minUtxoDepositCoefficient,
        maxTxSize: result.maxTransactionSize?.bytes || 0,
        minFeeCoefficient: result.minFeeCoefficient,
        minFeeConstant: Number(result.minFeeConstant.ada.lovelace),
        maxBlockBodySize: result.maxBlockBodySize.bytes,
        maxBlockHeaderSize: result.maxBlockHeaderSize.bytes,
        stakeKeyDeposit: Number(result.stakeCredentialDeposit.ada.lovelace),
        poolDeposit: result.stakePoolDeposit ? Number(result.stakePoolDeposit.ada.lovelace) : null,
        poolRetirementEpochBound: result.stakePoolRetirementEpochBound,
        desiredNumberOfPools: result.desiredNumberOfStakePools,
        poolInfluence: result.stakePoolPledgeInfluence.toString(),
        monetaryExpansion: result.monetaryExpansion.toString(),
        treasuryExpansion: result.treasuryExpansion.toString(),
        minPoolCost: Number(result.minStakePoolCost.ada.lovelace),
        protocolVersion: {
          major: result.version.major,
          minor: result.version.minor
        },
        maxValueSize: result.maxValueSize?.bytes || 0,
        collateralPercentage: result.collateralPercentage || 0,
        maxCollateralInputs: result.maxCollateralInputs || 0,
        costModels: costModels || {},
        prices: {
          steps: this.parseFraction(result.scriptExecutionPrices.cpu),
          memory: this.parseFraction(result.scriptExecutionPrices.memory)
        },
        maxExecutionUnitsPerTransaction: {
          steps: result.maxExecutionUnitsPerTransaction.cpu,
          memory: result.maxExecutionUnitsPerTransaction.memory
        },
        maxExecutionUnitsPerBlock: {
          steps: result.maxExecutionUnitsPerBlock.cpu,
          memory: result.maxExecutionUnitsPerBlock.memory
        },
        minFeeReferenceScripts: result.minFeeReferenceScripts
      };
    });
  }
  /**
   * Resolves the datum for a given datum hash.
   * @param datumHash - Hash of the datum to resolve.
   * @returns A promise that resolves to the Plutus data.
   */
  async resolveDatum(datumHash) {
    const url = `${this.kupoUrl}/datums/${datumHash}`;
    const result = await fetch(url).then((res) => res.json());
    if (!result || !result.datum) {
      throw new Error(`No datum found for datum hash: ${datumHash}`);
    }
    return import_core6.PlutusData.fromCbor(result.datum);
  }
  /**
   * Awaits confirmation of a transaction.
   * @param txId - ID of the transaction to await confirmation for.
   * @param timeout - Optional timeout in milliseconds.
   * @returns A promise that resolves to a boolean indicating confirmation status.
   */
  async awaitTransactionConfirmation(txId, timeout = 5 * _Kupmios.confirmationTimeout) {
    const startTime = Date.now();
    const checkConfirmation = async () => {
      const response = await fetch(`${this.kupoUrl}/matches/0@${txId}`);
      if (response.ok && (await response.json().then((res) => res.length), (_res) => false)) {
        return true;
      } else if (Date.now() - startTime < timeout) {
        await new Promise(
          (resolve) => setTimeout(resolve, _Kupmios.confirmationTimeout)
        );
        return checkConfirmation();
      }
      return false;
    };
    return await checkConfirmation();
  }
  /**
   * Posts a transaction to the blockchain.
   * @param tx - Transaction to post.
   * @returns A promise that resolves to the transaction ID.
   */
  async postTransactionToChain(tx) {
    return this.ogmios.submitTransaction({ cbor: tx.toCbor() }).then((result) => {
      return (0, import_core6.TransactionId)(result.transaction.id);
    });
  }
  /**
   * Resolves the scripts for a given script hash.
   * @param scriptHash - Hash of the script to resolve.
   * @returns A promise that resolves to the JSON represenation of the scrip.
   * Note: we should reconsider creating a class for this as it could be expensive operation
   */
  async resolveScript(scriptHash) {
    const url = `${this.kupoUrl}/scripts/${scriptHash}`;
    const result = await fetch(url).then((res) => res.json());
    if (!result || !result.language || !result.script) {
      throw new Error(`No script found for script hash: ${scriptHash}`);
    }
    switch (result.language) {
      case "native":
        return import_core6.Script.newNativeScript(import_core6.NativeScript.fromCbor(result.script));
      case "plutus:v1":
        return import_core6.Script.newPlutusV1Script(new import_core6.PlutusV1Script(result.script));
      case "plutus:v2":
        return import_core6.Script.newPlutusV2Script(new import_core6.PlutusV2Script(result.script));
      case "plutus:v3":
        return import_core6.Script.newPlutusV3Script(new import_core6.PlutusV3Script(result.script));
      default:
        throw new Error(`Unsupported script language: ${result.language}`);
    }
  }
  /**
   * Evaluates a transaction.
   * @param tx - Transaction to evaluate.
   * @param additionalUtxos - Additional UTXOs to consider.
   * @returns A promise that resolves to the redeemers.
   */
  async evaluateTransaction(tx, additionalUtxos) {
    try {
      const redeemers = tx.witnessSet().redeemers()?.values();
      if (!redeemers) {
        throw new Error("Cannot evaluate without redeemers!");
      }
      const additionalInputs = additionalUtxos.map((utxo) => utxo.input());
      const utxosToDrop = await this.resolveUnspentOutputs(additionalInputs);
      const additional_utxos = _Kupmios.serializeUtxos(
        additionalUtxos.filter((utxo) => {
          return !utxosToDrop.includes(utxo);
        })
      );
      return this.ogmios.evaluateTransaction({ cbor: tx.toCbor() }, additional_utxos).then((results) => {
        if (results.length !== redeemers.length) {
          throw new Error(
            "Kupmios endpoint returned inconsistent length of the redeemers"
          );
        }
        const updatedRedeemers = results.map((redeemerData) => {
          const exUnits = import_core6.ExUnits.fromCore({
            memory: redeemerData.budget.memory,
            steps: redeemerData.budget.cpu
          });
          const redeemer = redeemers.find(
            (x) => Number(x.index()) === redeemerData.validator.index && // TODO: RedeemerPurpose enum's indexes are still inconsistent. They are not the same as RedeemerTag values.
            x.tag() === purposeToTag[redeemerData.validator.purpose]
          );
          if (!redeemer) {
            throw new Error(
              "Kupmios endpoint returned extraneous redeemer data"
            );
          }
          redeemer.setExUnits(exUnits);
          return redeemer.toCore();
        });
        return import_core6.Redeemers.fromCore(updatedRedeemers);
      });
    } catch (error) {
      console.error("Error evaluating transaction:", error);
      throw error;
    }
  }
  /**
   * Serialize unspent outputs to JSON format.
   * @param unspentOutputs - Unspent outputs to serialize.
   * @returns the serialized unspent outputs.
   */
  static serializeUtxos(unspentOutputs) {
    return unspentOutputs.map((output) => {
      const out = output.output();
      const address = out.address().toBech32();
      const ada = out.amount().coin().valueOf();
      const value = { ada: { lovelace: ada } };
      const multiAsset = out.amount().multiasset?.();
      multiAsset?.forEach((assets, assetId) => {
        const policyID = import_core6.AssetId.getPolicyId(assetId);
        const assetName = import_core6.AssetId.getAssetName(assetId);
        value[policyID] ?? (value[policyID] = {});
        value[policyID][assetName] = assets;
      });
      const datumHash = out.datum()?.asDataHash()?.toString();
      const datum = out.datum()?.asInlineData()?.toCbor();
      const scriptRef = out.scriptRef();
      let script;
      if (scriptRef) {
        const langIndex = scriptRef.language();
        const language = _Kupmios.plutusVersions[langIndex - 1];
        script = {
          language: language || "native",
          cbor: langIndex === 0 ? scriptRef.toCbor() : scriptRef[`asPlutusV${langIndex}`]().rawBytes()
        };
      }
      return {
        transaction: {
          id: output.input().transactionId().toString()
        },
        index: Number(output.input().index()),
        address,
        value,
        datumHash,
        datum,
        script
      };
    });
  }
};
_Kupmios.plutusVersions = [
  "plutus:v1",
  "plutus:v2",
  "plutus:v3"
];
_Kupmios.confirmationTimeout = 2e4;
var Kupmios = _Kupmios;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Blockfrost,
  Kupmios,
  Maestro,
  Provider,
  fromBlockfrostLanguageVersion,
  purposeToTag
});
