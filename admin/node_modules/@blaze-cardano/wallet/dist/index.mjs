// src/types.ts
var Wallet = class {
};

// src/wallets.ts
var WalletDetails = [
  {
    namespace: "nami",
    name: "Nami Wallet",
    websiteUrl: "https://www.namiwallet.io/"
  }
];

// src/web.ts
import {
  Address,
  HexBlob,
  RewardAddress,
  TransactionId,
  TransactionUnspentOutput,
  TransactionWitnessSet,
  Value
} from "@blaze-cardano/core";
var WebWallet = class {
  /**
   * Constructs a new instance of the WebWallet class.
   * @param {CIP30Interface} webWallet - The CIP30Interface to be used.
   */
  constructor(webWallet) {
    this.webWallet = webWallet;
  }
  /**
   * Retrieves the network ID of the currently connected account.
   * @returns {Promise<NetworkId>} - The network ID of the currently connected account.
   */
  async getNetworkId() {
    const id = await this.webWallet.getNetworkId();
    switch (id) {
      case 0:
        return 0;
      case 1:
        return 1;
      default:
        throw new Error("Could not resolve CIP30 network id.");
    }
  }
  /**
   * Retrieves the UTxO(s) controlled by the wallet.
   * @returns {Promise<TransactionUnspentOutput[]>} - The UTXO(s) controlled by the wallet.
   */
  async getUnspentOutputs() {
    const utxos = await this.webWallet.getUtxos();
    return (utxos ?? []).map(
      (utxo) => TransactionUnspentOutput.fromCbor(HexBlob(utxo))
    );
  }
  /**
   * Retrieves the total available balance of the wallet, encoded in CBOR.
   * @returns {Promise<Value>} - The balance of the wallet.
   */
  async getBalance() {
    const balance = await this.webWallet.getBalance();
    return Value.fromCbor(HexBlob(balance));
  }
  /**
   * Retrieves all used addresses controlled by the wallet.
   * @returns {Promise<Address[]>} - The used addresses controlled by the wallet.
   */
  async getUsedAddresses() {
    const addresses = await this.webWallet.getUsedAddresses();
    return addresses.map((addy) => {
      const parsedAddy = Address.fromString(addy);
      if (!parsedAddy) {
        throw new Error(
          "getUsedAddresses: Wallet API returned an invalid used address."
        );
      }
      return parsedAddy;
    });
  }
  /**
   * Retrieves all unused addresses controlled by the wallet.
   * @returns {Promise<Address[]>} - The unused addresses controlled by the wallet.
   */
  async getUnusedAddresses() {
    const addresses = await this.webWallet.getUnusedAddresses();
    return addresses.map((addy) => {
      const parsedAddy = Address.fromString(addy);
      if (!parsedAddy) {
        throw new Error(
          "getUnusedAddresses: Wallet API returned an invalid unused address."
        );
      }
      return parsedAddy;
    });
  }
  /**
   * Retrieves an address owned by the wallet which should be used to return transaction change.
   * @returns {Promise<Address>} - The change address.
   */
  async getChangeAddress() {
    const addy = await this.webWallet.getChangeAddress();
    const parsedAddy = Address.fromString(addy);
    if (!parsedAddy) {
      throw new Error(
        "getChangeAddress: Wallet API returned an invalid change address."
      );
    }
    return parsedAddy;
  }
  /**
   * Retrieves the reward addresses controlled by the wallet.
   * @returns {Promise<RewardAddress[]>} - The reward addresses controlled by the wallet.
   */
  async getRewardAddresses() {
    const addresses = await this.webWallet.getRewardAddresses();
    return addresses.map((addy) => {
      const parsedAddy = Address.fromString(addy);
      if (!parsedAddy) {
        throw new Error(
          "getRewardAddresses: Wallet API returned an invalid address."
        );
      }
      const parsedRewardAddy = RewardAddress.fromAddress(parsedAddy);
      if (!parsedRewardAddy) {
        throw new Error(
          "getRewardAddresses: Wallet API returned an invalid reward address."
        );
      }
      return parsedRewardAddy;
    });
  }
  /**
   * Requests a transaction signature from the wallet.
   * @param {string} tx - The transaction to sign.
   * @param {boolean} partialSign - Whether to partially sign the transaction.
   * @returns {Promise<TransactionWitnessSet>} - The signed transaction.
   */
  async signTransaction(tx, partialSign) {
    const witnessSet = await this.webWallet.signTx(tx.toCbor(), partialSign);
    return TransactionWitnessSet.fromCbor(HexBlob(witnessSet));
  }
  /**
   * Requests signed data from the wallet.
   * @param {Address} address - The address to sign the data with.
   * @param {string} payload - The data to sign.
   * @returns {Promise<CIP30DataSignature>} - The signed data.
   */
  async signData(address, payload) {
    const { signature, key } = await this.webWallet.signData(
      address.toBech32(),
      payload
    );
    return {
      key: HexBlob(key),
      signature: HexBlob(signature)
    };
  }
  /**
   * Submits a transaction through the wallet.
   * @param {Transaction} tx - The transaction to submit.
   * @returns {Promise<TransactionId>} - The ID of the submitted transaction.
   */
  async postTransaction(tx) {
    const transactionId = await this.webWallet.submitTx(tx.toCbor());
    return TransactionId.fromHexBlob(HexBlob(transactionId));
  }
  /**
   * Retrieves the collateral UTxO(s) for the wallet.
   * @returns {Promise<TransactionUnspentOutput[]>} - The collateral for the wallet.
   */
  async getCollateral() {
    const utxos = await this.webWallet.getCollateral();
    return (utxos ?? []).map(
      (utxo) => TransactionUnspentOutput.fromCbor(HexBlob(utxo))
    );
  }
};

// src/hot.ts
import {
  Address as Address2,
  AddressType,
  TransactionWitnessSet as TransactionWitnessSet2,
  CredentialType,
  VkeyWitness,
  CborSet,
  HexBlob as HexBlob3,
  Bip32PrivateKey,
  NetworkId,
  Hash28ByteBase16
} from "@blaze-cardano/core";
import * as value from "@blaze-cardano/tx/value";

// src/utils.ts
import {
  fromHex,
  toHex,
  HexBlob as HexBlob2
} from "@blaze-cardano/core";
async function signData(addressHex, payload, privateKey) {
  const {
    Label,
    CBORValue,
    COSESign1Builder,
    Headers,
    HeaderMap,
    ProtectedHeaderMap,
    Int,
    BigNum,
    AlgorithmId,
    COSEKey,
    KeyType
  } = await // @ts-expect-error - TS doesn't recognize window object
  (typeof window === "undefined" ? import("@emurgo/cardano-message-signing-nodejs") : import("@emurgo/cardano-message-signing-browser"));
  const protectedHeaders = HeaderMap.new();
  protectedHeaders.set_algorithm_id(Label.from_algorithm_id(AlgorithmId.EdDSA));
  protectedHeaders.set_header(
    Label.new_text("address"),
    CBORValue.new_bytes(fromHex(addressHex))
  );
  const protectedSerialized = ProtectedHeaderMap.new(protectedHeaders);
  const unprotectedHeaders = HeaderMap.new();
  const headers = Headers.new(protectedSerialized, unprotectedHeaders);
  const builder = COSESign1Builder.new(headers, fromHex(payload), false);
  const toSign = builder.make_data_to_sign().to_bytes();
  8;
  const publicKey = await privateKey.toPublic();
  const signedSigStruc = await privateKey.sign(HexBlob2(toHex(toSign)));
  const coseSign1 = builder.build(signedSigStruc.bytes());
  const key = COSEKey.new(
    Label.from_key_type(KeyType.OKP)
    //OKP
  );
  key.set_algorithm_id(Label.from_algorithm_id(AlgorithmId.EdDSA));
  key.set_header(
    Label.new_int(Int.new_negative(BigNum.from_str("1"))),
    CBORValue.new_int(
      Int.new_i32(6)
      //CurveType.Ed25519
    )
  );
  key.set_header(
    Label.new_int(Int.new_negative(BigNum.from_str("2"))),
    CBORValue.new_bytes(publicKey.bytes())
  );
  return {
    signature: HexBlob2(toHex(coseSign1.to_bytes())),
    key: HexBlob2(toHex(key.to_bytes()))
  };
}

// src/hot.ts
var _HotWallet = class _HotWallet {
  /**
   * Constructs a new instance of the HotWallet class.
   * @param {Address} address - the wallets's address
   * @param {RewardAddress} rewardAddress - the wallet's reward address if there is any
   * @param {Bip32PrivateKey} signingKey - The signing key of the derived account's of wallet.
   * @param {Bip32PublicKey} publicKey - The public key of the derived account's of the wallet.
   * @param {Provider} provider - The provider of the wallet.
   */
  constructor(address, rewardAddress, signingKey, publicKey, provider, stakePaymentKey) {
    this.address = address;
    this.rewardAddress = rewardAddress;
    this.networkId = this.address.getNetworkId();
    this.signingKey = signingKey;
    this.publicKey = publicKey;
    this.provider = provider;
    this.stakeSigningKey = stakePaymentKey;
  }
  static async generateAccountAddressFromMasterkey(masterkey, networkId = NetworkId.Testnet, addressType = AddressType.BasePaymentKeyStakeKey) {
    if (addressType !== AddressType.BasePaymentKeyStakeKey && addressType !== AddressType.EnterpriseKey) {
      throw new Error(
        "Hot wallets only support the BasePaymentKeyStakeKey and EnterpriseKey adresses!"
      );
    }
    const accountKey = await masterkey.derive([
      this.harden(1852),
      this.harden(1815),
      this.harden(0)
    ]);
    const paymentKey = await accountKey.derive([0, 0]);
    const stakePaymentKey = await accountKey.derive([2, 0]);
    const address = new Address2({
      type: addressType,
      networkId,
      paymentPart: {
        type: CredentialType.KeyHash,
        hash: Hash28ByteBase16.fromEd25519KeyHashHex(
          (await (await paymentKey.toPublic()).toRawKey().hash()).hex()
        )
      },
      delegationPart: addressType === AddressType.EnterpriseKey ? void 0 : {
        type: CredentialType.KeyHash,
        // 1852H/1815H/0H/2/0
        hash: Hash28ByteBase16.fromEd25519KeyHashHex(
          (await (await (await accountKey.derive([2, 0])).toPublic()).toRawKey().hash()).hex()
        )
      }
    });
    return {
      address,
      paymentKey,
      stakePaymentKey,
      publicKey: await paymentKey.toPublic()
    };
  }
  static async fromMasterkey(masterkey, provider, networkId = NetworkId.Testnet, addressType = AddressType.BasePaymentKeyStakeKey) {
    const rootKey = Bip32PrivateKey.fromHex(masterkey);
    const { address, paymentKey, stakePaymentKey, publicKey } = await this.generateAccountAddressFromMasterkey(
      rootKey,
      networkId,
      addressType
    );
    return new _HotWallet(
      address,
      address.asReward(),
      paymentKey,
      publicKey,
      provider,
      stakePaymentKey
    );
  }
  /**
   * Retrieves the network ID of the currently connected account.
   * @returns {Promise<NetworkId>} - The network ID of the currently connected account.
   */
  async getNetworkId() {
    return this.networkId;
  }
  /**
   * Retrieves the UTxO(s) controlled by the wallet.
   * @returns {Promise<TransactionUnspentOutput[]>} - The UTXO(s) controlled by the wallet.
   */
  async getUnspentOutputs() {
    return this.provider.getUnspentOutputs(this.address);
  }
  /**
   * Retrieves the total available balance of the wallet, encoded in CBOR.
   * @returns {Promise<Value>} - The balance of the wallet.
   */
  async getBalance() {
    let balance = value.zero();
    const utxos = await this.getUnspentOutputs();
    for (const utxo of utxos) {
      balance = value.merge(balance, utxo.output().amount());
    }
    return balance;
  }
  /**
   * Retrieves all used addresses controlled by the wallet.
   * @returns {Promise<Address[]>} - The used addresses controlled by the wallet.
   */
  async getUsedAddresses() {
    return [this.address];
  }
  /**
   * Retrieves all unused addresses controlled by the wallet.
   * @returns {Promise<Address[]>} - The unused addresses controlled by the wallet.
   */
  async getUnusedAddresses() {
    return [];
  }
  /**
   * Retrieves an address owned by the wallet which should be used to return transaction change.
   * @returns {Promise<Address>} - The change address.
   */
  async getChangeAddress() {
    return this.address;
  }
  /**
   * Retrieves the reward addresses controlled by the wallet.
   * @returns {Promise<RewardAddress[]>} - The reward addresses controlled by the wallet.
   */
  async getRewardAddresses() {
    return this.rewardAddress ? [this.rewardAddress] : [];
  }
  /**
   * Requests a transaction signature from the wallet.
   * @param {string} tx - The transaction to sign.
   * @param {boolean} partialSign - Whether to partially sign the transaction.
   * @returns {Promise<TransactionWitnessSet>} - The signed transaction.
   */
  async signTransaction(tx, partialSign = true) {
    if (partialSign == false) {
      throw new Error(
        "signTx: Hot wallet only supports partial signing = true"
      );
    }
    const signature = await this.signingKey.toRawKey().sign(HexBlob3(tx.getId()));
    const tws = new TransactionWitnessSet2();
    const vkw = new VkeyWitness(
      this.publicKey.toRawKey().hex(),
      signature.hex()
    );
    tws.setVkeys(CborSet.fromCore([vkw.toCore()], VkeyWitness.fromCore));
    return tws;
  }
  /**
   * Requests signed data from the wallet.
   * @param {Address} address - The address to sign the data with.
   * @param {string} payload - The data to sign.
   * @returns {Promise<CIP30DataSignature>} - The signed data.
   */
  async signData(address, payload) {
    const paymentKey = address.getProps().paymentPart;
    const signingPublic = await this.signingKey.toPublic();
    const stakeSigningPublic = await this.stakeSigningKey?.toPublic();
    const signingKeyHash = await signingPublic.toRawKey().hash();
    const stakeSigningKeyHash = await stakeSigningPublic?.toRawKey().hash();
    if (!paymentKey)
      throw new Error("signData: Address does not have a payment key");
    const signingKeyMap = {};
    if (signingKeyHash)
      signingKeyMap[signingKeyHash.hex().toString()] = this.signingKey;
    if (stakeSigningKeyHash)
      signingKeyMap[stakeSigningKeyHash.hex().toString()] = this.stakeSigningKey;
    const signingKey = signingKeyMap[paymentKey.hash.toString()];
    if (!signingKey)
      throw new Error("signData: Address does not have a signing key");
    return signData(address.toBytes(), payload, signingKey.toRawKey());
  }
  /**
   * Submits a transaction through the wallet.
   * @param {string} tx - The transaction to submit.
   * @returns {Promise<TransactionId>} - The ID of the submitted transaction.
   */
  async postTransaction(tx) {
    return this.provider.postTransactionToChain(tx);
  }
  /**
   * Retrieves the collateral UTxO(s) for the wallet.
   * @returns {Promise<TransactionUnspentOutput[]>} - The collateral for the wallet.
   */
  async getCollateral() {
    return [];
  }
};
_HotWallet.harden = (num) => 2147483648 + num;
var HotWallet = _HotWallet;

// src/hotsingle.ts
import {
  Ed25519PublicKey,
  Ed25519PrivateKey,
  HexBlob as HexBlob4,
  blake2b_224,
  CredentialType as CredentialType2,
  signMessage,
  Address as Address3,
  AddressType as AddressType2,
  TransactionWitnessSet as TransactionWitnessSet3,
  VkeyWitness as VkeyWitness2,
  CborSet as CborSet2,
  Ed25519SignatureHex,
  derivePublicKey
} from "@blaze-cardano/core";
import * as value2 from "@blaze-cardano/tx/value";
var HotSingleWallet = class {
  /**
   * Constructs a new instance of the HotSingleWallet class.
   * @param {Ed25519PrivateNormalKeyHex} signingKey - The private signing key of the wallet.
   * @param {NetworkId} networkId - The network ID for the wallet.
   * @param {Provider} provider - The provider for the wallet.
   * @param {Ed25519PrivateNormalKeyHex} stakeSigningKey - An optional private signing key for the delegation part of the wallet. If not provided, the wallet will have an enterprise address.
   */
  constructor(paymentSigningKey, networkId, provider, stakeSigningKey) {
    this.stakeSigningKey = void 0;
    this.stakePublicKey = void 0;
    this.networkId = networkId;
    this.paymentSigningKey = paymentSigningKey;
    this.paymentPublicKey = Ed25519PublicKey.fromHex(
      derivePublicKey(this.paymentSigningKey)
    );
    if (stakeSigningKey) {
      this.stakeSigningKey = stakeSigningKey;
      this.stakePublicKey = Ed25519PublicKey.fromHex(
        derivePublicKey(this.stakeSigningKey)
      );
    }
    this.address = new Address3({
      type: this.stakePublicKey ? AddressType2.BasePaymentKeyStakeKey : AddressType2.EnterpriseKey,
      networkId: this.networkId,
      paymentPart: {
        type: CredentialType2.KeyHash,
        hash: blake2b_224(HexBlob4(this.paymentPublicKey.hex()))
      },
      delegationPart: this.stakePublicKey ? {
        type: CredentialType2.KeyHash,
        hash: blake2b_224(HexBlob4(this.stakePublicKey.hex()))
      } : void 0
    });
    this.provider = provider;
  }
  /**
   * Retrieves the network ID of the currently connected account.
   * @returns {Promise<NetworkId>} - The network ID of the currently connected account.
   */
  async getNetworkId() {
    return this.networkId;
  }
  /**
   * Retrieves the UTxO(s) controlled by the wallet.
   * @returns {Promise<TransactionUnspentOutput[]>} - The UTXO(s) controlled by the wallet.
   */
  async getUnspentOutputs() {
    return this.provider.getUnspentOutputs(this.address);
  }
  /**
   * Retrieves the total available balance of the wallet, encoded in CBOR.
   * @returns {Promise<Value>} - The balance of the wallet.
   */
  async getBalance() {
    return (await this.getUnspentOutputs()).reduce(
      (x, y) => value2.merge(x, y.output().amount()),
      value2.zero()
    );
  }
  /**
   * Retrieves all used addresses controlled by the wallet.
   * @returns {Promise<Address[]>} - The used addresses controlled by the wallet.
   */
  async getUsedAddresses() {
    return [this.address];
  }
  /**
   * Retrieves all unused addresses controlled by the wallet.
   * @returns {Promise<Address[]>} - The unused addresses controlled by the wallet.
   */
  async getUnusedAddresses() {
    return [];
  }
  /**
   * Retrieves an address owned by the wallet which should be used to return transaction change.
   * @returns {Promise<Address>} - The change address.
   */
  async getChangeAddress() {
    return this.address;
  }
  /**
   * Retrieves the reward addresses controlled by the wallet.
   * @returns {Promise<RewardAddress[]>} - The reward addresses controlled by the wallet.
   */
  async getRewardAddresses() {
    if (this.stakePublicKey) {
      const rewardAddress = new Address3({
        type: AddressType2.RewardKey,
        networkId: this.networkId,
        paymentPart: this.address.getProps().delegationPart
      }).asReward();
      return rewardAddress ? [rewardAddress] : [];
    }
    return [];
  }
  /**
   * Requests a transaction signature from the wallet.
   * @param {string} tx - The transaction to sign.
   * @param {boolean} partialSign - Whether to partially sign the transaction.
   * @returns {Promise<TransactionWitnessSet>} - The signed transaction.
   */
  async signTransaction(tx, partialSign = true) {
    if (partialSign == false) {
      throw new Error(
        "signTx: Hot single wallet only supports partial signing = true"
      );
    }
    const signature = signMessage(HexBlob4(tx.getId()), this.paymentSigningKey);
    const tws = new TransactionWitnessSet3();
    const vkw = new VkeyWitness2(
      this.paymentPublicKey.hex(),
      Ed25519SignatureHex(signature)
    );
    tws.setVkeys(CborSet2.fromCore([vkw.toCore()], VkeyWitness2.fromCore));
    return tws;
  }
  /**
   * Requests signed data from the wallet.
   * Not supported, will always throw an error.
   * @param {Address} address - The address to sign the data with.
   * @param {string} payload - The data to sign.
   * @returns {Promise<CIP30DataSignature>} - The signed data.
   */
  async signData(address, payload) {
    const paymentKey = address.getProps().paymentPart;
    const paymentSigningKey = Ed25519PrivateKey.fromNormalHex(
      this.paymentSigningKey
    );
    const stakeSigningKey = this.stakeSigningKey && Ed25519PrivateKey.fromNormalHex(this.stakeSigningKey);
    const signingPublic = await paymentSigningKey.toPublic();
    const stakeSigningPublic = await stakeSigningKey?.toPublic();
    const signingKeyHash = await signingPublic.hash();
    const stakeSigningKeyHash = await stakeSigningPublic?.hash();
    if (!paymentKey)
      throw new Error("signData: Address does not have a payment key");
    const signingKeyMap = {};
    if (signingKeyHash)
      signingKeyMap[signingKeyHash.hex().toString()] = paymentSigningKey;
    if (stakeSigningKeyHash)
      signingKeyMap[stakeSigningKeyHash.hex().toString()] = stakeSigningKey;
    const signingKey = signingKeyMap[paymentKey.hash.toString()];
    if (!signingKey)
      throw new Error("signData: Address does not have a signing key");
    return signData(address.toBytes(), payload, signingKey);
  }
  /**
   * Submits a transaction through the wallet.
   * @param {string} tx - The transaction to submit.
   * @returns {Promise<TransactionId>} - The ID of the submitted transaction.
   */
  async postTransaction(tx) {
    return this.provider.postTransactionToChain(tx);
  }
  /**
   * Retrieves the collateral UTxO(s) for the wallet.
   * @returns {Promise<TransactionUnspentOutput[]>} - The collateral for the wallet.
   */
  async getCollateral() {
    return [];
  }
};

// src/cold.ts
import * as value3 from "@blaze-cardano/tx/value";
var ColdWallet = class {
  /**
   * Constructs a new instance of the ColdWallet class.
   * @param {Address} address - The address of the wallet.
   * @param {NetworkId} networkId - The network ID of the wallet.
   * @param {Provider} provider - The provider of the wallet.
   */
  constructor(address, networkId, provider) {
    this.networkId = networkId;
    this.address = address;
    this.provider = provider;
  }
  /**
   * Retrieves the network ID of the currently connected account.
   * @returns {Promise<NetworkId>} - The network ID of the currently connected account.
   */
  async getNetworkId() {
    return this.networkId;
  }
  /**
   * Retrieves the UTxO(s) controlled by the wallet.
   * @returns {Promise<TransactionUnspentOutput[]>} - The UTXO(s) controlled by the wallet.
   */
  async getUnspentOutputs() {
    return this.provider.getUnspentOutputs(this.address);
  }
  /**
   * Retrieves the total available balance of the wallet, encoded in CBOR.
   * @returns {Promise<Value>} - The balance of the wallet.
   */
  async getBalance() {
    let balance = value3.zero();
    const utxos = await this.getUnspentOutputs();
    for (const utxo of utxos) {
      balance = value3.merge(balance, utxo.output().amount());
    }
    return balance;
  }
  /**
   * Retrieves all used addresses controlled by the wallet.
   * @returns {Promise<Address[]>} - The used addresses controlled by the wallet.
   */
  async getUsedAddresses() {
    return Promise.resolve([this.address]);
  }
  /**
   * Retrieves all unused addresses controlled by the wallet.
   * @returns {Promise<Address[]>} - The unused addresses controlled by the wallet.
   */
  async getUnusedAddresses() {
    return [];
  }
  /**
   * Retrieves an address owned by the wallet which should be used to return transaction change.
   * @returns {Promise<Address>} - The change address.
   */
  async getChangeAddress() {
    return this.address;
  }
  /**
   * Retrieves the reward addresses controlled by the wallet.
   * @returns {Promise<RewardAddress[]>} - The reward addresses controlled by the wallet.
   */
  async getRewardAddresses() {
    return [];
  }
  /**
   * Requests a transaction signature from the wallet.
   * @param {string} tx - The transaction to sign.
   * @param {boolean} partialSign - Whether to partially sign the transaction.
   * @returns {Promise<TransactionWitnessSet>} - The signed transaction.
   */
  async signTransaction(_tx, _partialSign = true) {
    throw new Error(
      "ColdWallet signTransaction: Cold wallet cannot sign a transaction!"
    );
  }
  /**
   * Requests signed data from the wallet.
   * @param {Address} address - The address to sign the data with.
   * @param {string} payload - The data to sign.
   * @returns {Promise<CIP30DataSignature>} - The signed data.
   */
  async signData(_address, _payload) {
    throw new Error("ColdWallet signData: Cold wallet cannot sign data!");
  }
  /**
   * Submits a transaction through the wallet.
   * @param {string} tx - The transaction to submit.
   * @returns {Promise<TransactionId>} - The ID of the submitted transaction.
   */
  async postTransaction(tx) {
    return this.provider.postTransactionToChain(tx);
  }
  /**
   * Retrieves the collateral UTxO(s) for the wallet.
   * @returns {Promise<TransactionUnspentOutput[]>} - The collateral for the wallet.
   */
  async getCollateral() {
    return [];
  }
};
export {
  ColdWallet,
  HotSingleWallet,
  HotWallet,
  Wallet,
  WalletDetails,
  WebWallet
};
