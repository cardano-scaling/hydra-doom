"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ColdWallet: () => ColdWallet,
  HotSingleWallet: () => HotSingleWallet,
  HotWallet: () => HotWallet,
  Wallet: () => Wallet,
  WalletDetails: () => WalletDetails,
  WebWallet: () => WebWallet
});
module.exports = __toCommonJS(src_exports);

// src/types.ts
var Wallet = class {
};

// src/wallets.ts
var WalletDetails = [
  {
    namespace: "nami",
    name: "Nami Wallet",
    websiteUrl: "https://www.namiwallet.io/"
  }
];

// src/web.ts
var import_core = require("@blaze-cardano/core");
var WebWallet = class {
  /**
   * Constructs a new instance of the WebWallet class.
   * @param {CIP30Interface} webWallet - The CIP30Interface to be used.
   */
  constructor(webWallet) {
    this.webWallet = webWallet;
  }
  /**
   * Retrieves the network ID of the currently connected account.
   * @returns {Promise<NetworkId>} - The network ID of the currently connected account.
   */
  async getNetworkId() {
    const id = await this.webWallet.getNetworkId();
    switch (id) {
      case 0:
        return 0;
      case 1:
        return 1;
      default:
        throw new Error("Could not resolve CIP30 network id.");
    }
  }
  /**
   * Retrieves the UTxO(s) controlled by the wallet.
   * @returns {Promise<TransactionUnspentOutput[]>} - The UTXO(s) controlled by the wallet.
   */
  async getUnspentOutputs() {
    const utxos = await this.webWallet.getUtxos();
    return (utxos ?? []).map(
      (utxo) => import_core.TransactionUnspentOutput.fromCbor((0, import_core.HexBlob)(utxo))
    );
  }
  /**
   * Retrieves the total available balance of the wallet, encoded in CBOR.
   * @returns {Promise<Value>} - The balance of the wallet.
   */
  async getBalance() {
    const balance = await this.webWallet.getBalance();
    return import_core.Value.fromCbor((0, import_core.HexBlob)(balance));
  }
  /**
   * Retrieves all used addresses controlled by the wallet.
   * @returns {Promise<Address[]>} - The used addresses controlled by the wallet.
   */
  async getUsedAddresses() {
    const addresses = await this.webWallet.getUsedAddresses();
    return addresses.map((addy) => {
      const parsedAddy = import_core.Address.fromString(addy);
      if (!parsedAddy) {
        throw new Error(
          "getUsedAddresses: Wallet API returned an invalid used address."
        );
      }
      return parsedAddy;
    });
  }
  /**
   * Retrieves all unused addresses controlled by the wallet.
   * @returns {Promise<Address[]>} - The unused addresses controlled by the wallet.
   */
  async getUnusedAddresses() {
    const addresses = await this.webWallet.getUnusedAddresses();
    return addresses.map((addy) => {
      const parsedAddy = import_core.Address.fromString(addy);
      if (!parsedAddy) {
        throw new Error(
          "getUnusedAddresses: Wallet API returned an invalid unused address."
        );
      }
      return parsedAddy;
    });
  }
  /**
   * Retrieves an address owned by the wallet which should be used to return transaction change.
   * @returns {Promise<Address>} - The change address.
   */
  async getChangeAddress() {
    const addy = await this.webWallet.getChangeAddress();
    const parsedAddy = import_core.Address.fromString(addy);
    if (!parsedAddy) {
      throw new Error(
        "getChangeAddress: Wallet API returned an invalid change address."
      );
    }
    return parsedAddy;
  }
  /**
   * Retrieves the reward addresses controlled by the wallet.
   * @returns {Promise<RewardAddress[]>} - The reward addresses controlled by the wallet.
   */
  async getRewardAddresses() {
    const addresses = await this.webWallet.getRewardAddresses();
    return addresses.map((addy) => {
      const parsedAddy = import_core.Address.fromString(addy);
      if (!parsedAddy) {
        throw new Error(
          "getRewardAddresses: Wallet API returned an invalid address."
        );
      }
      const parsedRewardAddy = import_core.RewardAddress.fromAddress(parsedAddy);
      if (!parsedRewardAddy) {
        throw new Error(
          "getRewardAddresses: Wallet API returned an invalid reward address."
        );
      }
      return parsedRewardAddy;
    });
  }
  /**
   * Requests a transaction signature from the wallet.
   * @param {string} tx - The transaction to sign.
   * @param {boolean} partialSign - Whether to partially sign the transaction.
   * @returns {Promise<TransactionWitnessSet>} - The signed transaction.
   */
  async signTransaction(tx, partialSign) {
    const witnessSet = await this.webWallet.signTx(tx.toCbor(), partialSign);
    return import_core.TransactionWitnessSet.fromCbor((0, import_core.HexBlob)(witnessSet));
  }
  /**
   * Requests signed data from the wallet.
   * @param {Address} address - The address to sign the data with.
   * @param {string} payload - The data to sign.
   * @returns {Promise<CIP30DataSignature>} - The signed data.
   */
  async signData(address, payload) {
    const { signature, key } = await this.webWallet.signData(
      address.toBech32(),
      payload
    );
    return {
      key: (0, import_core.HexBlob)(key),
      signature: (0, import_core.HexBlob)(signature)
    };
  }
  /**
   * Submits a transaction through the wallet.
   * @param {Transaction} tx - The transaction to submit.
   * @returns {Promise<TransactionId>} - The ID of the submitted transaction.
   */
  async postTransaction(tx) {
    const transactionId = await this.webWallet.submitTx(tx.toCbor());
    return import_core.TransactionId.fromHexBlob((0, import_core.HexBlob)(transactionId));
  }
  /**
   * Retrieves the collateral UTxO(s) for the wallet.
   * @returns {Promise<TransactionUnspentOutput[]>} - The collateral for the wallet.
   */
  async getCollateral() {
    const utxos = await this.webWallet.getCollateral();
    return (utxos ?? []).map(
      (utxo) => import_core.TransactionUnspentOutput.fromCbor((0, import_core.HexBlob)(utxo))
    );
  }
};

// src/hot.ts
var import_core3 = require("@blaze-cardano/core");
var value = __toESM(require("@blaze-cardano/tx/value"));

// src/utils.ts
var import_core2 = require("@blaze-cardano/core");
async function signData(addressHex, payload, privateKey) {
  const {
    Label,
    CBORValue,
    COSESign1Builder,
    Headers,
    HeaderMap,
    ProtectedHeaderMap,
    Int,
    BigNum,
    AlgorithmId,
    COSEKey,
    KeyType
  } = await // @ts-expect-error - TS doesn't recognize window object
  (typeof window === "undefined" ? import("@emurgo/cardano-message-signing-nodejs") : import("@emurgo/cardano-message-signing-browser"));
  const protectedHeaders = HeaderMap.new();
  protectedHeaders.set_algorithm_id(Label.from_algorithm_id(AlgorithmId.EdDSA));
  protectedHeaders.set_header(
    Label.new_text("address"),
    CBORValue.new_bytes((0, import_core2.fromHex)(addressHex))
  );
  const protectedSerialized = ProtectedHeaderMap.new(protectedHeaders);
  const unprotectedHeaders = HeaderMap.new();
  const headers = Headers.new(protectedSerialized, unprotectedHeaders);
  const builder = COSESign1Builder.new(headers, (0, import_core2.fromHex)(payload), false);
  const toSign = builder.make_data_to_sign().to_bytes();
  8;
  const publicKey = await privateKey.toPublic();
  const signedSigStruc = await privateKey.sign((0, import_core2.HexBlob)((0, import_core2.toHex)(toSign)));
  const coseSign1 = builder.build(signedSigStruc.bytes());
  const key = COSEKey.new(
    Label.from_key_type(KeyType.OKP)
    //OKP
  );
  key.set_algorithm_id(Label.from_algorithm_id(AlgorithmId.EdDSA));
  key.set_header(
    Label.new_int(Int.new_negative(BigNum.from_str("1"))),
    CBORValue.new_int(
      Int.new_i32(6)
      //CurveType.Ed25519
    )
  );
  key.set_header(
    Label.new_int(Int.new_negative(BigNum.from_str("2"))),
    CBORValue.new_bytes(publicKey.bytes())
  );
  return {
    signature: (0, import_core2.HexBlob)((0, import_core2.toHex)(coseSign1.to_bytes())),
    key: (0, import_core2.HexBlob)((0, import_core2.toHex)(key.to_bytes()))
  };
}

// src/hot.ts
var _HotWallet = class _HotWallet {
  /**
   * Constructs a new instance of the HotWallet class.
   * @param {Address} address - the wallets's address
   * @param {RewardAddress} rewardAddress - the wallet's reward address if there is any
   * @param {Bip32PrivateKey} signingKey - The signing key of the derived account's of wallet.
   * @param {Bip32PublicKey} publicKey - The public key of the derived account's of the wallet.
   * @param {Provider} provider - The provider of the wallet.
   */
  constructor(address, rewardAddress, signingKey, publicKey, provider, stakePaymentKey) {
    this.address = address;
    this.rewardAddress = rewardAddress;
    this.networkId = this.address.getNetworkId();
    this.signingKey = signingKey;
    this.publicKey = publicKey;
    this.provider = provider;
    this.stakeSigningKey = stakePaymentKey;
  }
  static async generateAccountAddressFromMasterkey(masterkey, networkId = import_core3.NetworkId.Testnet, addressType = import_core3.AddressType.BasePaymentKeyStakeKey) {
    if (addressType !== import_core3.AddressType.BasePaymentKeyStakeKey && addressType !== import_core3.AddressType.EnterpriseKey) {
      throw new Error(
        "Hot wallets only support the BasePaymentKeyStakeKey and EnterpriseKey adresses!"
      );
    }
    const accountKey = await masterkey.derive([
      this.harden(1852),
      this.harden(1815),
      this.harden(0)
    ]);
    const paymentKey = await accountKey.derive([0, 0]);
    const stakePaymentKey = await accountKey.derive([2, 0]);
    const address = new import_core3.Address({
      type: addressType,
      networkId,
      paymentPart: {
        type: import_core3.CredentialType.KeyHash,
        hash: import_core3.Hash28ByteBase16.fromEd25519KeyHashHex(
          (await (await paymentKey.toPublic()).toRawKey().hash()).hex()
        )
      },
      delegationPart: addressType === import_core3.AddressType.EnterpriseKey ? void 0 : {
        type: import_core3.CredentialType.KeyHash,
        // 1852H/1815H/0H/2/0
        hash: import_core3.Hash28ByteBase16.fromEd25519KeyHashHex(
          (await (await (await accountKey.derive([2, 0])).toPublic()).toRawKey().hash()).hex()
        )
      }
    });
    return {
      address,
      paymentKey,
      stakePaymentKey,
      publicKey: await paymentKey.toPublic()
    };
  }
  static async fromMasterkey(masterkey, provider, networkId = import_core3.NetworkId.Testnet, addressType = import_core3.AddressType.BasePaymentKeyStakeKey) {
    const rootKey = import_core3.Bip32PrivateKey.fromHex(masterkey);
    const { address, paymentKey, stakePaymentKey, publicKey } = await this.generateAccountAddressFromMasterkey(
      rootKey,
      networkId,
      addressType
    );
    return new _HotWallet(
      address,
      address.asReward(),
      paymentKey,
      publicKey,
      provider,
      stakePaymentKey
    );
  }
  /**
   * Retrieves the network ID of the currently connected account.
   * @returns {Promise<NetworkId>} - The network ID of the currently connected account.
   */
  async getNetworkId() {
    return this.networkId;
  }
  /**
   * Retrieves the UTxO(s) controlled by the wallet.
   * @returns {Promise<TransactionUnspentOutput[]>} - The UTXO(s) controlled by the wallet.
   */
  async getUnspentOutputs() {
    return this.provider.getUnspentOutputs(this.address);
  }
  /**
   * Retrieves the total available balance of the wallet, encoded in CBOR.
   * @returns {Promise<Value>} - The balance of the wallet.
   */
  async getBalance() {
    let balance = value.zero();
    const utxos = await this.getUnspentOutputs();
    for (const utxo of utxos) {
      balance = value.merge(balance, utxo.output().amount());
    }
    return balance;
  }
  /**
   * Retrieves all used addresses controlled by the wallet.
   * @returns {Promise<Address[]>} - The used addresses controlled by the wallet.
   */
  async getUsedAddresses() {
    return [this.address];
  }
  /**
   * Retrieves all unused addresses controlled by the wallet.
   * @returns {Promise<Address[]>} - The unused addresses controlled by the wallet.
   */
  async getUnusedAddresses() {
    return [];
  }
  /**
   * Retrieves an address owned by the wallet which should be used to return transaction change.
   * @returns {Promise<Address>} - The change address.
   */
  async getChangeAddress() {
    return this.address;
  }
  /**
   * Retrieves the reward addresses controlled by the wallet.
   * @returns {Promise<RewardAddress[]>} - The reward addresses controlled by the wallet.
   */
  async getRewardAddresses() {
    return this.rewardAddress ? [this.rewardAddress] : [];
  }
  /**
   * Requests a transaction signature from the wallet.
   * @param {string} tx - The transaction to sign.
   * @param {boolean} partialSign - Whether to partially sign the transaction.
   * @returns {Promise<TransactionWitnessSet>} - The signed transaction.
   */
  async signTransaction(tx, partialSign = true) {
    if (partialSign == false) {
      throw new Error(
        "signTx: Hot wallet only supports partial signing = true"
      );
    }
    const signature = await this.signingKey.toRawKey().sign((0, import_core3.HexBlob)(tx.getId()));
    const tws = new import_core3.TransactionWitnessSet();
    const vkw = new import_core3.VkeyWitness(
      this.publicKey.toRawKey().hex(),
      signature.hex()
    );
    tws.setVkeys(import_core3.CborSet.fromCore([vkw.toCore()], import_core3.VkeyWitness.fromCore));
    return tws;
  }
  /**
   * Requests signed data from the wallet.
   * @param {Address} address - The address to sign the data with.
   * @param {string} payload - The data to sign.
   * @returns {Promise<CIP30DataSignature>} - The signed data.
   */
  async signData(address, payload) {
    const paymentKey = address.getProps().paymentPart;
    const signingPublic = await this.signingKey.toPublic();
    const stakeSigningPublic = await this.stakeSigningKey?.toPublic();
    const signingKeyHash = await signingPublic.toRawKey().hash();
    const stakeSigningKeyHash = await stakeSigningPublic?.toRawKey().hash();
    if (!paymentKey)
      throw new Error("signData: Address does not have a payment key");
    const signingKeyMap = {};
    if (signingKeyHash)
      signingKeyMap[signingKeyHash.hex().toString()] = this.signingKey;
    if (stakeSigningKeyHash)
      signingKeyMap[stakeSigningKeyHash.hex().toString()] = this.stakeSigningKey;
    const signingKey = signingKeyMap[paymentKey.hash.toString()];
    if (!signingKey)
      throw new Error("signData: Address does not have a signing key");
    return signData(address.toBytes(), payload, signingKey.toRawKey());
  }
  /**
   * Submits a transaction through the wallet.
   * @param {string} tx - The transaction to submit.
   * @returns {Promise<TransactionId>} - The ID of the submitted transaction.
   */
  async postTransaction(tx) {
    return this.provider.postTransactionToChain(tx);
  }
  /**
   * Retrieves the collateral UTxO(s) for the wallet.
   * @returns {Promise<TransactionUnspentOutput[]>} - The collateral for the wallet.
   */
  async getCollateral() {
    return [];
  }
};
_HotWallet.harden = (num) => 2147483648 + num;
var HotWallet = _HotWallet;

// src/hotsingle.ts
var import_core4 = require("@blaze-cardano/core");
var value2 = __toESM(require("@blaze-cardano/tx/value"));
var HotSingleWallet = class {
  /**
   * Constructs a new instance of the HotSingleWallet class.
   * @param {Ed25519PrivateNormalKeyHex} signingKey - The private signing key of the wallet.
   * @param {NetworkId} networkId - The network ID for the wallet.
   * @param {Provider} provider - The provider for the wallet.
   * @param {Ed25519PrivateNormalKeyHex} stakeSigningKey - An optional private signing key for the delegation part of the wallet. If not provided, the wallet will have an enterprise address.
   */
  constructor(paymentSigningKey, networkId, provider, stakeSigningKey) {
    this.stakeSigningKey = void 0;
    this.stakePublicKey = void 0;
    this.networkId = networkId;
    this.paymentSigningKey = paymentSigningKey;
    this.paymentPublicKey = import_core4.Ed25519PublicKey.fromHex(
      (0, import_core4.derivePublicKey)(this.paymentSigningKey)
    );
    if (stakeSigningKey) {
      this.stakeSigningKey = stakeSigningKey;
      this.stakePublicKey = import_core4.Ed25519PublicKey.fromHex(
        (0, import_core4.derivePublicKey)(this.stakeSigningKey)
      );
    }
    this.address = new import_core4.Address({
      type: this.stakePublicKey ? import_core4.AddressType.BasePaymentKeyStakeKey : import_core4.AddressType.EnterpriseKey,
      networkId: this.networkId,
      paymentPart: {
        type: import_core4.CredentialType.KeyHash,
        hash: (0, import_core4.blake2b_224)((0, import_core4.HexBlob)(this.paymentPublicKey.hex()))
      },
      delegationPart: this.stakePublicKey ? {
        type: import_core4.CredentialType.KeyHash,
        hash: (0, import_core4.blake2b_224)((0, import_core4.HexBlob)(this.stakePublicKey.hex()))
      } : void 0
    });
    this.provider = provider;
  }
  /**
   * Retrieves the network ID of the currently connected account.
   * @returns {Promise<NetworkId>} - The network ID of the currently connected account.
   */
  async getNetworkId() {
    return this.networkId;
  }
  /**
   * Retrieves the UTxO(s) controlled by the wallet.
   * @returns {Promise<TransactionUnspentOutput[]>} - The UTXO(s) controlled by the wallet.
   */
  async getUnspentOutputs() {
    return this.provider.getUnspentOutputs(this.address);
  }
  /**
   * Retrieves the total available balance of the wallet, encoded in CBOR.
   * @returns {Promise<Value>} - The balance of the wallet.
   */
  async getBalance() {
    return (await this.getUnspentOutputs()).reduce(
      (x, y) => value2.merge(x, y.output().amount()),
      value2.zero()
    );
  }
  /**
   * Retrieves all used addresses controlled by the wallet.
   * @returns {Promise<Address[]>} - The used addresses controlled by the wallet.
   */
  async getUsedAddresses() {
    return [this.address];
  }
  /**
   * Retrieves all unused addresses controlled by the wallet.
   * @returns {Promise<Address[]>} - The unused addresses controlled by the wallet.
   */
  async getUnusedAddresses() {
    return [];
  }
  /**
   * Retrieves an address owned by the wallet which should be used to return transaction change.
   * @returns {Promise<Address>} - The change address.
   */
  async getChangeAddress() {
    return this.address;
  }
  /**
   * Retrieves the reward addresses controlled by the wallet.
   * @returns {Promise<RewardAddress[]>} - The reward addresses controlled by the wallet.
   */
  async getRewardAddresses() {
    if (this.stakePublicKey) {
      const rewardAddress = new import_core4.Address({
        type: import_core4.AddressType.RewardKey,
        networkId: this.networkId,
        paymentPart: this.address.getProps().delegationPart
      }).asReward();
      return rewardAddress ? [rewardAddress] : [];
    }
    return [];
  }
  /**
   * Requests a transaction signature from the wallet.
   * @param {string} tx - The transaction to sign.
   * @param {boolean} partialSign - Whether to partially sign the transaction.
   * @returns {Promise<TransactionWitnessSet>} - The signed transaction.
   */
  async signTransaction(tx, partialSign = true) {
    if (partialSign == false) {
      throw new Error(
        "signTx: Hot single wallet only supports partial signing = true"
      );
    }
    const signature = (0, import_core4.signMessage)((0, import_core4.HexBlob)(tx.getId()), this.paymentSigningKey);
    const tws = new import_core4.TransactionWitnessSet();
    const vkw = new import_core4.VkeyWitness(
      this.paymentPublicKey.hex(),
      (0, import_core4.Ed25519SignatureHex)(signature)
    );
    tws.setVkeys(import_core4.CborSet.fromCore([vkw.toCore()], import_core4.VkeyWitness.fromCore));
    return tws;
  }
  /**
   * Requests signed data from the wallet.
   * Not supported, will always throw an error.
   * @param {Address} address - The address to sign the data with.
   * @param {string} payload - The data to sign.
   * @returns {Promise<CIP30DataSignature>} - The signed data.
   */
  async signData(address, payload) {
    const paymentKey = address.getProps().paymentPart;
    const paymentSigningKey = import_core4.Ed25519PrivateKey.fromNormalHex(
      this.paymentSigningKey
    );
    const stakeSigningKey = this.stakeSigningKey && import_core4.Ed25519PrivateKey.fromNormalHex(this.stakeSigningKey);
    const signingPublic = await paymentSigningKey.toPublic();
    const stakeSigningPublic = await stakeSigningKey?.toPublic();
    const signingKeyHash = await signingPublic.hash();
    const stakeSigningKeyHash = await stakeSigningPublic?.hash();
    if (!paymentKey)
      throw new Error("signData: Address does not have a payment key");
    const signingKeyMap = {};
    if (signingKeyHash)
      signingKeyMap[signingKeyHash.hex().toString()] = paymentSigningKey;
    if (stakeSigningKeyHash)
      signingKeyMap[stakeSigningKeyHash.hex().toString()] = stakeSigningKey;
    const signingKey = signingKeyMap[paymentKey.hash.toString()];
    if (!signingKey)
      throw new Error("signData: Address does not have a signing key");
    return signData(address.toBytes(), payload, signingKey);
  }
  /**
   * Submits a transaction through the wallet.
   * @param {string} tx - The transaction to submit.
   * @returns {Promise<TransactionId>} - The ID of the submitted transaction.
   */
  async postTransaction(tx) {
    return this.provider.postTransactionToChain(tx);
  }
  /**
   * Retrieves the collateral UTxO(s) for the wallet.
   * @returns {Promise<TransactionUnspentOutput[]>} - The collateral for the wallet.
   */
  async getCollateral() {
    return [];
  }
};

// src/cold.ts
var value3 = __toESM(require("@blaze-cardano/tx/value"));
var ColdWallet = class {
  /**
   * Constructs a new instance of the ColdWallet class.
   * @param {Address} address - The address of the wallet.
   * @param {NetworkId} networkId - The network ID of the wallet.
   * @param {Provider} provider - The provider of the wallet.
   */
  constructor(address, networkId, provider) {
    this.networkId = networkId;
    this.address = address;
    this.provider = provider;
  }
  /**
   * Retrieves the network ID of the currently connected account.
   * @returns {Promise<NetworkId>} - The network ID of the currently connected account.
   */
  async getNetworkId() {
    return this.networkId;
  }
  /**
   * Retrieves the UTxO(s) controlled by the wallet.
   * @returns {Promise<TransactionUnspentOutput[]>} - The UTXO(s) controlled by the wallet.
   */
  async getUnspentOutputs() {
    return this.provider.getUnspentOutputs(this.address);
  }
  /**
   * Retrieves the total available balance of the wallet, encoded in CBOR.
   * @returns {Promise<Value>} - The balance of the wallet.
   */
  async getBalance() {
    let balance = value3.zero();
    const utxos = await this.getUnspentOutputs();
    for (const utxo of utxos) {
      balance = value3.merge(balance, utxo.output().amount());
    }
    return balance;
  }
  /**
   * Retrieves all used addresses controlled by the wallet.
   * @returns {Promise<Address[]>} - The used addresses controlled by the wallet.
   */
  async getUsedAddresses() {
    return Promise.resolve([this.address]);
  }
  /**
   * Retrieves all unused addresses controlled by the wallet.
   * @returns {Promise<Address[]>} - The unused addresses controlled by the wallet.
   */
  async getUnusedAddresses() {
    return [];
  }
  /**
   * Retrieves an address owned by the wallet which should be used to return transaction change.
   * @returns {Promise<Address>} - The change address.
   */
  async getChangeAddress() {
    return this.address;
  }
  /**
   * Retrieves the reward addresses controlled by the wallet.
   * @returns {Promise<RewardAddress[]>} - The reward addresses controlled by the wallet.
   */
  async getRewardAddresses() {
    return [];
  }
  /**
   * Requests a transaction signature from the wallet.
   * @param {string} tx - The transaction to sign.
   * @param {boolean} partialSign - Whether to partially sign the transaction.
   * @returns {Promise<TransactionWitnessSet>} - The signed transaction.
   */
  async signTransaction(_tx, _partialSign = true) {
    throw new Error(
      "ColdWallet signTransaction: Cold wallet cannot sign a transaction!"
    );
  }
  /**
   * Requests signed data from the wallet.
   * @param {Address} address - The address to sign the data with.
   * @param {string} payload - The data to sign.
   * @returns {Promise<CIP30DataSignature>} - The signed data.
   */
  async signData(_address, _payload) {
    throw new Error("ColdWallet signData: Cold wallet cannot sign data!");
  }
  /**
   * Submits a transaction through the wallet.
   * @param {string} tx - The transaction to submit.
   * @returns {Promise<TransactionId>} - The ID of the submitted transaction.
   */
  async postTransaction(tx) {
    return this.provider.postTransactionToChain(tx);
  }
  /**
   * Retrieves the collateral UTxO(s) for the wallet.
   * @returns {Promise<TransactionUnspentOutput[]>} - The collateral for the wallet.
   */
  async getCollateral() {
    return [];
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ColdWallet,
  HotSingleWallet,
  HotWallet,
  Wallet,
  WalletDetails,
  WebWallet
});
