"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Ogmios: () => Ogmios2,
  Schema: () => schema_exports,
  Unwrapped: () => unwrapped_exports
});
module.exports = __toCommonJS(src_exports);

// src/schema.ts
var schema_exports = {};
__reExport(schema_exports, require("@cardano-ogmios/schema"));

// src/unwrapped.ts
var unwrapped_exports = {};
__export(unwrapped_exports, {
  Ogmios: () => Ogmios
});
var import_isomorphic_ws = __toESM(require("isomorphic-ws"));
var Ogmios = class _Ogmios {
  constructor(url) {
    this.requests = {};
    console.log("url", url);
    this.url = url;
    this.ws = new import_isomorphic_ws.default(this.url);
  }
  async setupEventListeners() {
    return new Promise((resolve, reject) => {
      this.ws.onopen = () => {
        resolve();
      };
      this.ws.onmessage = (event) => {
        const messageText = typeof event.data === "string" ? event.data : event.data.toString("utf-8");
        const parsedMessage = JSON.parse(messageText);
        if (parsedMessage.id && parsedMessage.id in this.requests) {
          const { resolve: resolve2, reject: reject2 } = this.requests[parsedMessage.id];
          if (parsedMessage.error) {
            reject2(new Error(JSON.stringify(parsedMessage.error)));
          } else {
            resolve2(parsedMessage.result);
          }
          delete this.requests[parsedMessage.id];
        }
      };
      this.ws.onerror = (error) => {
        console.error("WebSocket error:", error);
        reject(error);
      };
    });
  }
  static async new(url) {
    const instance = new _Ogmios(url);
    await instance.setupEventListeners();
    return instance;
  }
  static async fromDemeter(network, apiKey, region) {
    const url = `wss://${apiKey}.${network}-v6.${region}.demeter.run`;
    return _Ogmios.new(url);
  }
  static generateId() {
    return crypto.randomUUID();
  }
  async request(method, params) {
    if (this.ws.readyState !== import_isomorphic_ws.default.OPEN) {
      throw new Error("WebSocket connection not open");
    }
    const id = _Ogmios.generateId();
    return new Promise((resolve, reject) => {
      this.ws.send(
        JSON.stringify(
          { jsonrpc: "2.0", method, params, id },
          (_key, value) => {
            if (typeof value === "bigint") {
              return Number(value);
            }
            return value;
          }
        )
      );
      this.requests[id] = { resolve, reject };
    });
  }
  connect() {
    return this.ws;
  }
  kill() {
    return new Promise((resolve) => {
      if (this.ws) {
        this.ws.close();
        this.ws.onclose = (event) => {
          console.log("WebSocket connection closed:", event);
          this.requests = {};
        };
      } else {
        resolve();
      }
    });
  }
  async findIntersection(points) {
    return this.request("findIntersection", { points });
  }
  async nextBlock() {
    return this.request(
      "nextBlock",
      {}
    );
  }
  // Transaction Submission API
  async submitTransaction(transaction) {
    return this.request("submitTransaction", { transaction });
  }
  // Transaction Evaluation API
  async evaluateTransaction(transaction, additionalUtxos) {
    return this.request("evaluateTransaction", { transaction, additionalUtxo: additionalUtxos });
  }
  // State Query API
  async acquireLedgerState(point) {
    return this.request("acquireLedgerState", { point });
  }
  async releaseLedgerState() {
    return this.request(
      "releaseLedgerState",
      {}
    );
  }
  async queryLedgerStateConstitution() {
    return this.request("queryLedgerState/constitution", {});
  }
  async queryLedgerStateConstitutionalCommittee() {
    return this.request("queryLedgerState/constitutionalCommittee", {});
  }
  async queryLedgerStateEpoch() {
    return this.request(
      "queryLedgerState/epoch",
      {}
    );
  }
  async queryLedgerStateEraStart() {
    return this.request(
      "queryLedgerState/eraStart",
      {}
    );
  }
  async queryLedgerStateEraSummaries() {
    return this.request("queryLedgerState/eraSummaries", {});
  }
  async queryLedgerStateLiveStakeDistribution() {
    return this.request("queryLedgerState/liveStakeDistribution", {});
  }
  async queryLedgerStateProjectedRewards(params) {
    return this.request("queryLedgerState/projectedRewards", params);
  }
  async queryLedgerStateProposedProtocolParameters() {
    return this.request("queryLedgerState/proposedProtocolParameters", {});
  }
  async queryLedgerStateProtocolParameters() {
    return this.request("queryLedgerState/protocolParameters", {});
  }
  async queryLedgerStateRewardAccountSummaries(params) {
    return this.request("queryLedgerState/rewardAccountSummaries", params);
  }
  async queryLedgerStateRewardsProvenance() {
    return this.request("queryLedgerState/rewardsProvenance", {});
  }
  async queryLedgerStateStakePools(params) {
    return this.request("queryLedgerState/stakePools", params);
  }
  async queryLedgerStateTip() {
    return this.request(
      "queryLedgerState/tip",
      {}
    );
  }
  async queryLedgerStateTreasuryAndReserves() {
    return this.request("queryLedgerState/treasuryAndReserves", {});
  }
  async queryLedgerStateUtxo(params) {
    return this.request(
      "queryLedgerState/utxo",
      params
    );
  }
  // Network Query API
  async queryNetworkBlockHeight() {
    return this.request(
      "queryNetwork/blockHeight",
      {}
    );
  }
  async queryNetworkGenesisConfiguration(params) {
    return this.request("queryNetwork/genesisConfiguration", params);
  }
  async queryNetworkStartTime() {
    return this.request(
      "queryNetwork/startTime",
      {}
    );
  }
  async queryNetworkTip() {
    return this.request(
      "queryNetwork/tip",
      {}
    );
  }
  // Local State Query API
  async acquireMempool() {
    return this.request(
      "acquireMempool",
      {}
    );
  }
  async nextTransaction(params) {
    return this.request(
      "nextTransaction",
      params
    );
  }
  async hasTransaction(params) {
    return this.request("hasTransaction", params);
  }
  async sizeOfMempool() {
    return this.request("sizeOfMempool", {});
  }
  async releaseMempool() {
    return this.request(
      "releaseMempool",
      {}
    );
  }
};

// src/wrapped.ts
var Ogmios2 = class {
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Ogmios,
  Schema,
  Unwrapped
});
