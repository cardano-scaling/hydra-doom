import * as _cardano_sdk_util from '@cardano-sdk/util';
import { OpaqueString, HexBlob } from '@cardano-sdk/util';
export { HexBlob, OpaqueString, typedHex } from '@cardano-sdk/util';
import * as C from '@cardano-sdk/core';
import { Cardano } from '@cardano-sdk/core';
import * as Crypto from '@cardano-sdk/crypto';
import * as bip39 from '@scure/bip39';
export { wordlist } from '@scure/bip39/wordlists/english';

declare const Slot: (value: number) => C.Cardano.Slot;
type Slot = C.Cardano.Slot;
declare const Value: typeof C.Serialization.Value;
type Value = C.Serialization.Value;
type TokenMap = C.Cardano.TokenMap;
declare const Transaction: typeof C.Serialization.Transaction;
type Transaction = C.Serialization.Transaction;
declare const TxCBOR: {
    (tx: string): C.Serialization.TxCBOR;
    serialize(tx: C.Cardano.Tx): C.Serialization.TxCBOR;
    deserialize(tx: C.Serialization.TxCBOR): C.Cardano.Tx;
};
type TxCBOR = C.Serialization.TxCBOR;
declare const TransactionId: {
    (value: string): C.Cardano.TransactionId;
    fromHexBlob(value: _cardano_sdk_util.HexBlob): C.Cardano.TransactionId;
};
type TransactionId = C.Cardano.TransactionId;
declare const TransactionBody: typeof C.Serialization.TransactionBody;
type TransactionBody = C.Serialization.TransactionBody;
declare const TransactionWitnessSet: typeof C.Serialization.TransactionWitnessSet;
type TransactionWitnessSet = C.Serialization.TransactionWitnessSet;
declare const TransactionUnspentOutput: typeof C.Serialization.TransactionUnspentOutput;
type TransactionUnspentOutput = C.Serialization.TransactionUnspentOutput;
declare const TransactionInput: typeof C.Serialization.TransactionInput;
type TransactionInput = C.Serialization.TransactionInput;
declare const TransactionOutput: typeof C.Serialization.TransactionOutput;
type TransactionOutput = C.Serialization.TransactionOutput;
type TransactionInputSet = C.Serialization.CborSet<ReturnType<TransactionInput["toCore"]>, TransactionInput>;
type TransactionWitnessPlutusData = Set<PlutusData>;
declare const PlutusData: typeof C.Serialization.PlutusData;
type PlutusData = C.Serialization.PlutusData;
declare const ConstrPlutusData: typeof C.Serialization.ConstrPlutusData;
type ConstrPlutusData = C.Serialization.ConstrPlutusData;
declare const PlutusList: typeof C.Serialization.PlutusList;
type PlutusList = C.Serialization.PlutusList;
declare const PlutusMap: typeof C.Serialization.PlutusMap;
type PlutusMap = C.Serialization.PlutusMap;
declare const PlutusDataKind: typeof C.Serialization.PlutusDataKind;
type PlutusDataKind = C.Serialization.PlutusDataKind;
declare const Redeemers: typeof C.Serialization.Redeemers;
type Redeemers = C.Serialization.Redeemers;
declare const Redeemer: typeof C.Serialization.Redeemer;
type Redeemer = C.Serialization.Redeemer;
declare const RedeemerPurpose: typeof C.Cardano.RedeemerPurpose;
type RedeemerPurpose = C.Cardano.RedeemerPurpose;
declare const RedeemerTag: typeof C.Serialization.RedeemerTag;
type RedeemerTag = C.Serialization.RedeemerTag;
declare const Script: typeof C.Serialization.Script;
type Script = C.Serialization.Script;
declare const PolicyId: (value: string) => C.Cardano.PolicyId;
type PolicyId = C.Cardano.PolicyId;
declare const AssetName: {
    (value: string): C.Cardano.AssetName;
    toUTF8(assetName: C.Cardano.AssetName, stripInvisibleCharacters?: boolean): string;
};
type AssetName = C.Cardano.AssetName;
declare const AssetId: {
    (value: string): C.Cardano.AssetId;
    getPolicyId(id: C.Cardano.AssetId): C.Cardano.PolicyId;
    getAssetName(id: C.Cardano.AssetId): C.Cardano.AssetName;
    fromParts(policyId: C.Cardano.PolicyId, assetName: C.Cardano.AssetName): C.Cardano.AssetId;
};
type AssetId = C.Cardano.AssetId;
type ScriptHash = Crypto.Hash28ByteBase16;
declare const Address: typeof C.Cardano.Address;
type Address = C.Cardano.Address;
declare const RewardAddress: typeof C.Cardano.RewardAddress;
type RewardAddress = C.Cardano.RewardAddress;
declare const AddressType: typeof C.Cardano.AddressType;
type AddressType = C.Cardano.AddressType;
declare const PaymentAddress: (value: string) => C.Cardano.PaymentAddress;
type PaymentAddress = C.Cardano.PaymentAddress;
declare const Credential: typeof C.Serialization.Credential;
type Credential = C.Serialization.Credential;
type CredentialCore = C.Cardano.Credential;
declare const Ed25519PublicKeyHex: (value: string) => Crypto.Ed25519PublicKeyHex;
type Ed25519PublicKeyHex = Crypto.Ed25519PublicKeyHex;
declare const Ed25519PrivateKey: typeof Crypto.Ed25519PrivateKey;
type Ed25519PrivateKey = Crypto.Ed25519PrivateKey;
type Ed25519PrivateNormalKeyHex = OpaqueString<"Ed25519PrivateKeyHex">;
declare const Ed25519PrivateNormalKeyHex: (value: string) => Ed25519PrivateNormalKeyHex;
type Ed25519PrivateExtendedKeyHex = OpaqueString<"Ed25519PrivateKeyHex">;
declare const Ed25519PrivateExtendedKeyHex: (value: string) => Ed25519PrivateExtendedKeyHex;
type Bip32PrivateKeyHex = OpaqueString<"Bip32PrivateKeyHex">;
declare const Bip32PrivateKeyHex: (value: string) => Bip32PrivateKeyHex;
declare const Ed25519KeyHashHex: (value: string) => Crypto.Ed25519KeyHashHex;
type Ed25519KeyHashHex = Crypto.Ed25519KeyHashHex;
declare const Hash28ByteBase16: {
    (value: string): Crypto.Hash28ByteBase16;
    fromEd25519KeyHashHex(value: Crypto.Ed25519KeyHashHex): Crypto.Hash28ByteBase16;
};
type Hash28ByteBase16 = Crypto.Hash28ByteBase16;
declare const Hash32ByteBase16: {
    (value: string): Crypto.Hash32ByteBase16;
    fromHexBlob<T>(value: _cardano_sdk_util.HexBlob): T;
};
type Hash32ByteBase16 = Crypto.Hash32ByteBase16;
declare const CredentialType: typeof C.Cardano.CredentialType;
type CredentialType = C.Cardano.CredentialType;
declare const Certificate: typeof C.Serialization.Certificate;
type Certificate = C.Serialization.Certificate;
declare const PoolId: {
    (value: string): C.Cardano.PoolId;
    fromKeyHash(value: Crypto.Ed25519KeyHashHex): C.Cardano.PoolId;
    toKeyHash(poolId: C.Cardano.PoolId): Crypto.Ed25519KeyHashHex;
};
type PoolId = C.Cardano.PoolId;
declare const StakeRegistration: typeof C.Serialization.StakeRegistration;
type StakeRegistration = C.Serialization.StakeRegistration;
declare const StakeDelegation: typeof C.Serialization.StakeDelegation;
type StakeDelegation = C.Serialization.StakeDelegation;
type StakeDelegationCertificate = C.Cardano.StakeDelegationCertificate;
declare const CertificateType: typeof C.Cardano.CertificateType;
type CertificateType = C.Cardano.CertificateType;
declare const VkeyWitness: typeof C.Serialization.VkeyWitness;
type VkeyWitness = C.Serialization.VkeyWitness;
declare const Ed25519SignatureHex: (value: string) => Crypto.Ed25519SignatureHex;
type Ed25519SignatureHex = Crypto.Ed25519SignatureHex;
declare const Ed25519PublicKey: typeof Crypto.Ed25519PublicKey;
type Ed25519PublicKey = Crypto.Ed25519PublicKey;
declare const Ed25519Signature: typeof Crypto.Ed25519Signature;
type Ed25519Signature = Crypto.Ed25519Signature;
declare const Bip32PrivateKey: typeof Crypto.Bip32PrivateKey;
type Bip32PrivateKey = Crypto.Bip32PrivateKey;
declare const Bip32PublicKey: typeof Crypto.Bip32PublicKey;
type Bip32PublicKey = Crypto.Bip32PublicKey;
declare const PlutusLanguageVersion: typeof C.Cardano.PlutusLanguageVersion;
type PlutusLanguageVersion = C.Cardano.PlutusLanguageVersion;
declare const NativeScript: typeof C.Serialization.NativeScript;
type NativeScript = C.Serialization.NativeScript;
declare const ScriptPubkey: typeof C.Serialization.ScriptPubkey;
type ScriptPubkey = C.Serialization.ScriptPubkey;
declare const ScriptAll: typeof C.Serialization.ScriptAll;
type ScriptAll = C.Serialization.ScriptAll;
declare const ScriptAny: typeof C.Serialization.ScriptAny;
type ScriptAny = C.Serialization.ScriptAny;
declare const ScriptNOfK: typeof C.Serialization.ScriptNOfK;
type ScriptNOfK = C.Serialization.ScriptNOfK;
declare const TimelockStart: typeof C.Serialization.TimelockStart;
type TimelockStart = C.Serialization.TimelockStart;
declare const TimelockExpiry: typeof C.Serialization.TimelockExpiry;
type TimelockExpiry = C.Serialization.TimelockExpiry;
declare const PlutusV1Script: typeof C.Serialization.PlutusV1Script;
type PlutusV1Script = C.Serialization.PlutusV1Script;
declare const PlutusV2Script: typeof C.Serialization.PlutusV2Script;
type PlutusV2Script = C.Serialization.PlutusV2Script;
declare const PlutusV3Script: typeof C.Serialization.PlutusV3Script;
type PlutusV3Script = C.Serialization.PlutusV3Script;
declare const Costmdls: typeof C.Serialization.Costmdls;
type Costmdls = C.Serialization.Costmdls;
declare const CostModel: typeof C.Serialization.CostModel;
type CostModel = C.Serialization.CostModel;
declare const CborWriter: typeof C.Serialization.CborWriter;
type CborWriter = C.Serialization.CborWriter;
declare const CborReader: typeof C.Serialization.CborReader;
type CborReader = C.Serialization.CborReader;
declare const CborReaderState: typeof C.Serialization.CborReaderState;
type CborReaderState = C.Serialization.CborReaderState;
declare const RewardAccount: {
    (value: string): C.Cardano.RewardAccount;
    toHash(rewardAccount: C.Cardano.RewardAccount): Crypto.Ed25519KeyHashHex;
    fromCredential(credential: C.Cardano.Credential, networkId: C.Cardano.NetworkId): C.Cardano.RewardAccount;
    toNetworkId(rewardAccount: C.Cardano.RewardAccount): C.Cardano.NetworkId;
};
type RewardAccount = C.Cardano.RewardAccount;
declare const Hash: typeof C.Serialization.Hash;
type Hash<T extends string> = C.Serialization.Hash<T>;
declare const DatumHash: {
    (value: string): Crypto.Hash32ByteBase16;
    fromHexBlob<T>(value: _cardano_sdk_util.HexBlob): T;
};
type DatumHash = Crypto.Hash32ByteBase16;
declare const Datum: typeof C.Serialization.Datum;
type Datum = PlutusData | DatumHash;
type CostModels = C.Cardano.CostModels;
type ExUnits = C.Serialization.ExUnits;
declare const ExUnits: typeof C.Serialization.ExUnits;
declare const NetworkId: typeof C.Cardano.NetworkId;
type NetworkId = C.Cardano.ChainId["networkId"];
declare const DatumKind: typeof C.Serialization.DatumKind;
type Evaluator = (tx: Transaction, additionalUtxos: TransactionUnspentOutput[]) => Promise<Redeemers>;
declare const AuxiliaryData: typeof C.Serialization.AuxiliaryData;
type AuxiliaryData = C.Serialization.AuxiliaryData;
declare const Metadata: typeof C.Serialization.GeneralTransactionMetadata;
type Metadata = C.Serialization.GeneralTransactionMetadata;
declare const Metadatum: typeof C.Serialization.TransactionMetadatum;
type Metadatum = C.Serialization.TransactionMetadatum;
declare const MetadatumMap: typeof C.Serialization.MetadatumMap;
type MetadatumMap = C.Serialization.MetadatumMap;
declare const MetadatumList: typeof C.Serialization.MetadatumList;
type MetadatumList = C.Serialization.MetadatumList;
declare const TransactionMetadatumKind: typeof C.Serialization.TransactionMetadatumKind;
type TransactionMetadatumKind = C.Serialization.TransactionMetadatumKind;
/**
 * The SlotConfig interface defines the configuration for slots.
 * @interface SlotConfig
 * @property {number} zeroTime - The zero time for slot calculation.
 * @property {number} zeroSlot - The zero slot.
 * @property {number} slotLength - The slot length.
 */
interface SlotConfig {
    zeroTime: number;
    zeroSlot: number;
    slotLength: number;
}
declare const SLOT_CONFIG_NETWORK: {
    Mainnet: {
        zeroTime: number;
        zeroSlot: number;
        slotLength: number;
    };
    Preview: {
        zeroTime: number;
        zeroSlot: number;
        slotLength: number;
    };
    Preprod: {
        zeroTime: number;
        zeroSlot: number;
        slotLength: number;
    };
};

/**
 * Converts an Address to a PaymentAddress.
 * @param {Address} address - The address to be converted.
 * @returns {PaymentAddress} The converted address in PaymentAddress format.
 * @throws {Error} If a reward account is passed in.
 */
declare function getPaymentAddress(address: Address): PaymentAddress;
/**
 * Converts a PolicyId to a Hash28ByteBase16 format.
 * @param {PolicyId} policy - The policy ID to be converted.
 * @returns {Hash28ByteBase16} The converted hash in Hash28ByteBase16 format.
 */
declare function PolicyIdToHash(policy: PolicyId): Hash28ByteBase16;
/**
 * Converts a Hash28ByteBase16 to an Ed25519PublicKeyHex format.
 * @param {Hash28ByteBase16} hash - The hash to be converted.
 * @returns {Ed25519PublicKeyHex} The converted hash in Ed25519PublicKeyHex format.
 */
declare function HashAsPubKeyHex(hash: Hash28ByteBase16): Ed25519PublicKeyHex;
/**
 * Converts a hex string to a byte array.
 * @param {string} hexString - The hex string to convert.
 * @returns {Uint8Array} The resulting byte array.
 */
declare function fromHex(hexString: string): Uint8Array;
/**
 * Converts a byte array to a hex string.
 * @param {Uint8Array} byteArray - The byte array to convert.
 * @returns {string} The resulting hex string.
 */
declare function toHex(byteArray: Uint8Array): string;
/**
 * Function to compute the SHA2-256 hash of a hex blob.
 * @param {HexBlob} _data - The hex blob to compute the hash of.
 * @returns {Hash32ByteBase16} The computed hash in Hash32ByteBase16 format.
 */
declare function sha2_256(data: HexBlob): Hash32ByteBase16;
/**
 * Function to compute the SHA3-256 hash of a hex blob.
 * @param {HexBlob} _data - The hex blob to compute the hash of.
 * @returns {Hash32ByteBase16} The computed hash in Hash32ByteBase16 format.
 */
declare function sha3_256(data: HexBlob): Hash32ByteBase16;
/**
 * Function to compute the BLAKE2b-256 hash of a hex blob.
 * @param {HexBlob} _data - The hex blob to compute the hash of.
 * @returns {Hash32ByteBase16} The computed hash in Hash32ByteBase16 format.
 */
declare function blake2b_256(data: HexBlob): Hash32ByteBase16;
/**
 * Function to compute the BLAKE2b-224 hash of a hex blob.
 * @param {HexBlob} _data - The hex blob to compute the hash of.
 * @returns {Hash32ByteBase16} The computed hash in Hash28ByteBase16 format.
 */
declare function blake2b_224(data: HexBlob): Hash28ByteBase16;
/**
 * Function to derive the public key from a private key.
 * @param {Ed25519PrivateNormalKeyHex | Ed25519PrivateExtendedKeyHex} privateKey - The private key to derive the public key from.
 * @returns {Ed25519PublicKeyHex} The derived public key.
 */
declare function derivePublicKey(privateKey: Ed25519PrivateNormalKeyHex | Ed25519PrivateExtendedKeyHex): Ed25519PublicKeyHex;
/**
 * Function to sign a message with a private key.
 * @param {HexBlob} message - The message to sign.
 * @param {Ed25519PrivateNormalKeyHex} privateKey - The private key to sign the message with.
 * @returns {Ed25519SignatureHex} The signature of the message.
 */
declare function signMessage(message: HexBlob, privateKey: Ed25519PrivateNormalKeyHex | Ed25519PrivateExtendedKeyHex): Ed25519SignatureHex;
/**
 * Function to generate a mnemonic.
 * @returns {string} The generated mnemonic.
 */
declare const generateMnemonic: typeof bip39.generateMnemonic;
/**
 * Function to convert entropy to a mnemonic.
 * @param {Buffer} entropy - The entropy to convert.
 * @returns {string} The generated mnemonic.
 */
declare const entropyToMnemonic: typeof bip39.entropyToMnemonic;
/**
 * Function to convert a mnemonic to entropy.
 * @param {string} mnemonic - The mnemonic to convert.
 * @returns {Buffer} The generated entropy.
 */
declare const mnemonicToEntropy: typeof bip39.mnemonicToEntropy;
/**
 * Function to create an Address from a Bech32 string.
 * @param {string} bech32 - The Bech32 string to create the Address from.
 * @returns {Address} The created Address.
 */
declare const addressFromBech32: typeof C.Cardano.Address.fromBech32;
/**
 * Function to create an Address from a validator script.
 * @param {NetworkId} network - The network ID of the Address.
 * @param {Script} validator - The validator script to create the Address from.
 * @returns {Address} The created Address.
 */
declare const addressFromValidator: (network: NetworkId, validator: Script) => Address;
/**
 * Function to create an Address from a credential.
 * @param {NetworkId} network - The network ID of the Address.
 * @param {Credential} credential - The credential to create the Address from.
 * @returns {Address} The created Address.
 */
declare const addressFromCredential: (network: NetworkId, credential: Credential) => Address;
/**
 * Function to create an Address from payment and optional delegation credentials.
 * @param {NetworkId} network - The network ID of the Address.
 * @param {Credential} paymentCredential - The payment credential to create the Address from.
 * @param {Credential} [delegationCredential] - The optional delegation credential to create the Address from.
 * @returns {Address} The created Address.
 */
declare const addressFromCredentials: (network: NetworkId, paymentCredential: Credential, delegationCredential?: Credential) => Address;
declare const getBurnAddress: (network: NetworkId) => C.Cardano.Address;
/**
 * Interface for objects that can be serialized to CBOR.
 */
interface CborSerializable<C> {
    /**
     * Function to serialize the object to CBOR.
     * @returns {HexBlob} The serialized object.
     */
    toCbor(): HexBlob;
    /**
     * Function to convert the object to its core representation.
     * @returns {C} The core representation of the object.
     */
    toCore(): C;
}
/**
 * Exporting CborSet from C.Serialization.
 */
declare const CborSet: typeof C.Serialization.CborSet;
/**
 * Type definition for CborSet.
 */
type CborSet<A, B extends CborSerializable<A>> = C.Serialization.CborSet<A, B>;
/**
 * Helper function to set the serialization era.
 */
declare const setInConwayEra: (value: boolean) => false;

/**
 * Cardano ledger protocol parameters.
 */
interface ProtocolParameters {
    /** The number of coins per UTXO byte. */
    coinsPerUtxoByte: number;
    /** The maximum transaction size. */
    maxTxSize: number;
    /** The minimum fee coefficient. */
    minFeeCoefficient: number;
    /** The minimum fee constant. */
    minFeeConstant: number;
    /** The maximum block body size. */
    maxBlockBodySize: number;
    /** The maximum block header size. */
    maxBlockHeaderSize: number;
    /** The stake key deposit. */
    stakeKeyDeposit: number;
    /** The pool deposit. */
    poolDeposit: number | null;
    /** The pool retirement epoch bound. */
    poolRetirementEpochBound: number;
    /** The desired number of pools. */
    desiredNumberOfPools: number;
    /** The pool influence. */
    poolInfluence: string;
    /** The monetary expansion. */
    monetaryExpansion: string;
    /** The treasury expansion. */
    treasuryExpansion: string;
    /** The minimum pool cost. */
    minPoolCost: number;
    /** The protocol version. */
    protocolVersion: Cardano.ProtocolVersion;
    /** The maximum value size. */
    maxValueSize: number;
    /** The collateral percentage. */
    collateralPercentage: number;
    /** The maximum collateral inputs. */
    maxCollateralInputs: number;
    /** The cost models. */
    costModels: Cardano.CostModels;
    /** The prices. */
    prices: Cardano.Prices;
    /** The maximum execution units per transaction. */
    maxExecutionUnitsPerTransaction: Cardano.ExUnits;
    /** The maximum execution units per block. */
    maxExecutionUnitsPerBlock: Cardano.ExUnits;
    /** Params used for calculating the minimum fee from reference inputs (see https://github.com/CardanoSolutions/ogmios/releases/tag/v6.5.0) */
    minFeeReferenceScripts?: MinFeeReferenceScripts;
}
/**
 * Hard coded protocol parameters for the Cardano ledger.
 * These parameters are used as default values in the absence of network-provided parameters.
 */
declare const hardCodedProtocolParams: ProtocolParameters;
interface MinFeeReferenceScripts {
    base: number;
    range: number;
    multiplier: number;
}

type Prettier = PlutusData | string | number | boolean | null;
declare function prettify(data: Prettier, indent?: string): string;

type SelectionPhase = "wide" | "deep" | "final";
declare class UTxOSelectionError extends Error {
    phase: SelectionPhase;
    dearth: Value;
    availableInputs?: TransactionUnspentOutput[] | undefined;
    selectedInputs?: TransactionUnspentOutput[] | undefined;
    bestStep?: [bigint | number, Value, number] | undefined;
    constructor(phase: SelectionPhase, dearth: Value, availableInputs?: TransactionUnspentOutput[] | undefined, selectedInputs?: TransactionUnspentOutput[] | undefined, bestStep?: [bigint | number, Value, number] | undefined);
}

export { Address, AddressType, AssetId, AssetName, AuxiliaryData, Bip32PrivateKey, Bip32PrivateKeyHex, Bip32PublicKey, CborReader, CborReaderState, CborSet, CborWriter, Certificate, CertificateType, ConstrPlutusData, CostModel, type CostModels, Costmdls, Credential, type CredentialCore, CredentialType, Datum, DatumHash, DatumKind, Ed25519KeyHashHex, Ed25519PrivateExtendedKeyHex, Ed25519PrivateKey, Ed25519PrivateNormalKeyHex, Ed25519PublicKey, Ed25519PublicKeyHex, Ed25519Signature, Ed25519SignatureHex, type Evaluator, ExUnits, Hash, Hash28ByteBase16, Hash32ByteBase16, HashAsPubKeyHex, Metadata, Metadatum, MetadatumList, MetadatumMap, type MinFeeReferenceScripts, NativeScript, NetworkId, PaymentAddress, PlutusData, PlutusDataKind, PlutusLanguageVersion, PlutusList, PlutusMap, PlutusV1Script, PlutusV2Script, PlutusV3Script, PolicyId, PolicyIdToHash, PoolId, type Prettier, type ProtocolParameters, Redeemer, RedeemerPurpose, RedeemerTag, Redeemers, RewardAccount, RewardAddress, SLOT_CONFIG_NETWORK, Script, ScriptAll, ScriptAny, type ScriptHash, ScriptNOfK, ScriptPubkey, type SelectionPhase, Slot, type SlotConfig, StakeDelegation, type StakeDelegationCertificate, StakeRegistration, TimelockExpiry, TimelockStart, type TokenMap, Transaction, TransactionBody, TransactionId, TransactionInput, type TransactionInputSet, TransactionMetadatumKind, TransactionOutput, TransactionUnspentOutput, type TransactionWitnessPlutusData, TransactionWitnessSet, TxCBOR, UTxOSelectionError, Value, VkeyWitness, addressFromBech32, addressFromCredential, addressFromCredentials, addressFromValidator, blake2b_224, blake2b_256, derivePublicKey, entropyToMnemonic, fromHex, generateMnemonic, getBurnAddress, getPaymentAddress, hardCodedProtocolParams, mnemonicToEntropy, prettify, setInConwayEra, sha2_256, sha3_256, signMessage, toHex };
