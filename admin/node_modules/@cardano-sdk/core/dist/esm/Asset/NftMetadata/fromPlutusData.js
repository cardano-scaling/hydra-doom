import { ImageMediaType, MediaType, Uri } from './types.js';
import { asString } from './util.js';
import { contextLogger, isNotNil } from '@cardano-sdk/util';
import { isConstrPlutusData, isPlutusBigInt, isPlutusBoundedBytes, isPlutusList, isPlutusMap, tryConvertPlutusMapToUtf8Record } from '../../Cardano/util/index.js';
const tryCoerce = (value, ctor, logger) => {
    if (typeof value !== 'string')
        return;
    try {
        return ctor(value);
    }
    catch (error) {
        logger.warn(error instanceof Error ? error.message : error);
    }
};
const mapOtherPropertyValue = (value, logger) => {
    if (typeof value === 'string' || isPlutusBigInt(value) || isPlutusBoundedBytes(value))
        return value;
    if (isPlutusMap(value)) {
        const properties = mapOtherProperties(tryConvertPlutusMapToUtf8Record(value, logger), logger);
        return new Map(Object.entries(properties));
    }
    const list = isPlutusList(value) ? value.items : value.fields.items;
    return list.map((item) => mapOtherPropertyValue(item, logger));
};
const mapOtherProperties = (additionalProperties, logger) => Object.entries(additionalProperties).reduce((result, [key, value]) => {
    if (typeof value !== 'undefined') {
        result.set(key, mapOtherPropertyValue(value, logger));
    }
    return result;
}, new Map());
const undefinedIfEmpty = (map) => (map.size > 0 ? map : undefined);
const mapFile = (file, logger) => {
    if (!isPlutusMap(file)) {
        logger.warn('expected "files[n]" to be a map');
        return;
    }
    const { mediaType: mediaTypeStr, src: srcStr, name, ...additionalProperties } = tryConvertPlutusMapToUtf8Record(file, logger);
    const mediaType = tryCoerce(mediaTypeStr, MediaType, logger);
    const src = tryCoerce(srcStr, Uri, logger);
    if (typeof src !== 'string' || typeof mediaType !== 'string') {
        logger.warn('invalid "files[n].src" or "files[n].mediaType"');
        return;
    }
    return {
        mediaType,
        name: asString(name),
        otherProperties: undefinedIfEmpty(mapOtherProperties(additionalProperties, logger)),
        src
    };
};
const mapFiles = (files, logger) => {
    if (!files)
        return;
    if (!isPlutusList(files)) {
        logger.warn('expected "files" to be a list');
        return;
    }
    return files.items.map((file) => mapFile(file, logger)).filter(isNotNil);
};
const getConditionalValidators = (strict, logger) => ({
    isNameValid: (name) => {
        if (typeof name === 'string')
            return true;
        if (typeof name === 'undefined') {
            if (strict) {
                logger.debug('Invalid PlutusData: "name" is required');
                return false;
            }
            return true;
        }
        logger.debug('Invalid PlutusData: "name" must be utf8 bounded bytes');
        return false;
    },
    isValidDatumShape: (plutusData) => {
        const minNumberOfFields = strict ? 3 : 2;
        const isValid = isConstrPlutusData(plutusData) &&
            plutusData.constructor === 0n &&
            plutusData.fields.items.length >= minNumberOfFields;
        if (!isValid)
            logger.debug(`Invalid PlutusData: expecting ConstrPlutusData with 0th constructor and ${minNumberOfFields} items`);
        return isValid;
    }
});
export const fromPlutusData = (plutusData, parentLogger, strict = false) => {
    const logger = contextLogger(parentLogger, 'NftMetadata.fromPlutusData');
    const conditionalValidators = getConditionalValidators(strict, logger);
    if (!conditionalValidators.isValidDatumShape(plutusData)) {
        return null;
    }
    const [nftMetadata, version] = plutusData.fields.items;
    if (!isPlutusMap(nftMetadata) || !isPlutusBigInt(version)) {
        logger.debug('Invalid PlutusData: expecting a map at [0] and integer at [1]');
        return null;
    }
    const nftMetadataRecord = tryConvertPlutusMapToUtf8Record(nftMetadata, logger);
    const { name, image, mediaType, description, files, ...additionalProperties } = nftMetadataRecord;
    if (!conditionalValidators.isNameValid(name)) {
        return null;
    }
    if (typeof image !== 'string') {
        logger.debug('Invalid PlutusData: "image" must be UTF-8 bounded bytes');
        return null;
    }
    const imageAsUri = tryCoerce(image, Uri, logger);
    if (!imageAsUri) {
        return null;
    }
    return {
        description: asString(description),
        files: mapFiles(files, logger),
        image: imageAsUri,
        mediaType: tryCoerce(mediaType, ImageMediaType, logger),
        name: name || '',
        otherProperties: undefinedIfEmpty(mapOtherProperties(additionalProperties, logger)),
        version: version.toString()
    };
};
//# sourceMappingURL=fromPlutusData.js.map