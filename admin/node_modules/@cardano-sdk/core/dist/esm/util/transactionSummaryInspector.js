import { AssetId } from '../Cardano/index.js';
import { assetsBurnedInspector, assetsMintedInspector, resolveInputs, totalAddressInputsValueInspector, totalAddressOutputsValueInspector } from './txInspector.js';
import { BigIntMath } from '@cardano-sdk/util';
import { TimeoutError } from '../errors.js';
import { coalesceTokenMaps, subtractTokenMaps } from '../Asset/util/index.js';
import { coalesceValueQuantities } from './coalesceValueQuantities.js';
import { computeImplicitCoin } from '../Cardano/util/index.js';
import { promiseTimeout } from './promiseTimeout.js';
import { subtractValueQuantities } from './subtractValueQuantities.js';
import { tryGetAssetInfos } from './tryGetAssetInfos.js';
export const getCollateral = async (tx, inputResolver, addresses) => {
    if (!tx.body.collaterals || tx.body.collaterals.length === 0)
        return 0n;
    const resolvedCollateralInputs = (await resolveInputs(tx.body.collaterals, inputResolver)).resolvedInputs.filter((input) => addresses.includes(input.address));
    const totalOwnedValueAtRisk = BigIntMath.sum(resolvedCollateralInputs.map(({ value }) => value.coins));
    if (tx.body.collateralReturn) {
        if (!addresses.includes(tx.body.collateralReturn.address))
            return totalOwnedValueAtRisk;
        return BigIntMath.max([totalOwnedValueAtRisk - tx.body.collateralReturn.value.coins, 0n]) ?? 0n;
    }
    return totalOwnedValueAtRisk;
};
const totalInputsValue = (resolvedInputs) => {
    const receivedInputsValues = resolvedInputs.resolvedInputs.map((input) => input.value);
    return coalesceValueQuantities(receivedInputsValues);
};
const totalOutputsValue = (outputs) => coalesceValueQuantities(outputs.map((output) => output.value));
const mintInspectionToTokenMap = (mintedAssets) => new Map(mintedAssets.map((asset) => [AssetId.fromParts(asset.policyId, asset.assetName), asset.quantity]));
const getImplicitAssets = async (tx) => {
    const mintedAssets = mintInspectionToTokenMap(await assetsMintedInspector(tx));
    const burnedAssets = mintInspectionToTokenMap(await assetsBurnedInspector(tx));
    return coalesceTokenMaps([mintedAssets, burnedAssets]);
};
const getUnaccountedFunds = async (tx, resolvedInputs, implicitCoin, fee, implicitAssets = new Map()) => {
    const totalInputs = totalInputsValue(resolvedInputs);
    const totalOutputs = totalOutputsValue(tx.body.outputs);
    totalInputs.assets = coalesceTokenMaps([totalInputs.assets, implicitAssets]);
    totalInputs.coins += implicitCoin;
    totalOutputs.coins += fee;
    return subtractValueQuantities([totalOutputs, totalInputs]);
};
const intoAssetInfoWithAmount = async ({ assetProvider, logger, timeout, tokenMap }) => {
    if (!tokenMap)
        return new Map();
    const assetIds = tokenMap && tokenMap.size > 0 ? [...tokenMap.keys()] : [];
    const assetInfos = new Map();
    if (assetIds.length > 0) {
        const assets = await tryGetAssetInfos({
            assetIds,
            assetProvider,
            logger,
            timeout
        });
        for (const asset of assets) {
            const amount = tokenMap?.get(asset.assetId) ?? 0n;
            assetInfos.set(asset.assetId, { amount, assetInfo: asset });
        }
    }
    return assetInfos;
};
export const transactionSummaryInspector = ({ inputResolver, addresses, rewardAccounts, protocolParameters, assetProvider, dRepKeyHash, timeout, logger }) => async (tx) => {
    let resolvedInputs;
    try {
        resolvedInputs = await promiseTimeout(resolveInputs(tx.body.inputs, inputResolver), timeout);
    }
    catch (error) {
        if (error instanceof TimeoutError) {
            logger.error('Error: Inputs resolution timed out');
        }
        resolvedInputs = {
            resolvedInputs: [],
            unresolvedInputs: tx.body.inputs
        };
    }
    const fee = tx.body.fee;
    const implicit = computeImplicitCoin(protocolParameters, { certificates: tx.body.certificates, withdrawals: tx.body.withdrawals }, rewardAccounts || [], dRepKeyHash);
    const collateral = await getCollateral(tx, inputResolver, addresses);
    const totalOutputValue = await totalAddressOutputsValueInspector(addresses)(tx);
    const totalInputValue = await totalAddressInputsValueInspector(addresses, inputResolver)(tx);
    const implicitCoin = (implicit.withdrawals || 0n) + (implicit.reclaimDeposit || 0n) - (implicit.deposit || 0n);
    const implicitAssets = await getImplicitAssets(tx);
    const diff = {
        assets: subtractTokenMaps([totalOutputValue.assets, totalInputValue.assets]),
        coins: totalOutputValue.coins - totalInputValue.coins
    };
    return {
        assets: await intoAssetInfoWithAmount({
            assetProvider,
            logger,
            timeout,
            tokenMap: diff.assets
        }),
        coins: diff.coins,
        collateral,
        deposit: implicit.deposit || 0n,
        fee,
        returnedDeposit: implicit.reclaimDeposit || 0n,
        unresolved: {
            inputs: resolvedInputs.unresolvedInputs,
            value: await getUnaccountedFunds(tx, resolvedInputs, implicitCoin, fee, implicitAssets)
        }
    };
};
//# sourceMappingURL=transactionSummaryInspector.js.map