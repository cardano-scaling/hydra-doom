import * as Crypto from '@cardano-sdk/crypto';
import { AssetFingerprint, AssetId, CertificateType, ScriptType, StakeCredentialCertificateTypes, isCertType } from '../Cardano/types/index.js';
import { BigIntMath } from '@cardano-sdk/util';
import { RewardAccount, isAddressWithin } from '../Cardano/Address/index.js';
import { coalesceValueQuantities } from './coalesceValueQuantities.js';
import { nativeScriptPolicyId } from './nativeScript.js';
import { removeNegativesFromTokenMap } from '../Asset/util/index.js';
import { subtractValueQuantities } from './subtractValueQuantities.js';
export const resolveInputs = async (txIns, inputResolver) => {
    const resolvedInputs = [];
    const unresolvedInputs = [];
    for (const input of txIns) {
        const resolvedInput = await inputResolver.resolveInput(input);
        if (resolvedInput) {
            resolvedInputs.push({
                address: resolvedInput.address,
                index: input.index,
                txId: input.txId,
                value: resolvedInput.value
            });
        }
        else {
            unresolvedInputs.push(input);
        }
    }
    return {
        resolvedInputs,
        unresolvedInputs
    };
};
export const totalAddressInputsValueInspector = (ownAddresses, inputResolver) => async (tx) => {
    const { resolvedInputs } = await resolveInputs(tx.body.inputs, inputResolver);
    const receivedInputs = resolvedInputs.filter((input) => isAddressWithin(ownAddresses)(input));
    const receivedInputsValues = receivedInputs.map((input) => input.value);
    return coalesceValueQuantities(receivedInputsValues);
};
export const totalAddressOutputsValueInspector = (ownAddresses) => async (tx) => {
    const receivedOutputs = tx.body.outputs.filter((out) => isAddressWithin(ownAddresses)(out));
    return coalesceValueQuantities(receivedOutputs.map((output) => output.value));
};
export const getCertificatesByType = (tx, rewardAccounts, certificateTypes) => {
    if (!tx.body.certificates || tx.body.certificates.length === 0)
        return [];
    const certificates = certificateTypes
        ? tx.body.certificates?.filter((certificate) => isCertType(certificate, certificateTypes))
        : tx.body.certificates;
    return certificates.filter((certificate) => {
        if (isCertType(certificate, StakeCredentialCertificateTypes)) {
            const credHash = Crypto.Ed25519KeyHashHex(certificate.stakeCredential.hash);
            return rewardAccounts.some((account) => RewardAccount.toHash(account) === credHash);
        }
        if (isCertType(certificate, [CertificateType.PoolRegistration]))
            return rewardAccounts.includes(certificate.poolParameters.rewardAccount);
        return false;
    });
};
export const signedCertificatesInspector = (rewardAccounts, certificateTypes) => async (tx) => getCertificatesByType(tx, rewardAccounts, certificateTypes);
export const sentInspector = ({ addresses, rewardAccounts, inputResolver }) => async (tx) => {
    const certificates = rewardAccounts?.length ? await signedCertificatesInspector(rewardAccounts)(tx) : [];
    let inputs = [];
    if (addresses) {
        const { resolvedInputs } = await resolveInputs(tx.body.inputs, inputResolver);
        const sentInputs = resolvedInputs.filter((input) => isAddressWithin(addresses)(input));
        inputs = sentInputs.map((input) => ({ address: input.address, index: input.index, txId: input.txId }));
    }
    return {
        certificates,
        inputs
    };
};
export const valueSentInspector = (ownAddresses, inputResolver) => async (tx) => {
    let assets = new Map();
    if ((await sentInspector({ addresses: ownAddresses, inputResolver })(tx)).inputs.length === 0)
        return { coins: 0n };
    const totalOutputValue = await totalAddressOutputsValueInspector(ownAddresses)(tx);
    const totalInputValue = await totalAddressInputsValueInspector(ownAddresses, inputResolver)(tx);
    const diff = subtractValueQuantities([totalInputValue, totalOutputValue]);
    if (diff.assets)
        assets = removeNegativesFromTokenMap(diff.assets);
    return {
        assets: assets.size > 0 ? assets : undefined,
        coins: diff.coins < 0n ? 0n : diff.coins
    };
};
export const valueReceivedInspector = (ownAddresses, inputResolver) => async (tx) => {
    let assets = new Map();
    const totalOutputValue = await totalAddressOutputsValueInspector(ownAddresses)(tx);
    const totalInputValue = await totalAddressInputsValueInspector(ownAddresses, inputResolver)(tx);
    const diff = subtractValueQuantities([totalOutputValue, totalInputValue]);
    if (diff.assets)
        assets = removeNegativesFromTokenMap(diff.assets);
    return {
        assets: assets.size > 0 ? assets : undefined,
        coins: diff.coins < 0n ? 0n : diff.coins
    };
};
const certificateInspector = (type) => async (tx) => tx.body.certificates?.filter((cert) => cert.__typename === type) ?? [];
export const delegationInspector = certificateInspector(CertificateType.StakeDelegation);
export const stakeKeyDeregistrationInspector = certificateInspector(CertificateType.StakeDeregistration);
export const stakeKeyRegistrationInspector = certificateInspector(CertificateType.StakeRegistration);
export const poolRegistrationInspector = certificateInspector(CertificateType.PoolRegistration);
export const poolRetirementInspector = certificateInspector(CertificateType.PoolRetirement);
export const withdrawalInspector = async (tx) => tx.body.withdrawals?.length ? BigIntMath.sum(tx.body.withdrawals.map(({ quantity }) => quantity)) : 0n;
export const mintInspector = (matchQuantityCriteria) => async (tx) => {
    const assets = [];
    const scriptMap = new Map();
    if (!tx.body.mint)
        return assets;
    const scripts = [...(tx.auxiliaryData?.scripts || []), ...(tx.witness?.scripts || [])];
    for (const script of scripts) {
        switch (script.__type) {
            case ScriptType.Native: {
                const policyId = nativeScriptPolicyId(script);
                if (scriptMap.has(policyId))
                    continue;
                scriptMap.set(policyId, script);
                break;
            }
            case ScriptType.Plutus:
            default:
        }
    }
    for (const [key, value] of tx.body.mint.entries()) {
        const [policyId, assetName] = [AssetId.getPolicyId(key), AssetId.getAssetName(key)];
        const mintedAsset = {
            assetName,
            fingerprint: AssetFingerprint.fromParts(policyId, assetName),
            policyId,
            quantity: value,
            script: scriptMap.get(policyId)
        };
        if (matchQuantityCriteria(mintedAsset.quantity))
            assets.push(mintedAsset);
    }
    return assets;
};
export const assetsMintedInspector = mintInspector((quantity) => quantity > 0);
export const assetsBurnedInspector = mintInspector((quantity) => quantity < 0);
export const metadataInspector = async (tx) => tx.auxiliaryData?.blob ?? new Map();
export const createTxInspector = (inspectors) => async (tx) => {
    const results = await Promise.all(Object.entries(inspectors).map(async ([key, inspector]) => {
        const result = await inspector(tx);
        return { key, result };
    }));
    return results.reduce((acc, { key, result }) => {
        acc[key] = result;
        return acc;
    }, {});
};
//# sourceMappingURL=txInspector.js.map