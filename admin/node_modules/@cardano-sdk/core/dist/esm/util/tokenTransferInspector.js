import { resolveInputs } from './txInspector.js';
import { TimeoutError } from '../errors.js';
import { coalesceValueQuantities } from './coalesceValueQuantities.js';
import { promiseTimeout } from './promiseTimeout.js';
import { subtractValueQuantities } from './subtractValueQuantities.js';
import { tryGetAssetInfos } from './tryGetAssetInfos.js';
import uniq from 'lodash/uniq.js';
const coalesceByAddress = (elements) => {
    const grouped = elements.reduce((acc, elem) => {
        if (!acc.has(elem.address))
            acc.set(elem.address, []);
        acc.get(elem.address)?.push(elem);
        return acc;
    }, new Map());
    const coalescedByAddress = new Map();
    for (const [address, elem] of grouped) {
        coalescedByAddress.set(address, coalesceValueQuantities(elem.map((x) => x.value)));
    }
    return coalescedByAddress;
};
const initializeAddressMap = (addresses) => new Map(addresses.map((address) => [address, { assets: new Map(), coins: 0n }]));
const updateFromAddressMap = (addressMap, key, value) => {
    if (value.coins < 0n) {
        addressMap.get(key).coins = value.coins;
    }
    for (const [assetId, quantity] of value.assets?.entries() ?? [])
        if (quantity < 0n) {
            addressMap.get(key).assets?.set(assetId, quantity);
        }
};
const updateToAddressMap = (addressMap, key, value) => {
    if (value.coins > 0n) {
        addressMap.get(key).coins = value.coins;
    }
    for (const [assetId, quantity] of value.assets?.entries() ?? []) {
        if (quantity > 0n) {
            addressMap.get(key).assets?.set(assetId, quantity);
        }
    }
};
const computeNetDifferences = (inputs, outputs, fromAddress, toAddress) => {
    for (const [key, inputValue] of inputs.entries()) {
        const outputValue = outputs.get(key) ?? { assets: new Map(), coins: 0n };
        const difference = subtractValueQuantities([outputValue, inputValue]);
        updateFromAddressMap(fromAddress, key, difference);
        updateToAddressMap(toAddress, key, difference);
    }
    for (const [key, outputValue] of outputs.entries()) {
        if (!inputs.has(key)) {
            updateToAddressMap(toAddress, key, outputValue);
        }
    }
};
const removeZeroBalanceEntries = (addressMap) => {
    for (const [key, value] of addressMap.entries()) {
        if (value.coins === 0n && value.assets?.size === 0) {
            addressMap.delete(key);
        }
    }
};
const intoTokenTransferValue = async ({ logger, assetProvider, timeout, addressMap }) => {
    const tokenTransferValue = new Map();
    for (const [address, value] of addressMap.entries()) {
        const coins = value.coins;
        const assetIds = uniq(value.assets && value.assets.size > 0 ? [...value.assets.keys()] : []);
        const assetInfos = new Map();
        if (assetIds.length > 0) {
            const assets = await tryGetAssetInfos({
                assetIds,
                assetProvider,
                logger,
                timeout
            });
            for (const asset of assets) {
                const amount = value.assets?.get(asset.assetId) ?? 0n;
                assetInfos.set(asset.assetId, { amount, assetInfo: asset });
            }
        }
        tokenTransferValue.set(address, {
            assets: assetInfos,
            coins
        });
    }
    return tokenTransferValue;
};
export const tokenTransferInspector = ({ inputResolver, fromAddressAssetProvider, toAddressAssetProvider, timeout, logger }) => async (tx) => {
    let resolvedInputs;
    try {
        const inputResolution = await promiseTimeout(resolveInputs(tx.body.inputs, inputResolver), timeout);
        resolvedInputs = inputResolution.resolvedInputs;
    }
    catch (error) {
        if (error instanceof TimeoutError) {
            logger.error('Error: Inputs resolution timed out');
        }
        resolvedInputs = [];
    }
    const coalescedInputsByAddress = coalesceByAddress(resolvedInputs);
    const coalescedOutputsByAddress = coalesceByAddress(tx.body.outputs);
    const addresses = uniq([...coalescedInputsByAddress.keys(), ...coalescedOutputsByAddress.keys()]);
    const fromAddress = initializeAddressMap(addresses);
    const toAddress = initializeAddressMap(addresses);
    computeNetDifferences(coalescedInputsByAddress, coalescedOutputsByAddress, fromAddress, toAddress);
    removeZeroBalanceEntries(fromAddress);
    removeZeroBalanceEntries(toAddress);
    return {
        fromAddress: await intoTokenTransferValue({
            addressMap: fromAddress,
            assetProvider: fromAddressAssetProvider,
            logger,
            timeout
        }),
        toAddress: await intoTokenTransferValue({
            addressMap: toAddress,
            assetProvider: toAddressAssetProvider,
            logger,
            timeout
        })
    };
};
//# sourceMappingURL=tokenTransferInspector.js.map