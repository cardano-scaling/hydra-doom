import { CustomError } from 'ts-custom-error';
import { EpochNo, Slot } from '../Cardano/types/Block.js';
import groupBy from 'lodash/groupBy.js';
import last from 'lodash/last.js';
import memoize from 'lodash/memoize.js';
import orderBy from 'lodash/orderBy.js';
export class EraSummaryError extends CustomError {
}
const createSlotEpochCalcImpl = (eraSummaries) => {
    const eraSummariesWithoutSkippedEras = Object.values(groupBy(eraSummaries, 'start.slot')).map(last);
    const eraSummariesAsc = orderBy(eraSummariesWithoutSkippedEras, ({ start }) => start.slot);
    return (slotNo) => {
        const relevantEraSummariesAsc = orderBy(eraSummariesAsc.filter(({ start }) => start.slot <= slotNo), ({ start }) => start.slot);
        if (relevantEraSummariesAsc.length === 0) {
            throw new EraSummaryError(`No EraSummary for slot ${slotNo} found`);
        }
        let epochNo = 0;
        let currentEraSummary;
        for (let i = 0; i < relevantEraSummariesAsc.length; i++) {
            currentEraSummary = relevantEraSummariesAsc[i];
            const nextEraSummary = relevantEraSummariesAsc[i + 1];
            epochNo += Math.floor(((nextEraSummary?.start.slot || slotNo) - currentEraSummary.start.slot) /
                currentEraSummary.parameters.epochLength);
        }
        return { epochEraSummary: currentEraSummary, epochNo };
    };
};
export const createSlotEpochCalc = memoize((eraSummaries) => {
    const calc = createSlotEpochCalcImpl(eraSummaries);
    return (slotNo) => EpochNo(calc(slotNo).epochNo);
});
export const createSlotTimeCalc = (eraSummaries) => {
    const eraSummariesWithoutSkippedEras = Object.values(groupBy(eraSummaries, 'start.slot')).map(last);
    const eraSummariesDesc = orderBy(eraSummariesWithoutSkippedEras, ({ start }) => start.slot, 'desc');
    return (slotNo) => {
        const activeEraSummary = eraSummariesDesc.find(({ start }) => start.slot <= slotNo);
        if (!activeEraSummary) {
            throw new EraSummaryError(`No EraSummary for slot ${slotNo} found`);
        }
        return new Date(activeEraSummary.start.time.getTime() +
            (slotNo - activeEraSummary.start.slot) * activeEraSummary.parameters.slotLength);
    };
};
export const createSlotEpochInfoCalc = (eraSummaries) => {
    const slotTimeCalc = createSlotTimeCalc(eraSummaries);
    const epochCalc = createSlotEpochCalcImpl(eraSummaries);
    return (slot) => {
        const { epochNo, epochEraSummary } = epochCalc(slot);
        const firstSlot = epochEraSummary.start.slot +
            Math.floor((slot - epochEraSummary.start.slot) / epochEraSummary.parameters.epochLength) *
                epochEraSummary.parameters.epochLength;
        const lastSlot = firstSlot + epochEraSummary.parameters.epochLength - 1;
        return {
            epochNo: EpochNo(epochNo),
            firstSlot: {
                date: slotTimeCalc(Slot(firstSlot)),
                slot: Slot(firstSlot)
            },
            lastSlot: {
                date: slotTimeCalc(Slot(lastSlot)),
                slot: Slot(lastSlot)
            }
        };
    };
};
const epochSlotsCalcImplementation = (epochNo, eraSummaries) => {
    let atEpoch = 0;
    let atSlot = eraSummaries[0].start.slot;
    let eraSummaryIdx = 0;
    const maxEraSummaryIdx = eraSummaries.length - 1;
    const checkNextEraSummary = () => eraSummaryIdx < maxEraSummaryIdx && atSlot >= eraSummaries[eraSummaryIdx + 1].start.slot;
    const findNextEraSummary = () => {
        while (checkNextEraSummary())
            eraSummaryIdx++;
    };
    findNextEraSummary();
    while (atEpoch !== epochNo) {
        atSlot += eraSummaries[eraSummaryIdx].parameters.epochLength;
        atEpoch++;
        if (checkNextEraSummary())
            findNextEraSummary();
    }
    const eraSummary = eraSummaries[eraSummaryIdx];
    return {
        eraSummary,
        firstSlot: Slot(atSlot),
        lastSlot: Slot(atSlot + eraSummary.parameters.epochLength - 1)
    };
};
export const epochSlotsCalc = memoize(epochSlotsCalcImplementation);
export const epochSlotsCalcFactory = memoize((provider) => memoize(async (epochNo) => epochSlotsCalcImplementation(epochNo, await provider.eraSummaries())));
//# sourceMappingURL=slotCalc.js.map