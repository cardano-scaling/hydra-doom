"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimeoutError = exports.NotImplementedError = exports.InvalidProtocolParametersError = exports.SerializationError = exports.SerializationFailure = exports.HandleOwnerChangeError = exports.ProviderError = exports.reasonToProviderFailure = exports.statusCodeMapToProviderFailure = exports.providerFailureToStatusCodeMap = exports.ProviderFailure = void 0;
const util_1 = require("@cardano-sdk/util");
const ts_custom_error_1 = require("ts-custom-error");
var ProviderFailure;
(function (ProviderFailure) {
    ProviderFailure["Conflict"] = "CONFLICT";
    ProviderFailure["NotFound"] = "NOT_FOUND";
    ProviderFailure["Unknown"] = "UNKNOWN";
    ProviderFailure["Forbidden"] = "FORBIDDEN";
    ProviderFailure["InvalidResponse"] = "INVALID_RESPONSE";
    ProviderFailure["NotImplemented"] = "NOT_IMPLEMENTED";
    ProviderFailure["Unhealthy"] = "UNHEALTHY";
    ProviderFailure["ConnectionFailure"] = "CONNECTION_FAILURE";
    ProviderFailure["BadRequest"] = "BAD_REQUEST";
    ProviderFailure["ServerUnavailable"] = "SERVER_UNAVAILABLE";
})(ProviderFailure = exports.ProviderFailure || (exports.ProviderFailure = {}));
exports.providerFailureToStatusCodeMap = {
    [ProviderFailure.BadRequest]: 400,
    [ProviderFailure.Forbidden]: 403,
    [ProviderFailure.NotFound]: 404,
    [ProviderFailure.Conflict]: 409,
    [ProviderFailure.Unhealthy]: 500,
    [ProviderFailure.Unknown]: 500,
    [ProviderFailure.InvalidResponse]: 500,
    [ProviderFailure.NotImplemented]: 500,
    [ProviderFailure.ConnectionFailure]: 500,
    [ProviderFailure.ServerUnavailable]: 500
};
exports.statusCodeMapToProviderFailure = new Map(Object.entries(exports.providerFailureToStatusCodeMap).map(([key, value]) => [value, key]));
const isProviderFailure = (reason) => Object.values(ProviderFailure).includes(reason);
const reasonToProviderFailure = (reason) => isProviderFailure(reason) ? reason : ProviderFailure.Unknown;
exports.reasonToProviderFailure = reasonToProviderFailure;
class ProviderError extends util_1.ComposableError {
    constructor(reason, innerError, detail) {
        super((0, util_1.formatErrorMessage)(reason, detail), innerError);
        this.reason = reason;
        this.detail = detail;
    }
}
exports.ProviderError = ProviderError;
class HandleOwnerChangeError extends ts_custom_error_1.CustomError {
    constructor(handle, expectedAddress, actualAddress) {
        super(`Expected: ${expectedAddress} for handle $${handle}. Actual: ${actualAddress}`);
        this.handle = handle;
        this.expectedAddress = expectedAddress;
        this.actualAddress = actualAddress;
    }
}
exports.HandleOwnerChangeError = HandleOwnerChangeError;
var SerializationFailure;
(function (SerializationFailure) {
    SerializationFailure["InvalidType"] = "INVALID_TYPE";
    SerializationFailure["Overflow"] = "OVERFLOW";
    SerializationFailure["InvalidAddress"] = "INVALID_ADDRESS";
    SerializationFailure["MaxLengthLimit"] = "MAX_LENGTH_LIMIT";
    SerializationFailure["InvalidScript"] = "INVALID_SCRIPT";
    SerializationFailure["InvalidNativeScriptKind"] = "INVALID_NATIVE_SCRIPT_KIND";
    SerializationFailure["InvalidScriptType"] = "INVALID_SCRIPT_TYPE";
    SerializationFailure["InvalidDatum"] = "INVALID_DATUM";
})(SerializationFailure = exports.SerializationFailure || (exports.SerializationFailure = {}));
class SerializationError extends util_1.ComposableError {
    constructor(reason, detail, innerError) {
        super((0, util_1.formatErrorMessage)(reason, detail), innerError);
        this.reason = reason;
        this.detail = detail;
    }
}
exports.SerializationError = SerializationError;
class InvalidProtocolParametersError extends ts_custom_error_1.CustomError {
    constructor(reason) {
        super(reason);
    }
}
exports.InvalidProtocolParametersError = InvalidProtocolParametersError;
class NotImplementedError extends ts_custom_error_1.CustomError {
    constructor(missingFeature) {
        super(`Not implemented: ${missingFeature}`);
    }
}
exports.NotImplementedError = NotImplementedError;
class TimeoutError extends ts_custom_error_1.CustomError {
    constructor(message) {
        super(`Timeout: ${message}`);
    }
}
exports.TimeoutError = TimeoutError;
//# sourceMappingURL=errors.js.map