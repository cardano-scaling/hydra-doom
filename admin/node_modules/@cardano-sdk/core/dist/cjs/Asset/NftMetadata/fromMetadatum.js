"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromMetadatum = void 0;
const Asset_1 = require("../../Cardano/types/Asset");
const types_1 = require("./types");
const errors_1 = require("./errors");
const metadatum_1 = require("../../util/metadatum");
const util_1 = require("./util");
const util_2 = require("@cardano-sdk/util");
const difference_js_1 = __importDefault(require("lodash/difference.js"));
const isString = (obj) => typeof obj === 'string';
const VersionRegExp = /^\d+\.?\d?$/;
const metadatumToString = (metadatum) => {
    if (Array.isArray(metadatum)) {
        const result = metadatum.map(util_1.asString);
        if (result.some((str) => typeof str === 'undefined')) {
            return undefined;
        }
        return result.join('');
    }
    return (0, util_1.asString)(metadatum);
};
const mapOtherProperties = (metadata, primaryProperties) => {
    const extraProperties = (0, difference_js_1.default)([...metadata.keys()].filter(isString), primaryProperties);
    if (extraProperties.length === 0)
        return;
    return extraProperties.reduce((result, key) => {
        result.set(key, metadata.get(key));
        return result;
    }, new Map());
};
const missingFieldLogMessage = (fieldType, assetId, rootLevel) => `Omitting cip25 ${rootLevel ? 'root' : 'file'} metadata: missing "${fieldType}". AssetId: ${assetId}`;
const mapFile = (metadatum, assetId, logger) => {
    const file = (0, metadatum_1.asMetadatumMap)(metadatum);
    if (!file)
        throw new errors_1.InvalidFileError();
    const name = (0, util_1.asString)(file.get('name'));
    const mediaType = (0, util_1.asString)(file.get('mediaType'));
    if (!mediaType) {
        logger.warn(missingFieldLogMessage('mediaType', assetId, false));
        return null;
    }
    const src = metadatumToString(file.get('src'));
    if (!src) {
        logger.warn(missingFieldLogMessage('source', assetId, false));
        return null;
    }
    return {
        mediaType: (0, types_1.MediaType)(mediaType),
        name,
        otherProperties: mapOtherProperties(file, ['mediaType', 'name', 'src']),
        src: (0, types_1.Uri)(src)
    };
};
const getPolicyMetadata = (policy, policyId) => (0, metadatum_1.asMetadatumMap)(policy.get(policyId) ||
    (() => {
        for (const [key, value] of policy.entries()) {
            if (ArrayBuffer.isView(key) && Buffer.from(key).toString('hex') === policyId)
                return value;
        }
    })());
const getAssetMetadata = (policy, assetName) => (0, metadatum_1.asMetadatumMap)(policy.get(assetName) ||
    policy.get(Buffer.from(assetName, 'hex').toString('utf8')) ||
    (() => {
        for (const [key, value] of policy.entries()) {
            if (ArrayBuffer.isView(key) && Buffer.from(key).toString('hex') === assetName)
                return value;
        }
    })());
const getName = (assetMetadata, version, asset, logger, stripInvisibleCharacters = false) => {
    const name = (0, util_1.asString)(assetMetadata.get('name'));
    if (name)
        return name;
    if (version === '1.0') {
        try {
            return Asset_1.AssetName.toUTF8(asset.name, stripInvisibleCharacters);
        }
        catch (error) {
            logger.warn(error);
        }
    }
};
const parseVersion = (version) => {
    if (!version)
        return '1.0';
    if (typeof version === 'bigint') {
        return `${version}.0`;
    }
    const stringVersion = (0, util_1.asString)(version);
    if (stringVersion && VersionRegExp.test(stringVersion)) {
        return `${Number(stringVersion)}.0`;
    }
};
const fromMetadatum = (asset, metadata, logger, strict = false) => {
    const cip25Metadata = metadata?.get(721n);
    if (!cip25Metadata)
        return null;
    const cip25MetadatumMap = (0, metadatum_1.asMetadatumMap)(cip25Metadata);
    if (!cip25MetadatumMap)
        return null;
    const policy = getPolicyMetadata(cip25MetadatumMap, asset.policyId);
    if (!policy)
        return null;
    const version = parseVersion(policy.get('version'));
    if (!version)
        return null;
    const assetMetadata = getAssetMetadata(policy, asset.name);
    if (!assetMetadata)
        return null;
    const name = getName(assetMetadata, version, asset, logger, true);
    const image = metadatumToString(assetMetadata.get('image'));
    const assetId = Asset_1.AssetId.fromParts(asset.policyId, asset.name);
    if ((strict && !name) || !image) {
        logger.warn(missingFieldLogMessage(!name ? 'name' : 'image', assetId, true));
        return null;
    }
    const mediaType = (0, util_1.asString)(assetMetadata.get('mediaType'));
    const files = (0, metadatum_1.asMetadatumArray)(assetMetadata.get('files'));
    try {
        return {
            description: metadatumToString(assetMetadata.get('description')),
            files: files?.map((file) => mapFile(file, assetId, logger)).filter(util_2.isNotNil),
            image: (0, types_1.Uri)(image),
            mediaType: mediaType ? (0, types_1.ImageMediaType)(mediaType) : undefined,
            name: name || '',
            otherProperties: mapOtherProperties(assetMetadata, ['name', 'image', 'mediaType', 'description', 'files']),
            version
        };
    }
    catch (error) {
        logger.warn('Invalid CIP-25 metadata', assetMetadata, error);
        return null;
    }
};
exports.fromMetadatum = fromMetadatum;
//# sourceMappingURL=fromMetadatum.js.map