"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromPlutusData = void 0;
const types_1 = require("./types");
const util_1 = require("./util");
const util_2 = require("@cardano-sdk/util");
const util_3 = require("../../Cardano/util");
const tryCoerce = (value, ctor, logger) => {
    if (typeof value !== 'string')
        return;
    try {
        return ctor(value);
    }
    catch (error) {
        logger.warn(error instanceof Error ? error.message : error);
    }
};
const mapOtherPropertyValue = (value, logger) => {
    if (typeof value === 'string' || (0, util_3.isPlutusBigInt)(value) || (0, util_3.isPlutusBoundedBytes)(value))
        return value;
    if ((0, util_3.isPlutusMap)(value)) {
        const properties = mapOtherProperties((0, util_3.tryConvertPlutusMapToUtf8Record)(value, logger), logger);
        return new Map(Object.entries(properties));
    }
    const list = (0, util_3.isPlutusList)(value) ? value.items : value.fields.items;
    return list.map((item) => mapOtherPropertyValue(item, logger));
};
const mapOtherProperties = (additionalProperties, logger) => Object.entries(additionalProperties).reduce((result, [key, value]) => {
    if (typeof value !== 'undefined') {
        result.set(key, mapOtherPropertyValue(value, logger));
    }
    return result;
}, new Map());
const undefinedIfEmpty = (map) => (map.size > 0 ? map : undefined);
const mapFile = (file, logger) => {
    if (!(0, util_3.isPlutusMap)(file)) {
        logger.warn('expected "files[n]" to be a map');
        return;
    }
    const { mediaType: mediaTypeStr, src: srcStr, name, ...additionalProperties } = (0, util_3.tryConvertPlutusMapToUtf8Record)(file, logger);
    const mediaType = tryCoerce(mediaTypeStr, types_1.MediaType, logger);
    const src = tryCoerce(srcStr, types_1.Uri, logger);
    if (typeof src !== 'string' || typeof mediaType !== 'string') {
        logger.warn('invalid "files[n].src" or "files[n].mediaType"');
        return;
    }
    return {
        mediaType,
        name: (0, util_1.asString)(name),
        otherProperties: undefinedIfEmpty(mapOtherProperties(additionalProperties, logger)),
        src
    };
};
const mapFiles = (files, logger) => {
    if (!files)
        return;
    if (!(0, util_3.isPlutusList)(files)) {
        logger.warn('expected "files" to be a list');
        return;
    }
    return files.items.map((file) => mapFile(file, logger)).filter(util_2.isNotNil);
};
const getConditionalValidators = (strict, logger) => ({
    isNameValid: (name) => {
        if (typeof name === 'string')
            return true;
        if (typeof name === 'undefined') {
            if (strict) {
                logger.debug('Invalid PlutusData: "name" is required');
                return false;
            }
            return true;
        }
        logger.debug('Invalid PlutusData: "name" must be utf8 bounded bytes');
        return false;
    },
    isValidDatumShape: (plutusData) => {
        const minNumberOfFields = strict ? 3 : 2;
        const isValid = (0, util_3.isConstrPlutusData)(plutusData) &&
            plutusData.constructor === 0n &&
            plutusData.fields.items.length >= minNumberOfFields;
        if (!isValid)
            logger.debug(`Invalid PlutusData: expecting ConstrPlutusData with 0th constructor and ${minNumberOfFields} items`);
        return isValid;
    }
});
const fromPlutusData = (plutusData, parentLogger, strict = false) => {
    const logger = (0, util_2.contextLogger)(parentLogger, 'NftMetadata.fromPlutusData');
    const conditionalValidators = getConditionalValidators(strict, logger);
    if (!conditionalValidators.isValidDatumShape(plutusData)) {
        return null;
    }
    const [nftMetadata, version] = plutusData.fields.items;
    if (!(0, util_3.isPlutusMap)(nftMetadata) || !(0, util_3.isPlutusBigInt)(version)) {
        logger.debug('Invalid PlutusData: expecting a map at [0] and integer at [1]');
        return null;
    }
    const nftMetadataRecord = (0, util_3.tryConvertPlutusMapToUtf8Record)(nftMetadata, logger);
    const { name, image, mediaType, description, files, ...additionalProperties } = nftMetadataRecord;
    if (!conditionalValidators.isNameValid(name)) {
        return null;
    }
    if (typeof image !== 'string') {
        logger.debug('Invalid PlutusData: "image" must be UTF-8 bounded bytes');
        return null;
    }
    const imageAsUri = tryCoerce(image, types_1.Uri, logger);
    if (!imageAsUri) {
        return null;
    }
    return {
        description: (0, util_1.asString)(description),
        files: mapFiles(files, logger),
        image: imageAsUri,
        mediaType: tryCoerce(mediaType, types_1.ImageMediaType, logger),
        name: name || '',
        otherProperties: undefinedIfEmpty(mapOtherProperties(additionalProperties, logger)),
        version: version.toString()
    };
};
exports.fromPlutusData = fromPlutusData;
//# sourceMappingURL=fromPlutusData.js.map