"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.jsonToMetadatum = exports.withProviderErrors = void 0;
const errors_1 = require("../errors");
const withProviderErrors = (providerImplementation, toProviderError) => Object.keys(providerImplementation).reduce((provider, key) => {
    const originalValue = providerImplementation[key];
    provider[key] =
        typeof originalValue === 'function'
            ? (...args) => originalValue(...args).catch(toProviderError)
            : originalValue;
    return provider;
}, {});
exports.withProviderErrors = withProviderErrors;
const tryParseBigIntKey = (key) => {
    if (key.startsWith('0x'))
        return key.slice(2);
    try {
        return BigInt(key);
    }
    catch {
        return key;
    }
};
const jsonToMetadatum = (obj) => {
    switch (typeof obj) {
        case 'number':
            return BigInt(obj);
        case 'string':
        case 'bigint':
            return obj;
        case 'object': {
            if (obj === null)
                break;
            if (Array.isArray(obj)) {
                return obj.map(exports.jsonToMetadatum);
            }
            return new Map(Object.keys(obj).map((key) => [tryParseBigIntKey(key), (0, exports.jsonToMetadatum)(obj[key])]));
        }
    }
    throw new errors_1.ProviderError(errors_1.ProviderFailure.NotImplemented, null, `Unsupported metadatum type: ${typeof obj}`);
};
exports.jsonToMetadatum = jsonToMetadatum;
//# sourceMappingURL=providerUtil.js.map