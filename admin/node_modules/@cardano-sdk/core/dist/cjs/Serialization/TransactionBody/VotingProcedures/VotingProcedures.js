"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _VotingProcedures_procedures, _VotingProcedures_originalBytes;
Object.defineProperty(exports, "__esModule", { value: true });
exports.VotingProcedures = void 0;
const CBOR_1 = require("../../CBOR");
const GovernanceActionId_1 = require("../../Common/GovernanceActionId");
const util_1 = require("@cardano-sdk/util");
const Voter_1 = require("./Voter");
const VotingProcedure_1 = require("./VotingProcedure");
const misc_1 = require("../../../util/misc");
class VotingProcedures {
    constructor() {
        _VotingProcedures_procedures.set(this, []);
        _VotingProcedures_originalBytes.set(this, undefined);
    }
    toCbor() {
        if (__classPrivateFieldGet(this, _VotingProcedures_originalBytes, "f"))
            return __classPrivateFieldGet(this, _VotingProcedures_originalBytes, "f");
        const writer = new CBOR_1.CborWriter();
        const voters = this.getVoters();
        if (voters.length === 0)
            throw new util_1.InvalidStateError('Empty VotingProcedures. There must be at least one VotingProcedure in the map');
        writer.writeStartMap(voters.length);
        for (const voter of voters) {
            const governanceActionIds = this.getGovernanceActionIdsByVoter(voter);
            if (governanceActionIds.length === 0)
                throw new util_1.InvalidStateError('Each voter must at least be associated to a GovernanceActionId');
            writer.writeEncodedValue((0, misc_1.hexToBytes)(voter.toCbor()));
            writer.writeStartMap(governanceActionIds.length);
            for (const actionIds of governanceActionIds) {
                writer.writeEncodedValue((0, misc_1.hexToBytes)(actionIds.toCbor()));
                const vote = this.get(voter, actionIds);
                if (!vote)
                    throw new util_1.InvalidStateError('Each governanceActionIds must at least be associated to a vote');
                writer.writeEncodedValue((0, misc_1.hexToBytes)(vote.toCbor()));
            }
        }
        return writer.encodeAsHex();
    }
    static fromCbor(cbor) {
        const reader = new CBOR_1.CborReader(cbor);
        const votingProcedures = new VotingProcedures();
        reader.readStartMap();
        while (reader.peekState() !== CBOR_1.CborReaderState.EndMap) {
            const voter = Voter_1.Voter.fromCbor(util_1.HexBlob.fromBytes(reader.readEncodedValue()));
            reader.readStartMap();
            while (reader.peekState() !== CBOR_1.CborReaderState.EndMap) {
                const actionId = GovernanceActionId_1.GovernanceActionId.fromCbor(util_1.HexBlob.fromBytes(reader.readEncodedValue()));
                const vote = VotingProcedure_1.VotingProcedure.fromCbor(util_1.HexBlob.fromBytes(reader.readEncodedValue()));
                votingProcedures.insert(voter, actionId, vote);
            }
            reader.readEndMap();
        }
        reader.readEndMap();
        __classPrivateFieldSet(votingProcedures, _VotingProcedures_originalBytes, cbor, "f");
        return votingProcedures;
    }
    toCore() {
        return __classPrivateFieldGet(this, _VotingProcedures_procedures, "f").map((value) => {
            const voter = value.voter.toCore();
            const votes = value.votes.map((vote) => ({
                actionId: vote.actionId.toCore(),
                votingProcedure: vote.votingProcedure.toCore()
            }));
            return { voter, votes };
        });
    }
    static fromCore(votingProcedures) {
        const procedures = new VotingProcedures();
        __classPrivateFieldSet(procedures, _VotingProcedures_procedures, votingProcedures.map((value) => {
            const voter = Voter_1.Voter.fromCore(value.voter);
            const votes = value.votes.map((vote) => ({
                actionId: GovernanceActionId_1.GovernanceActionId.fromCore(vote.actionId),
                votingProcedure: VotingProcedure_1.VotingProcedure.fromCore(vote.votingProcedure)
            }));
            return { voter, votes };
        }), "f");
        return procedures;
    }
    insert(voter, actionId, votingProcedure) {
        const foundVoter = __classPrivateFieldGet(this, _VotingProcedures_procedures, "f").find((value) => value.voter.equals(voter));
        if (!foundVoter) {
            __classPrivateFieldGet(this, _VotingProcedures_procedures, "f").push({
                voter,
                votes: [{ actionId, votingProcedure }]
            });
            return;
        }
        const foundVote = foundVoter.votes.find((vote) => vote.actionId.equals(actionId));
        if (foundVote)
            throw new util_1.InvalidArgumentError('actionId', 'Voter already has a voting procedure for the given actionId');
        foundVoter.votes.push({ actionId, votingProcedure });
        __classPrivateFieldSet(this, _VotingProcedures_originalBytes, undefined, "f");
    }
    get(voter, governanceActionId) {
        const foundVoter = __classPrivateFieldGet(this, _VotingProcedures_procedures, "f").find((value) => value.voter.equals(voter));
        if (!foundVoter)
            return undefined;
        const foundVote = foundVoter.votes.find((vote) => vote.actionId.equals(governanceActionId));
        if (!foundVote)
            return undefined;
        return foundVote.votingProcedure;
    }
    getVoters() {
        return __classPrivateFieldGet(this, _VotingProcedures_procedures, "f").map((procedure) => procedure.voter);
    }
    getGovernanceActionIdsByVoter(voter) {
        const foundVoter = __classPrivateFieldGet(this, _VotingProcedures_procedures, "f").find((procedure) => procedure.voter.equals(voter));
        if (!foundVoter)
            return [];
        return foundVoter.votes.map((votes) => votes.actionId);
    }
}
exports.VotingProcedures = VotingProcedures;
_VotingProcedures_procedures = new WeakMap(), _VotingProcedures_originalBytes = new WeakMap();
//# sourceMappingURL=VotingProcedures.js.map