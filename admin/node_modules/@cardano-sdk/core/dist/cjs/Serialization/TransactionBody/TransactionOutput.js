"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _TransactionOutput_instances, _TransactionOutput_address, _TransactionOutput_amount, _TransactionOutput_datum, _TransactionOutput_scriptRef, _TransactionOutput_originalBytes, _TransactionOutput_getMapSize;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionOutput = exports.REQUIRED_FIELDS_COUNT = void 0;
const Address_1 = require("../../Cardano/Address");
const CBOR_1 = require("../CBOR");
const Datum_1 = require("../Common/Datum");
const util_1 = require("@cardano-sdk/util");
const PlutusData_1 = require("../PlutusData");
const Scripts_1 = require("../Scripts");
const Value_1 = require("./Value");
exports.REQUIRED_FIELDS_COUNT = 2;
class TransactionOutput {
    constructor(address, amount) {
        _TransactionOutput_instances.add(this);
        _TransactionOutput_address.set(this, void 0);
        _TransactionOutput_amount.set(this, void 0);
        _TransactionOutput_datum.set(this, void 0);
        _TransactionOutput_scriptRef.set(this, void 0);
        _TransactionOutput_originalBytes.set(this, undefined);
        __classPrivateFieldSet(this, _TransactionOutput_address, address, "f");
        __classPrivateFieldSet(this, _TransactionOutput_amount, amount, "f");
    }
    toCbor() {
        if (__classPrivateFieldGet(this, _TransactionOutput_originalBytes, "f"))
            return __classPrivateFieldGet(this, _TransactionOutput_originalBytes, "f");
        const writer = new CBOR_1.CborWriter();
        const elementsSize = __classPrivateFieldGet(this, _TransactionOutput_instances, "m", _TransactionOutput_getMapSize).call(this);
        if (elementsSize === exports.REQUIRED_FIELDS_COUNT ||
            (elementsSize === 3 && __classPrivateFieldGet(this, _TransactionOutput_datum, "f") && __classPrivateFieldGet(this, _TransactionOutput_datum, "f").kind() === Datum_1.DatumKind.DataHash)) {
            writer.writeStartArray(elementsSize);
            writer.writeByteString(Buffer.from(__classPrivateFieldGet(this, _TransactionOutput_address, "f").toBytes(), 'hex'));
            writer.writeEncodedValue(Buffer.from(__classPrivateFieldGet(this, _TransactionOutput_amount, "f").toCbor(), 'hex'));
            if (__classPrivateFieldGet(this, _TransactionOutput_datum, "f")) {
                writer.writeByteString(Buffer.from(__classPrivateFieldGet(this, _TransactionOutput_datum, "f").asDataHash(), 'hex'));
            }
        }
        else {
            writer.writeStartMap(__classPrivateFieldGet(this, _TransactionOutput_instances, "m", _TransactionOutput_getMapSize).call(this));
            writer.writeInt(0n);
            writer.writeByteString(Buffer.from(__classPrivateFieldGet(this, _TransactionOutput_address, "f").toBytes(), 'hex'));
            writer.writeInt(1n);
            writer.writeEncodedValue(Buffer.from(__classPrivateFieldGet(this, _TransactionOutput_amount, "f").toCbor(), 'hex'));
            if (__classPrivateFieldGet(this, _TransactionOutput_datum, "f")) {
                writer.writeInt(2n);
                writer.writeStartArray(2);
                writer.writeInt(__classPrivateFieldGet(this, _TransactionOutput_datum, "f").kind());
                switch (__classPrivateFieldGet(this, _TransactionOutput_datum, "f").kind()) {
                    case Datum_1.DatumKind.DataHash:
                        writer.writeByteString(Buffer.from(__classPrivateFieldGet(this, _TransactionOutput_datum, "f").asDataHash(), 'hex'));
                        break;
                    case Datum_1.DatumKind.InlineData:
                        writer.writeTag(CBOR_1.CborTag.EncodedCborDataItem);
                        writer.writeByteString(Buffer.from(__classPrivateFieldGet(this, _TransactionOutput_datum, "f").asInlineData().toCbor(), 'hex'));
                        break;
                }
            }
            if (__classPrivateFieldGet(this, _TransactionOutput_scriptRef, "f")) {
                writer.writeInt(3n);
                writer.writeTag(CBOR_1.CborTag.EncodedCborDataItem);
                writer.writeByteString(Buffer.from(__classPrivateFieldGet(this, _TransactionOutput_scriptRef, "f").toCbor(), 'hex'));
            }
        }
        return writer.encodeAsHex();
    }
    static fromCbor(cbor) {
        const reader = new CBOR_1.CborReader(cbor);
        let address;
        let value;
        let datum;
        let scriptRef;
        if (reader.peekState() === CBOR_1.CborReaderState.StartMap) {
            reader.readStartMap();
            while (reader.peekState() !== CBOR_1.CborReaderState.EndMap) {
                const key = reader.readInt();
                switch (key) {
                    case 0n:
                        address = Address_1.Address.fromBytes(util_1.HexBlob.fromBytes(reader.readByteString()));
                        break;
                    case 1n:
                        value = Value_1.Value.fromCbor(util_1.HexBlob.fromBytes(reader.readEncodedValue()));
                        break;
                    case 2n: {
                        const datumReader = new CBOR_1.CborReader(util_1.HexBlob.fromBytes(reader.readEncodedValue()));
                        datumReader.readStartArray();
                        const datumKind = Number(datumReader.readInt());
                        if (datumKind === Datum_1.DatumKind.InlineData) {
                            const tag = datumReader.readTag();
                            if (tag !== CBOR_1.CborTag.EncodedCborDataItem)
                                throw new util_1.InvalidArgumentError('cbor', `Expected tag ${CBOR_1.CborTag.EncodedCborDataItem} but got ${tag}`);
                        }
                        const encodedDatum = datumReader.readByteString();
                        let dataHash;
                        let inlineDatum;
                        if (datumKind === Datum_1.DatumKind.DataHash)
                            dataHash = util_1.HexBlob.fromBytes(encodedDatum);
                        if (datumKind === Datum_1.DatumKind.InlineData)
                            inlineDatum = PlutusData_1.PlutusData.fromCbor(util_1.HexBlob.fromBytes(encodedDatum));
                        datum = new Datum_1.Datum(dataHash, inlineDatum);
                        break;
                    }
                    case 3n: {
                        const scriptReader = new CBOR_1.CborReader(util_1.HexBlob.fromBytes(reader.readEncodedValue()));
                        const tag = scriptReader.readTag();
                        if (tag !== CBOR_1.CborTag.EncodedCborDataItem)
                            throw new util_1.InvalidArgumentError('cbor', `Expected tag ${CBOR_1.CborTag.EncodedCborDataItem} but got ${tag}`);
                        const encodedDatum = scriptReader.readByteString();
                        scriptRef = Scripts_1.Script.fromCbor(util_1.HexBlob.fromBytes(encodedDatum));
                        break;
                    }
                }
            }
            reader.readEndMap();
        }
        else {
            const length = reader.readStartArray();
            address = Address_1.Address.fromBytes(util_1.HexBlob.fromBytes(reader.readByteString()));
            value = Value_1.Value.fromCbor(util_1.HexBlob.fromBytes(reader.readEncodedValue()));
            if (length === 3) {
                const datumHash = reader.readByteString();
                datum = Datum_1.Datum.newDataHash(util_1.HexBlob.fromBytes(datumHash));
            }
        }
        if (!address)
            throw new util_1.InvalidArgumentError('cbor', 'Transaction output does not contain an address.');
        if (!value)
            throw new util_1.InvalidArgumentError('cbor', 'Transaction output does not contain a value.');
        const output = new TransactionOutput(address, value);
        if (datum)
            output.setDatum(datum);
        if (scriptRef)
            output.setScriptRef(scriptRef);
        __classPrivateFieldSet(output, _TransactionOutput_originalBytes, cbor, "f");
        return output;
    }
    toCore() {
        return {
            address: __classPrivateFieldGet(this, _TransactionOutput_address, "f").asByron()
                ? __classPrivateFieldGet(this, _TransactionOutput_address, "f").toBase58()
                : __classPrivateFieldGet(this, _TransactionOutput_address, "f").toBech32(),
            datum: __classPrivateFieldGet(this, _TransactionOutput_datum, "f") && __classPrivateFieldGet(this, _TransactionOutput_datum, "f").kind() === Datum_1.DatumKind.InlineData ? __classPrivateFieldGet(this, _TransactionOutput_datum, "f").asInlineData()?.toCore() : undefined,
            datumHash: __classPrivateFieldGet(this, _TransactionOutput_datum, "f") && __classPrivateFieldGet(this, _TransactionOutput_datum, "f").kind() === Datum_1.DatumKind.DataHash ? __classPrivateFieldGet(this, _TransactionOutput_datum, "f").asDataHash() : undefined,
            scriptReference: __classPrivateFieldGet(this, _TransactionOutput_scriptRef, "f") ? __classPrivateFieldGet(this, _TransactionOutput_scriptRef, "f").toCore() : undefined,
            value: __classPrivateFieldGet(this, _TransactionOutput_amount, "f").toCore()
        };
    }
    static fromCore(coreTransactionOutput) {
        const address = Address_1.Address.fromString(coreTransactionOutput.address);
        if (!address)
            throw new util_1.InvalidArgumentError('coreTransactionOutput', `Invalid address ${address}`);
        const out = new TransactionOutput(address, Value_1.Value.fromCore(coreTransactionOutput.value));
        if (coreTransactionOutput.datum)
            out.setDatum(Datum_1.Datum.fromCore(coreTransactionOutput.datum));
        if (coreTransactionOutput.datumHash)
            out.setDatum(Datum_1.Datum.fromCore(coreTransactionOutput.datumHash));
        if (coreTransactionOutput.scriptReference)
            out.setScriptRef(Scripts_1.Script.fromCore(coreTransactionOutput.scriptReference));
        return out;
    }
    address() {
        return __classPrivateFieldGet(this, _TransactionOutput_address, "f");
    }
    amount() {
        return __classPrivateFieldGet(this, _TransactionOutput_amount, "f");
    }
    datum() {
        return __classPrivateFieldGet(this, _TransactionOutput_datum, "f");
    }
    setDatum(data) {
        __classPrivateFieldSet(this, _TransactionOutput_datum, data, "f");
    }
    scriptRef() {
        return __classPrivateFieldGet(this, _TransactionOutput_scriptRef, "f");
    }
    setScriptRef(script) {
        __classPrivateFieldSet(this, _TransactionOutput_scriptRef, script, "f");
    }
}
exports.TransactionOutput = TransactionOutput;
_TransactionOutput_address = new WeakMap(), _TransactionOutput_amount = new WeakMap(), _TransactionOutput_datum = new WeakMap(), _TransactionOutput_scriptRef = new WeakMap(), _TransactionOutput_originalBytes = new WeakMap(), _TransactionOutput_instances = new WeakSet(), _TransactionOutput_getMapSize = function _TransactionOutput_getMapSize() {
    let mapSize = exports.REQUIRED_FIELDS_COUNT;
    if (__classPrivateFieldGet(this, _TransactionOutput_datum, "f"))
        ++mapSize;
    if (__classPrivateFieldGet(this, _TransactionOutput_scriptRef, "f"))
        ++mapSize;
    return mapSize;
};
//# sourceMappingURL=TransactionOutput.js.map