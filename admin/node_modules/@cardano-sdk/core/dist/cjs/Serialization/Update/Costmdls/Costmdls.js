"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Costmdls_models, _Costmdls_originalBytes;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Costmdls = void 0;
const CBOR_1 = require("../../CBOR");
const CostModel_1 = require("./CostModel");
const util_1 = require("@cardano-sdk/util");
const Script_1 = require("../../../Cardano/types/Script");
class Costmdls {
    constructor(models = new Map()) {
        _Costmdls_models.set(this, void 0);
        _Costmdls_originalBytes.set(this, undefined);
        __classPrivateFieldSet(this, _Costmdls_models, models, "f");
    }
    toCbor() {
        const writer = new CBOR_1.CborWriter();
        if (__classPrivateFieldGet(this, _Costmdls_originalBytes, "f"))
            return __classPrivateFieldGet(this, _Costmdls_originalBytes, "f");
        const sortedCanonically = new Map([...__classPrivateFieldGet(this, _Costmdls_models, "f")].sort((a, b) => (a > b ? 1 : -1)));
        writer.writeStartMap(sortedCanonically.size);
        for (const [key, value] of sortedCanonically) {
            writer.writeInt(key);
            writer.writeStartArray(value.costs().length);
            for (const cost of value.costs()) {
                writer.writeInt(cost);
            }
        }
        return writer.encodeAsHex();
    }
    static fromCbor(cbor) {
        const reader = new CBOR_1.CborReader(cbor);
        reader.readStartMap();
        const models = new Map();
        while (reader.peekState() !== CBOR_1.CborReaderState.EndMap) {
            const language = Number(reader.readInt());
            const costs = new Array();
            reader.readStartArray();
            while (reader.peekState() !== CBOR_1.CborReaderState.EndArray) {
                costs.push(Number(reader.readInt()));
            }
            reader.readEndArray();
            models.set(language, new CostModel_1.CostModel(language, costs));
        }
        reader.readEndMap();
        const costmdl = new Costmdls(models);
        __classPrivateFieldSet(costmdl, _Costmdls_originalBytes, cbor, "f");
        return costmdl;
    }
    toCore() {
        const models = new Map();
        for (const [key, value] of __classPrivateFieldGet(this, _Costmdls_models, "f")) {
            models.set(key, value.costs());
        }
        return models;
    }
    static fromCore(costModels) {
        const models = new Map();
        for (const [key, value] of costModels) {
            models.set(key, new CostModel_1.CostModel(key, value));
        }
        return new Costmdls(models);
    }
    size() {
        return __classPrivateFieldGet(this, _Costmdls_models, "f").size;
    }
    insert(value) {
        __classPrivateFieldGet(this, _Costmdls_models, "f").set(value.language(), value);
        __classPrivateFieldSet(this, _Costmdls_originalBytes, undefined, "f");
    }
    get(key) {
        return __classPrivateFieldGet(this, _Costmdls_models, "f").get(key);
    }
    keys() {
        return [...__classPrivateFieldGet(this, _Costmdls_models, "f").keys()];
    }
    languageViewsEncoding() {
        const encodedLanguageViews = new CBOR_1.CborWriter();
        const sortedCanonically = new Map([...__classPrivateFieldGet(this, _Costmdls_models, "f")].sort((a, b) => {
            const lhs = a[0] === Script_1.PlutusLanguageVersion.V1 ? 0x41 : a[0];
            const rhs = b[0] === Script_1.PlutusLanguageVersion.V1 ? 0x41 : b[0];
            return lhs > rhs ? 1 : -1;
        }));
        encodedLanguageViews.writeStartMap(sortedCanonically.size);
        for (const [key, value] of sortedCanonically) {
            switch (key) {
                case Script_1.PlutusLanguageVersion.V1: {
                    const writer = new CBOR_1.CborWriter();
                    writer.writeStartArray();
                    for (const cost of value.costs()) {
                        writer.writeInt(cost);
                    }
                    writer.writeEndArray();
                    const innerCbor = writer.encode();
                    encodedLanguageViews.writeByteString(new Uint8Array([0]));
                    encodedLanguageViews.writeByteString(innerCbor);
                    break;
                }
                case Script_1.PlutusLanguageVersion.V2:
                case Script_1.PlutusLanguageVersion.V3:
                    encodedLanguageViews.writeInt(key);
                    encodedLanguageViews.writeStartArray(value.costs().length);
                    for (const cost of value.costs()) {
                        encodedLanguageViews.writeInt(cost);
                    }
                    break;
                default:
                    throw new util_1.InvalidStateError('Invalid plutus language version.');
            }
        }
        return encodedLanguageViews.encodeAsHex();
    }
}
exports.Costmdls = Costmdls;
_Costmdls_models = new WeakMap(), _Costmdls_originalBytes = new WeakMap();
//# sourceMappingURL=Costmdls.js.map