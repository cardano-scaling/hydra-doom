"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tokenTransferInspector = void 0;
const txInspector_1 = require("./txInspector");
const errors_1 = require("../errors");
const coalesceValueQuantities_1 = require("./coalesceValueQuantities");
const promiseTimeout_1 = require("./promiseTimeout");
const subtractValueQuantities_1 = require("./subtractValueQuantities");
const tryGetAssetInfos_1 = require("./tryGetAssetInfos");
const uniq_js_1 = __importDefault(require("lodash/uniq.js"));
const coalesceByAddress = (elements) => {
    const grouped = elements.reduce((acc, elem) => {
        if (!acc.has(elem.address))
            acc.set(elem.address, []);
        acc.get(elem.address)?.push(elem);
        return acc;
    }, new Map());
    const coalescedByAddress = new Map();
    for (const [address, elem] of grouped) {
        coalescedByAddress.set(address, (0, coalesceValueQuantities_1.coalesceValueQuantities)(elem.map((x) => x.value)));
    }
    return coalescedByAddress;
};
const initializeAddressMap = (addresses) => new Map(addresses.map((address) => [address, { assets: new Map(), coins: 0n }]));
const updateFromAddressMap = (addressMap, key, value) => {
    if (value.coins < 0n) {
        addressMap.get(key).coins = value.coins;
    }
    for (const [assetId, quantity] of value.assets?.entries() ?? [])
        if (quantity < 0n) {
            addressMap.get(key).assets?.set(assetId, quantity);
        }
};
const updateToAddressMap = (addressMap, key, value) => {
    if (value.coins > 0n) {
        addressMap.get(key).coins = value.coins;
    }
    for (const [assetId, quantity] of value.assets?.entries() ?? []) {
        if (quantity > 0n) {
            addressMap.get(key).assets?.set(assetId, quantity);
        }
    }
};
const computeNetDifferences = (inputs, outputs, fromAddress, toAddress) => {
    for (const [key, inputValue] of inputs.entries()) {
        const outputValue = outputs.get(key) ?? { assets: new Map(), coins: 0n };
        const difference = (0, subtractValueQuantities_1.subtractValueQuantities)([outputValue, inputValue]);
        updateFromAddressMap(fromAddress, key, difference);
        updateToAddressMap(toAddress, key, difference);
    }
    for (const [key, outputValue] of outputs.entries()) {
        if (!inputs.has(key)) {
            updateToAddressMap(toAddress, key, outputValue);
        }
    }
};
const removeZeroBalanceEntries = (addressMap) => {
    for (const [key, value] of addressMap.entries()) {
        if (value.coins === 0n && value.assets?.size === 0) {
            addressMap.delete(key);
        }
    }
};
const intoTokenTransferValue = async ({ logger, assetProvider, timeout, addressMap }) => {
    const tokenTransferValue = new Map();
    for (const [address, value] of addressMap.entries()) {
        const coins = value.coins;
        const assetIds = (0, uniq_js_1.default)(value.assets && value.assets.size > 0 ? [...value.assets.keys()] : []);
        const assetInfos = new Map();
        if (assetIds.length > 0) {
            const assets = await (0, tryGetAssetInfos_1.tryGetAssetInfos)({
                assetIds,
                assetProvider,
                logger,
                timeout
            });
            for (const asset of assets) {
                const amount = value.assets?.get(asset.assetId) ?? 0n;
                assetInfos.set(asset.assetId, { amount, assetInfo: asset });
            }
        }
        tokenTransferValue.set(address, {
            assets: assetInfos,
            coins
        });
    }
    return tokenTransferValue;
};
const tokenTransferInspector = ({ inputResolver, fromAddressAssetProvider, toAddressAssetProvider, timeout, logger }) => async (tx) => {
    let resolvedInputs;
    try {
        const inputResolution = await (0, promiseTimeout_1.promiseTimeout)((0, txInspector_1.resolveInputs)(tx.body.inputs, inputResolver), timeout);
        resolvedInputs = inputResolution.resolvedInputs;
    }
    catch (error) {
        if (error instanceof errors_1.TimeoutError) {
            logger.error('Error: Inputs resolution timed out');
        }
        resolvedInputs = [];
    }
    const coalescedInputsByAddress = coalesceByAddress(resolvedInputs);
    const coalescedOutputsByAddress = coalesceByAddress(tx.body.outputs);
    const addresses = (0, uniq_js_1.default)([...coalescedInputsByAddress.keys(), ...coalescedOutputsByAddress.keys()]);
    const fromAddress = initializeAddressMap(addresses);
    const toAddress = initializeAddressMap(addresses);
    computeNetDifferences(coalescedInputsByAddress, coalescedOutputsByAddress, fromAddress, toAddress);
    removeZeroBalanceEntries(fromAddress);
    removeZeroBalanceEntries(toAddress);
    return {
        fromAddress: await intoTokenTransferValue({
            addressMap: fromAddress,
            assetProvider: fromAddressAssetProvider,
            logger,
            timeout
        }),
        toAddress: await intoTokenTransferValue({
            addressMap: toAddress,
            assetProvider: toAddressAssetProvider,
            logger,
            timeout
        })
    };
};
exports.tokenTransferInspector = tokenTransferInspector;
//# sourceMappingURL=tokenTransferInspector.js.map