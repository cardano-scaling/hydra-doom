"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTxInspector = exports.metadataInspector = exports.assetsBurnedInspector = exports.assetsMintedInspector = exports.mintInspector = exports.withdrawalInspector = exports.poolRetirementInspector = exports.poolRegistrationInspector = exports.stakeKeyRegistrationInspector = exports.stakeKeyDeregistrationInspector = exports.delegationInspector = exports.valueReceivedInspector = exports.valueSentInspector = exports.sentInspector = exports.signedCertificatesInspector = exports.getCertificatesByType = exports.totalAddressOutputsValueInspector = exports.totalAddressInputsValueInspector = exports.resolveInputs = void 0;
const Crypto = __importStar(require("@cardano-sdk/crypto"));
const types_1 = require("../Cardano/types");
const util_1 = require("@cardano-sdk/util");
const Address_1 = require("../Cardano/Address");
const coalesceValueQuantities_1 = require("./coalesceValueQuantities");
const nativeScript_1 = require("./nativeScript");
const util_2 = require("../Asset/util");
const subtractValueQuantities_1 = require("./subtractValueQuantities");
const resolveInputs = async (txIns, inputResolver) => {
    const resolvedInputs = [];
    const unresolvedInputs = [];
    for (const input of txIns) {
        const resolvedInput = await inputResolver.resolveInput(input);
        if (resolvedInput) {
            resolvedInputs.push({
                address: resolvedInput.address,
                index: input.index,
                txId: input.txId,
                value: resolvedInput.value
            });
        }
        else {
            unresolvedInputs.push(input);
        }
    }
    return {
        resolvedInputs,
        unresolvedInputs
    };
};
exports.resolveInputs = resolveInputs;
const totalAddressInputsValueInspector = (ownAddresses, inputResolver) => async (tx) => {
    const { resolvedInputs } = await (0, exports.resolveInputs)(tx.body.inputs, inputResolver);
    const receivedInputs = resolvedInputs.filter((input) => (0, Address_1.isAddressWithin)(ownAddresses)(input));
    const receivedInputsValues = receivedInputs.map((input) => input.value);
    return (0, coalesceValueQuantities_1.coalesceValueQuantities)(receivedInputsValues);
};
exports.totalAddressInputsValueInspector = totalAddressInputsValueInspector;
const totalAddressOutputsValueInspector = (ownAddresses) => async (tx) => {
    const receivedOutputs = tx.body.outputs.filter((out) => (0, Address_1.isAddressWithin)(ownAddresses)(out));
    return (0, coalesceValueQuantities_1.coalesceValueQuantities)(receivedOutputs.map((output) => output.value));
};
exports.totalAddressOutputsValueInspector = totalAddressOutputsValueInspector;
const getCertificatesByType = (tx, rewardAccounts, certificateTypes) => {
    if (!tx.body.certificates || tx.body.certificates.length === 0)
        return [];
    const certificates = certificateTypes
        ? tx.body.certificates?.filter((certificate) => (0, types_1.isCertType)(certificate, certificateTypes))
        : tx.body.certificates;
    return certificates.filter((certificate) => {
        if ((0, types_1.isCertType)(certificate, types_1.StakeCredentialCertificateTypes)) {
            const credHash = Crypto.Ed25519KeyHashHex(certificate.stakeCredential.hash);
            return rewardAccounts.some((account) => Address_1.RewardAccount.toHash(account) === credHash);
        }
        if ((0, types_1.isCertType)(certificate, [types_1.CertificateType.PoolRegistration]))
            return rewardAccounts.includes(certificate.poolParameters.rewardAccount);
        return false;
    });
};
exports.getCertificatesByType = getCertificatesByType;
const signedCertificatesInspector = (rewardAccounts, certificateTypes) => async (tx) => (0, exports.getCertificatesByType)(tx, rewardAccounts, certificateTypes);
exports.signedCertificatesInspector = signedCertificatesInspector;
const sentInspector = ({ addresses, rewardAccounts, inputResolver }) => async (tx) => {
    const certificates = rewardAccounts?.length ? await (0, exports.signedCertificatesInspector)(rewardAccounts)(tx) : [];
    let inputs = [];
    if (addresses) {
        const { resolvedInputs } = await (0, exports.resolveInputs)(tx.body.inputs, inputResolver);
        const sentInputs = resolvedInputs.filter((input) => (0, Address_1.isAddressWithin)(addresses)(input));
        inputs = sentInputs.map((input) => ({ address: input.address, index: input.index, txId: input.txId }));
    }
    return {
        certificates,
        inputs
    };
};
exports.sentInspector = sentInspector;
const valueSentInspector = (ownAddresses, inputResolver) => async (tx) => {
    let assets = new Map();
    if ((await (0, exports.sentInspector)({ addresses: ownAddresses, inputResolver })(tx)).inputs.length === 0)
        return { coins: 0n };
    const totalOutputValue = await (0, exports.totalAddressOutputsValueInspector)(ownAddresses)(tx);
    const totalInputValue = await (0, exports.totalAddressInputsValueInspector)(ownAddresses, inputResolver)(tx);
    const diff = (0, subtractValueQuantities_1.subtractValueQuantities)([totalInputValue, totalOutputValue]);
    if (diff.assets)
        assets = (0, util_2.removeNegativesFromTokenMap)(diff.assets);
    return {
        assets: assets.size > 0 ? assets : undefined,
        coins: diff.coins < 0n ? 0n : diff.coins
    };
};
exports.valueSentInspector = valueSentInspector;
const valueReceivedInspector = (ownAddresses, inputResolver) => async (tx) => {
    let assets = new Map();
    const totalOutputValue = await (0, exports.totalAddressOutputsValueInspector)(ownAddresses)(tx);
    const totalInputValue = await (0, exports.totalAddressInputsValueInspector)(ownAddresses, inputResolver)(tx);
    const diff = (0, subtractValueQuantities_1.subtractValueQuantities)([totalOutputValue, totalInputValue]);
    if (diff.assets)
        assets = (0, util_2.removeNegativesFromTokenMap)(diff.assets);
    return {
        assets: assets.size > 0 ? assets : undefined,
        coins: diff.coins < 0n ? 0n : diff.coins
    };
};
exports.valueReceivedInspector = valueReceivedInspector;
const certificateInspector = (type) => async (tx) => tx.body.certificates?.filter((cert) => cert.__typename === type) ?? [];
exports.delegationInspector = certificateInspector(types_1.CertificateType.StakeDelegation);
exports.stakeKeyDeregistrationInspector = certificateInspector(types_1.CertificateType.StakeDeregistration);
exports.stakeKeyRegistrationInspector = certificateInspector(types_1.CertificateType.StakeRegistration);
exports.poolRegistrationInspector = certificateInspector(types_1.CertificateType.PoolRegistration);
exports.poolRetirementInspector = certificateInspector(types_1.CertificateType.PoolRetirement);
const withdrawalInspector = async (tx) => tx.body.withdrawals?.length ? util_1.BigIntMath.sum(tx.body.withdrawals.map(({ quantity }) => quantity)) : 0n;
exports.withdrawalInspector = withdrawalInspector;
const mintInspector = (matchQuantityCriteria) => async (tx) => {
    const assets = [];
    const scriptMap = new Map();
    if (!tx.body.mint)
        return assets;
    const scripts = [...(tx.auxiliaryData?.scripts || []), ...(tx.witness?.scripts || [])];
    for (const script of scripts) {
        switch (script.__type) {
            case types_1.ScriptType.Native: {
                const policyId = (0, nativeScript_1.nativeScriptPolicyId)(script);
                if (scriptMap.has(policyId))
                    continue;
                scriptMap.set(policyId, script);
                break;
            }
            case types_1.ScriptType.Plutus:
            default:
        }
    }
    for (const [key, value] of tx.body.mint.entries()) {
        const [policyId, assetName] = [types_1.AssetId.getPolicyId(key), types_1.AssetId.getAssetName(key)];
        const mintedAsset = {
            assetName,
            fingerprint: types_1.AssetFingerprint.fromParts(policyId, assetName),
            policyId,
            quantity: value,
            script: scriptMap.get(policyId)
        };
        if (matchQuantityCriteria(mintedAsset.quantity))
            assets.push(mintedAsset);
    }
    return assets;
};
exports.mintInspector = mintInspector;
exports.assetsMintedInspector = (0, exports.mintInspector)((quantity) => quantity > 0);
exports.assetsBurnedInspector = (0, exports.mintInspector)((quantity) => quantity < 0);
const metadataInspector = async (tx) => tx.auxiliaryData?.blob ?? new Map();
exports.metadataInspector = metadataInspector;
const createTxInspector = (inspectors) => async (tx) => {
    const results = await Promise.all(Object.entries(inspectors).map(async ([key, inspector]) => {
        const result = await inspector(tx);
        return { key, result };
    }));
    return results.reduce((acc, { key, result }) => {
        acc[key] = result;
        return acc;
    }, {});
};
exports.createTxInspector = createTxInspector;
//# sourceMappingURL=txInspector.js.map