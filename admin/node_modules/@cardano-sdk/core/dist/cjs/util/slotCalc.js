"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.epochSlotsCalcFactory = exports.epochSlotsCalc = exports.createSlotEpochInfoCalc = exports.createSlotTimeCalc = exports.createSlotEpochCalc = exports.EraSummaryError = void 0;
const ts_custom_error_1 = require("ts-custom-error");
const Block_1 = require("../Cardano/types/Block");
const groupBy_js_1 = __importDefault(require("lodash/groupBy.js"));
const last_js_1 = __importDefault(require("lodash/last.js"));
const memoize_js_1 = __importDefault(require("lodash/memoize.js"));
const orderBy_js_1 = __importDefault(require("lodash/orderBy.js"));
class EraSummaryError extends ts_custom_error_1.CustomError {
}
exports.EraSummaryError = EraSummaryError;
const createSlotEpochCalcImpl = (eraSummaries) => {
    const eraSummariesWithoutSkippedEras = Object.values((0, groupBy_js_1.default)(eraSummaries, 'start.slot')).map(last_js_1.default);
    const eraSummariesAsc = (0, orderBy_js_1.default)(eraSummariesWithoutSkippedEras, ({ start }) => start.slot);
    return (slotNo) => {
        const relevantEraSummariesAsc = (0, orderBy_js_1.default)(eraSummariesAsc.filter(({ start }) => start.slot <= slotNo), ({ start }) => start.slot);
        if (relevantEraSummariesAsc.length === 0) {
            throw new EraSummaryError(`No EraSummary for slot ${slotNo} found`);
        }
        let epochNo = 0;
        let currentEraSummary;
        for (let i = 0; i < relevantEraSummariesAsc.length; i++) {
            currentEraSummary = relevantEraSummariesAsc[i];
            const nextEraSummary = relevantEraSummariesAsc[i + 1];
            epochNo += Math.floor(((nextEraSummary?.start.slot || slotNo) - currentEraSummary.start.slot) /
                currentEraSummary.parameters.epochLength);
        }
        return { epochEraSummary: currentEraSummary, epochNo };
    };
};
exports.createSlotEpochCalc = (0, memoize_js_1.default)((eraSummaries) => {
    const calc = createSlotEpochCalcImpl(eraSummaries);
    return (slotNo) => (0, Block_1.EpochNo)(calc(slotNo).epochNo);
});
const createSlotTimeCalc = (eraSummaries) => {
    const eraSummariesWithoutSkippedEras = Object.values((0, groupBy_js_1.default)(eraSummaries, 'start.slot')).map(last_js_1.default);
    const eraSummariesDesc = (0, orderBy_js_1.default)(eraSummariesWithoutSkippedEras, ({ start }) => start.slot, 'desc');
    return (slotNo) => {
        const activeEraSummary = eraSummariesDesc.find(({ start }) => start.slot <= slotNo);
        if (!activeEraSummary) {
            throw new EraSummaryError(`No EraSummary for slot ${slotNo} found`);
        }
        return new Date(activeEraSummary.start.time.getTime() +
            (slotNo - activeEraSummary.start.slot) * activeEraSummary.parameters.slotLength);
    };
};
exports.createSlotTimeCalc = createSlotTimeCalc;
const createSlotEpochInfoCalc = (eraSummaries) => {
    const slotTimeCalc = (0, exports.createSlotTimeCalc)(eraSummaries);
    const epochCalc = createSlotEpochCalcImpl(eraSummaries);
    return (slot) => {
        const { epochNo, epochEraSummary } = epochCalc(slot);
        const firstSlot = epochEraSummary.start.slot +
            Math.floor((slot - epochEraSummary.start.slot) / epochEraSummary.parameters.epochLength) *
                epochEraSummary.parameters.epochLength;
        const lastSlot = firstSlot + epochEraSummary.parameters.epochLength - 1;
        return {
            epochNo: (0, Block_1.EpochNo)(epochNo),
            firstSlot: {
                date: slotTimeCalc((0, Block_1.Slot)(firstSlot)),
                slot: (0, Block_1.Slot)(firstSlot)
            },
            lastSlot: {
                date: slotTimeCalc((0, Block_1.Slot)(lastSlot)),
                slot: (0, Block_1.Slot)(lastSlot)
            }
        };
    };
};
exports.createSlotEpochInfoCalc = createSlotEpochInfoCalc;
const epochSlotsCalcImplementation = (epochNo, eraSummaries) => {
    let atEpoch = 0;
    let atSlot = eraSummaries[0].start.slot;
    let eraSummaryIdx = 0;
    const maxEraSummaryIdx = eraSummaries.length - 1;
    const checkNextEraSummary = () => eraSummaryIdx < maxEraSummaryIdx && atSlot >= eraSummaries[eraSummaryIdx + 1].start.slot;
    const findNextEraSummary = () => {
        while (checkNextEraSummary())
            eraSummaryIdx++;
    };
    findNextEraSummary();
    while (atEpoch !== epochNo) {
        atSlot += eraSummaries[eraSummaryIdx].parameters.epochLength;
        atEpoch++;
        if (checkNextEraSummary())
            findNextEraSummary();
    }
    const eraSummary = eraSummaries[eraSummaryIdx];
    return {
        eraSummary,
        firstSlot: (0, Block_1.Slot)(atSlot),
        lastSlot: (0, Block_1.Slot)(atSlot + eraSummary.parameters.epochLength - 1)
    };
};
exports.epochSlotsCalc = (0, memoize_js_1.default)(epochSlotsCalcImplementation);
exports.epochSlotsCalcFactory = (0, memoize_js_1.default)((provider) => (0, memoize_js_1.default)(async (epochNo) => epochSlotsCalcImplementation(epochNo, await provider.eraSummaries())));
//# sourceMappingURL=slotCalc.js.map