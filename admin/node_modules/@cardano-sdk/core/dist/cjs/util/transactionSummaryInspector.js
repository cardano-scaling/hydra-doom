"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transactionSummaryInspector = exports.getCollateral = void 0;
const Cardano_1 = require("../Cardano");
const txInspector_1 = require("./txInspector");
const util_1 = require("@cardano-sdk/util");
const errors_1 = require("../errors");
const util_2 = require("../Asset/util");
const coalesceValueQuantities_1 = require("./coalesceValueQuantities");
const util_3 = require("../Cardano/util");
const promiseTimeout_1 = require("./promiseTimeout");
const subtractValueQuantities_1 = require("./subtractValueQuantities");
const tryGetAssetInfos_1 = require("./tryGetAssetInfos");
const getCollateral = async (tx, inputResolver, addresses) => {
    if (!tx.body.collaterals || tx.body.collaterals.length === 0)
        return 0n;
    const resolvedCollateralInputs = (await (0, txInspector_1.resolveInputs)(tx.body.collaterals, inputResolver)).resolvedInputs.filter((input) => addresses.includes(input.address));
    const totalOwnedValueAtRisk = util_1.BigIntMath.sum(resolvedCollateralInputs.map(({ value }) => value.coins));
    if (tx.body.collateralReturn) {
        if (!addresses.includes(tx.body.collateralReturn.address))
            return totalOwnedValueAtRisk;
        return util_1.BigIntMath.max([totalOwnedValueAtRisk - tx.body.collateralReturn.value.coins, 0n]) ?? 0n;
    }
    return totalOwnedValueAtRisk;
};
exports.getCollateral = getCollateral;
const totalInputsValue = (resolvedInputs) => {
    const receivedInputsValues = resolvedInputs.resolvedInputs.map((input) => input.value);
    return (0, coalesceValueQuantities_1.coalesceValueQuantities)(receivedInputsValues);
};
const totalOutputsValue = (outputs) => (0, coalesceValueQuantities_1.coalesceValueQuantities)(outputs.map((output) => output.value));
const mintInspectionToTokenMap = (mintedAssets) => new Map(mintedAssets.map((asset) => [Cardano_1.AssetId.fromParts(asset.policyId, asset.assetName), asset.quantity]));
const getImplicitAssets = async (tx) => {
    const mintedAssets = mintInspectionToTokenMap(await (0, txInspector_1.assetsMintedInspector)(tx));
    const burnedAssets = mintInspectionToTokenMap(await (0, txInspector_1.assetsBurnedInspector)(tx));
    return (0, util_2.coalesceTokenMaps)([mintedAssets, burnedAssets]);
};
const getUnaccountedFunds = async (tx, resolvedInputs, implicitCoin, fee, implicitAssets = new Map()) => {
    const totalInputs = totalInputsValue(resolvedInputs);
    const totalOutputs = totalOutputsValue(tx.body.outputs);
    totalInputs.assets = (0, util_2.coalesceTokenMaps)([totalInputs.assets, implicitAssets]);
    totalInputs.coins += implicitCoin;
    totalOutputs.coins += fee;
    return (0, subtractValueQuantities_1.subtractValueQuantities)([totalOutputs, totalInputs]);
};
const intoAssetInfoWithAmount = async ({ assetProvider, logger, timeout, tokenMap }) => {
    if (!tokenMap)
        return new Map();
    const assetIds = tokenMap && tokenMap.size > 0 ? [...tokenMap.keys()] : [];
    const assetInfos = new Map();
    if (assetIds.length > 0) {
        const assets = await (0, tryGetAssetInfos_1.tryGetAssetInfos)({
            assetIds,
            assetProvider,
            logger,
            timeout
        });
        for (const asset of assets) {
            const amount = tokenMap?.get(asset.assetId) ?? 0n;
            assetInfos.set(asset.assetId, { amount, assetInfo: asset });
        }
    }
    return assetInfos;
};
const transactionSummaryInspector = ({ inputResolver, addresses, rewardAccounts, protocolParameters, assetProvider, dRepKeyHash, timeout, logger }) => async (tx) => {
    let resolvedInputs;
    try {
        resolvedInputs = await (0, promiseTimeout_1.promiseTimeout)((0, txInspector_1.resolveInputs)(tx.body.inputs, inputResolver), timeout);
    }
    catch (error) {
        if (error instanceof errors_1.TimeoutError) {
            logger.error('Error: Inputs resolution timed out');
        }
        resolvedInputs = {
            resolvedInputs: [],
            unresolvedInputs: tx.body.inputs
        };
    }
    const fee = tx.body.fee;
    const implicit = (0, util_3.computeImplicitCoin)(protocolParameters, { certificates: tx.body.certificates, withdrawals: tx.body.withdrawals }, rewardAccounts || [], dRepKeyHash);
    const collateral = await (0, exports.getCollateral)(tx, inputResolver, addresses);
    const totalOutputValue = await (0, txInspector_1.totalAddressOutputsValueInspector)(addresses)(tx);
    const totalInputValue = await (0, txInspector_1.totalAddressInputsValueInspector)(addresses, inputResolver)(tx);
    const implicitCoin = (implicit.withdrawals || 0n) + (implicit.reclaimDeposit || 0n) - (implicit.deposit || 0n);
    const implicitAssets = await getImplicitAssets(tx);
    const diff = {
        assets: (0, util_2.subtractTokenMaps)([totalOutputValue.assets, totalInputValue.assets]),
        coins: totalOutputValue.coins - totalInputValue.coins
    };
    return {
        assets: await intoAssetInfoWithAmount({
            assetProvider,
            logger,
            timeout,
            tokenMap: diff.assets
        }),
        coins: diff.coins,
        collateral,
        deposit: implicit.deposit || 0n,
        fee,
        returnedDeposit: implicit.reclaimDeposit || 0n,
        unresolved: {
            inputs: resolvedInputs.unresolvedInputs,
            value: await getUnaccountedFunds(tx, resolvedInputs, implicitCoin, fee, implicitAssets)
        }
    };
};
exports.transactionSummaryInspector = transactionSummaryInspector;
//# sourceMappingURL=transactionSummaryInspector.js.map