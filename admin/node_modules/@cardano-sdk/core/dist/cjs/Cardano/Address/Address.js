"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Address_props;
Object.defineProperty(exports, "__esModule", { value: true });
exports.isAddress = exports.Address = exports.CredentialType = exports.AddressType = void 0;
const BaseEncoding = __importStar(require("@scure/base"));
const BaseAddress_1 = require("./BaseAddress");
const ByronAddress_1 = require("./ByronAddress");
const EnterpriseAddress_1 = require("./EnterpriseAddress");
const util_1 = require("@cardano-sdk/util");
const ChainId_1 = require("../ChainId");
const PointerAddress_1 = require("./PointerAddress");
const RewardAddress_1 = require("./RewardAddress");
const MAX_BECH32_LENGTH_LIMIT = 1023;
var AddressType;
(function (AddressType) {
    AddressType[AddressType["BasePaymentKeyStakeKey"] = 0] = "BasePaymentKeyStakeKey";
    AddressType[AddressType["BasePaymentScriptStakeKey"] = 1] = "BasePaymentScriptStakeKey";
    AddressType[AddressType["BasePaymentKeyStakeScript"] = 2] = "BasePaymentKeyStakeScript";
    AddressType[AddressType["BasePaymentScriptStakeScript"] = 3] = "BasePaymentScriptStakeScript";
    AddressType[AddressType["PointerKey"] = 4] = "PointerKey";
    AddressType[AddressType["PointerScript"] = 5] = "PointerScript";
    AddressType[AddressType["EnterpriseKey"] = 6] = "EnterpriseKey";
    AddressType[AddressType["EnterpriseScript"] = 7] = "EnterpriseScript";
    AddressType[AddressType["Byron"] = 8] = "Byron";
    AddressType[AddressType["RewardKey"] = 14] = "RewardKey";
    AddressType[AddressType["RewardScript"] = 15] = "RewardScript";
})(AddressType = exports.AddressType || (exports.AddressType = {}));
var CredentialType;
(function (CredentialType) {
    CredentialType[CredentialType["KeyHash"] = 0] = "KeyHash";
    CredentialType[CredentialType["ScriptHash"] = 1] = "ScriptHash";
})(CredentialType = exports.CredentialType || (exports.CredentialType = {}));
class Address {
    constructor(props) {
        _Address_props.set(this, void 0);
        __classPrivateFieldSet(this, _Address_props, props, "f");
    }
    static fromBytes(hex) {
        const data = Buffer.from(hex, 'hex');
        const type = data[0] >> 4;
        let address;
        switch (type) {
            case AddressType.BasePaymentKeyStakeKey:
            case AddressType.BasePaymentScriptStakeKey:
            case AddressType.BasePaymentKeyStakeScript:
            case AddressType.BasePaymentScriptStakeScript: {
                address = BaseAddress_1.BaseAddress.unpackParts(type, data);
                break;
            }
            case AddressType.PointerKey:
            case AddressType.PointerScript: {
                address = PointerAddress_1.PointerAddress.unpackParts(type, data);
                break;
            }
            case AddressType.EnterpriseKey:
            case AddressType.EnterpriseScript: {
                address = EnterpriseAddress_1.EnterpriseAddress.unpackParts(type, data);
                break;
            }
            case AddressType.RewardKey:
            case AddressType.RewardScript: {
                address = RewardAddress_1.RewardAddress.unpackParts(type, data);
                break;
            }
            case AddressType.Byron: {
                address = ByronAddress_1.ByronAddress.unpackParts(type, data);
                break;
            }
            default:
                throw new util_1.InvalidArgumentError('data', 'Invalid address raw data');
        }
        return address;
    }
    toBytes() {
        let cborData;
        switch (__classPrivateFieldGet(this, _Address_props, "f").type) {
            case AddressType.BasePaymentKeyStakeKey:
            case AddressType.BasePaymentScriptStakeKey:
            case AddressType.BasePaymentKeyStakeScript:
            case AddressType.BasePaymentScriptStakeScript: {
                cborData = BaseAddress_1.BaseAddress.packParts(__classPrivateFieldGet(this, _Address_props, "f"));
                break;
            }
            case AddressType.PointerKey:
            case AddressType.PointerScript: {
                cborData = PointerAddress_1.PointerAddress.packParts(__classPrivateFieldGet(this, _Address_props, "f"));
                break;
            }
            case AddressType.EnterpriseKey:
            case AddressType.EnterpriseScript: {
                cborData = EnterpriseAddress_1.EnterpriseAddress.packParts(__classPrivateFieldGet(this, _Address_props, "f"));
                break;
            }
            case AddressType.RewardKey:
            case AddressType.RewardScript: {
                cborData = RewardAddress_1.RewardAddress.packParts(__classPrivateFieldGet(this, _Address_props, "f"));
                break;
            }
            case AddressType.Byron: {
                cborData = ByronAddress_1.ByronAddress.packParts(__classPrivateFieldGet(this, _Address_props, "f"));
                break;
            }
            default:
                throw new Error('Invalid address');
        }
        return util_1.HexBlob.fromBytes(cborData);
    }
    static fromBase58(base58Address) {
        return Address.fromBytes(util_1.HexBlob.fromBytes(BaseEncoding.base58.decode(base58Address)));
    }
    toBase58() {
        if (__classPrivateFieldGet(this, _Address_props, "f").type !== AddressType.Byron)
            throw new Error('Only Byron addresses will be encoded in base58');
        return BaseEncoding.base58.encode(Buffer.from(this.toBytes(), 'hex'));
    }
    toBech32() {
        const words = BaseEncoding.bech32.toWords(Buffer.from(this.toBytes(), 'hex'));
        if (__classPrivateFieldGet(this, _Address_props, "f").type === AddressType.Byron)
            throw new Error('Only Shelley addresses will be encoded in bech32');
        const prefix = Address.getBech32Prefix(__classPrivateFieldGet(this, _Address_props, "f").type, __classPrivateFieldGet(this, _Address_props, "f").networkId);
        const bech32Address = BaseEncoding.bech32.encode(prefix, words, MAX_BECH32_LENGTH_LIMIT);
        return __classPrivateFieldGet(this, _Address_props, "f").type === AddressType.RewardKey || __classPrivateFieldGet(this, _Address_props, "f").type === AddressType.RewardScript
            ? bech32Address
            : bech32Address;
    }
    static fromBech32(bech32) {
        const { words } = BaseEncoding.bech32.decode(bech32, MAX_BECH32_LENGTH_LIMIT);
        return Address.fromBytes(util_1.HexBlob.fromBytes(BaseEncoding.bech32.fromWords(words)));
    }
    static fromString(address) {
        try {
            if (Address.isValidBech32(address))
                return Address.fromBech32(address);
            if (Address.isValidByron(address))
                return Address.fromBase58(address);
            return Address.fromBytes((0, util_1.HexBlob)(address));
        }
        catch {
        }
        return null;
    }
    static isValidBech32(bech32) {
        try {
            Address.fromBech32(bech32);
        }
        catch {
            return false;
        }
        return true;
    }
    static isValidByron(base58) {
        try {
            const addr = Address.fromBase58(base58);
            if (__classPrivateFieldGet(addr, _Address_props, "f").type !== AddressType.Byron)
                return false;
        }
        catch {
            return false;
        }
        return true;
    }
    static isValid(address) {
        return Address.isValidBech32(address) || Address.isValidByron(address);
    }
    asByron() {
        return ByronAddress_1.ByronAddress.fromAddress(this);
    }
    asReward() {
        return RewardAddress_1.RewardAddress.fromAddress(this);
    }
    asPointer() {
        return PointerAddress_1.PointerAddress.fromAddress(this);
    }
    asEnterprise() {
        return EnterpriseAddress_1.EnterpriseAddress.fromAddress(this);
    }
    asBase() {
        return BaseAddress_1.BaseAddress.fromAddress(this);
    }
    getType() {
        return __classPrivateFieldGet(this, _Address_props, "f").type;
    }
    getNetworkId() {
        if (__classPrivateFieldGet(this, _Address_props, "f").type === AddressType.Byron) {
            if (__classPrivateFieldGet(this, _Address_props, "f").byronAddressContent?.attrs.magic === undefined)
                return ChainId_1.NetworkId.Mainnet;
            return ChainId_1.NetworkId.Testnet;
        }
        return __classPrivateFieldGet(this, _Address_props, "f").networkId;
    }
    getProps() {
        return __classPrivateFieldGet(this, _Address_props, "f");
    }
    static getBech32Prefix(type, networkId) {
        let prefix = '';
        switch (type) {
            case AddressType.BasePaymentKeyStakeKey:
            case AddressType.BasePaymentScriptStakeKey:
            case AddressType.BasePaymentKeyStakeScript:
            case AddressType.BasePaymentScriptStakeScript:
            case AddressType.PointerKey:
            case AddressType.PointerScript:
            case AddressType.EnterpriseKey:
            case AddressType.EnterpriseScript:
                prefix = 'addr';
                break;
            case AddressType.RewardKey:
            case AddressType.RewardScript: {
                prefix = 'stake';
                break;
            }
            default:
                throw new Error('Invalid address');
        }
        prefix += networkId === 0 ? '_test' : '';
        return prefix;
    }
}
exports.Address = Address;
_Address_props = new WeakMap();
const isAddress = (input) => Address.isValid(input);
exports.isAddress = isAddress;
//# sourceMappingURL=Address.js.map