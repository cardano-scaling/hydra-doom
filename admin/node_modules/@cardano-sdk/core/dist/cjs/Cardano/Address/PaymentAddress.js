"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addressNetworkId = exports.inputsWithAddresses = exports.isAddressWithin = exports.PaymentAddress = exports.isRewardAccount = void 0;
const Address_1 = require("./Address");
const DRepID_1 = require("./DRepID");
const util_1 = require("@cardano-sdk/util");
const isRewardAccount = (address) => {
    try {
        (0, util_1.assertIsBech32WithPrefix)(address, ['stake', 'stake_test']);
        return true;
    }
    catch {
        return false;
    }
};
exports.isRewardAccount = isRewardAccount;
const PaymentAddress = (value) => {
    if (Address_1.Address.isValid(value)) {
        if ((0, exports.isRewardAccount)(value) || DRepID_1.DRepID.isValid(value)) {
            throw new util_1.InvalidStringError(value, 'Address type can only be used for payment addresses');
        }
        return value;
    }
    try {
        (0, util_1.assertIsHexString)(value);
    }
    catch {
        throw new util_1.InvalidStringError(value, 'Expected payment address as bech32, base58 or hex-encoded bytes');
    }
    const address = Address_1.Address.fromBytes(util_1.HexBlob.fromBytes(Buffer.from(value, 'hex')));
    return (address.getType() === Address_1.AddressType.Byron ? address.toBase58() : address.toBech32());
};
exports.PaymentAddress = PaymentAddress;
const isAddressWithin = (addresses) => ({ address }) => addresses.includes(address);
exports.isAddressWithin = isAddressWithin;
const inputsWithAddresses = (tx, ownAddresses) => tx.body.inputs.filter((0, exports.isAddressWithin)(ownAddresses));
exports.inputsWithAddresses = inputsWithAddresses;
const addressNetworkId = (address) => {
    const addr = Address_1.Address.fromString(address);
    return addr.getNetworkId();
};
exports.addressNetworkId = addressNetworkId;
//# sourceMappingURL=PaymentAddress.js.map