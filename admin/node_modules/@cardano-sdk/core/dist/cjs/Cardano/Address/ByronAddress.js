"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ByronAddress_type, _ByronAddress_content;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ByronAddress = exports.ByronAddressType = void 0;
const Address_1 = require("./Address");
const Serialization_1 = require("../../Serialization");
const crypto_1 = require("@cardano-sdk/crypto");
const util_1 = require("@cardano-sdk/util");
const crc_1 = require("@foxglove/crc");
var ByronAddressType;
(function (ByronAddressType) {
    ByronAddressType[ByronAddressType["PubKey"] = 0] = "PubKey";
    ByronAddressType[ByronAddressType["Script"] = 1] = "Script";
    ByronAddressType[ByronAddressType["Redeem"] = 2] = "Redeem";
})(ByronAddressType = exports.ByronAddressType || (exports.ByronAddressType = {}));
class ByronAddress {
    constructor(props) {
        _ByronAddress_type.set(this, void 0);
        _ByronAddress_content.set(this, void 0);
        __classPrivateFieldSet(this, _ByronAddress_content, props.byronAddressContent, "f");
        __classPrivateFieldSet(this, _ByronAddress_type, props.type, "f");
    }
    static fromCredentials(root, attrs, type) {
        return new ByronAddress({
            byronAddressContent: {
                attrs,
                root,
                type
            },
            type: Address_1.AddressType.Byron
        });
    }
    getAttributes() {
        return __classPrivateFieldGet(this, _ByronAddress_content, "f").attrs;
    }
    getRoot() {
        return __classPrivateFieldGet(this, _ByronAddress_content, "f").root;
    }
    getByronAddressType() {
        return __classPrivateFieldGet(this, _ByronAddress_content, "f").type;
    }
    toAddress() {
        return new Address_1.Address({
            byronAddressContent: __classPrivateFieldGet(this, _ByronAddress_content, "f"),
            type: __classPrivateFieldGet(this, _ByronAddress_type, "f")
        });
    }
    static fromAddress(addr) {
        return addr.getProps().type === Address_1.AddressType.Byron ? new ByronAddress(addr.getProps()) : undefined;
    }
    static packParts(props) {
        const { root, attrs, type } = props.byronAddressContent;
        let mapSize = 0;
        if (attrs.derivationPath)
            ++mapSize;
        if (attrs.magic)
            ++mapSize;
        const writer = new Serialization_1.CborWriter();
        writer.writeStartArray(3);
        writer.writeByteString(Buffer.from(root, 'hex'));
        writer.writeStartMap(mapSize);
        if (attrs.derivationPath) {
            const encodedPathCbor = new Serialization_1.CborWriter().writeByteString(Buffer.from(attrs.derivationPath, 'hex')).encode();
            writer.writeInt(1);
            writer.writeByteString(encodedPathCbor);
        }
        if (attrs.magic) {
            const encodedMagicCbor = new Serialization_1.CborWriter().writeInt(attrs.magic).encode();
            writer.writeInt(2);
            writer.writeByteString(encodedMagicCbor);
        }
        writer.writeInt(type);
        const addressDataEncoded = Buffer.from(writer.encodeAsHex(), 'hex');
        writer.reset();
        writer.writeStartArray(2);
        writer.writeTag(Serialization_1.CborTag.EncodedCborDataItem);
        writer.writeByteString(addressDataEncoded);
        writer.writeInt((0, crc_1.crc32)(addressDataEncoded));
        return writer.encode();
    }
    static unpackParts(type, data) {
        let reader = new Serialization_1.CborReader(util_1.HexBlob.fromBytes(data));
        reader.readStartArray();
        reader.readTag();
        const addressDataEncoded = reader.readByteString();
        if (Number(reader.readInt()) !== (0, crc_1.crc32)(addressDataEncoded))
            throw new util_1.InvalidArgumentError('data', 'Invalid Byron raw data. Checksum doesnt match.');
        reader = new Serialization_1.CborReader(util_1.HexBlob.fromBytes(addressDataEncoded));
        reader.readStartArray();
        const root = (0, crypto_1.Hash28ByteBase16)(Buffer.from(reader.readByteString()).toString('hex'));
        reader.readStartMap();
        let magic;
        let derivationPath;
        while (reader.peekState() !== Serialization_1.CborReaderState.EndMap) {
            const key = reader.readInt();
            switch (key) {
                case 1n: {
                    const cborBytes = reader.readByteString();
                    derivationPath = util_1.HexBlob.fromBytes(new Serialization_1.CborReader(util_1.HexBlob.fromBytes(cborBytes)).readByteString());
                    break;
                }
                case 2n: {
                    const cborBytes = reader.readByteString();
                    magic = Number(new Serialization_1.CborReader(util_1.HexBlob.fromBytes(cborBytes)).readInt());
                    break;
                }
            }
        }
        reader.readEndMap();
        const byronAddressType = Number(reader.readInt());
        return new Address_1.Address({
            byronAddressContent: {
                attrs: { derivationPath, magic },
                root,
                type: byronAddressType
            },
            type
        });
    }
}
exports.ByronAddress = ByronAddress;
_ByronAddress_type = new WeakMap(), _ByronAddress_content = new WeakMap();
//# sourceMappingURL=ByronAddress.js.map