import { bech32 } from 'bech32';
import { InvalidStringError } from './errors.js';
const MAX_BECH32_LENGTH_LIMIT = 1023;
const isOneOf = (target, options) => (Array.isArray(options) && options.includes(target)) || target === options;
export const assertIsBech32WithPrefix = (target, prefix, expectedDecodedLength) => {
    let decoded;
    try {
        decoded = bech32.decode(target, MAX_BECH32_LENGTH_LIMIT);
    }
    catch (error) {
        throw new InvalidStringError(`expected bech32-encoded string with '${prefix}' prefix`, error);
    }
    if (!isOneOf(decoded.prefix, prefix)) {
        throw new InvalidStringError(`expected bech32 prefix '${prefix}', got '${decoded.prefix}''`);
    }
    if (expectedDecodedLength && !isOneOf(decoded.words.length, expectedDecodedLength)) {
        throw new InvalidStringError(`expected decoded length of '${expectedDecodedLength}', got '${decoded.words.length}'`);
    }
};
export const typedBech32 = (target, prefix, expectedDecodedLength) => {
    assertIsBech32WithPrefix(target, prefix, expectedDecodedLength);
    return target;
};
const assertLength = (expectedLength, target) => {
    if (expectedLength && target.length !== expectedLength) {
        throw new InvalidStringError(`expected length '${expectedLength}', got ${target.length}`);
    }
};
export const assertIsHexString = (target, expectedLength) => {
    assertLength(expectedLength, target);
    if (target.length > 0 && !/^[\da-f]+$/i.test(target)) {
        throw new InvalidStringError('expected hex string');
    }
};
export const typedHex = (value, length) => {
    assertIsHexString(value, length);
    return value;
};
export const Base64Blob = (target) => {
    if (/^(?:[\d+/a-z]{4})*(?:[\d+/a-z]{2}==|[\d+/a-z]{3}=)?$/i.test(target)) {
        return target;
    }
    throw new InvalidStringError('expected base64 string');
};
Base64Blob.fromBytes = (bytes) => Buffer.from(bytes).toString('base64');
export const HexBlob = (target) => typedHex(target);
HexBlob.fromBytes = (bytes) => Buffer.from(bytes).toString('hex');
HexBlob.fromBase64 = (rawData) => Buffer.from(rawData, 'base64').toString('hex');
HexBlob.toTypedBech32 = (prefix, hexString) => bech32.encode(prefix, bech32.toWords(Uint8Array.from(Buffer.from(hexString, 'hex'))));
export const castHexBlob = (target, expectedLength) => {
    assertLength(expectedLength, target);
    return target;
};
//# sourceMappingURL=primitives.js.map