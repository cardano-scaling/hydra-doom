"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromSerializableObject = exports.toSerializableObject = void 0;
const serialize_error_1 = require("serialize-error");
const transform_js_1 = __importDefault(require("lodash/transform.js"));
const PLAIN_TYPES = new Set(['boolean', 'number', 'string']);
const matchPrototype = (errorTypes, error) => {
    if (typeof error === 'object' && error !== null) {
        for (let ErrorType of errorTypes) {
            if (error.name === ErrorType.name) {
                return ErrorType.prototype;
            }
            ErrorType = Object.getPrototypeOf(ErrorType.prototype)?.constructor;
        }
    }
    return Error.prototype;
};
const defaultTransformKey = (key) => key;
const defaultTransformationTypeKey = '__type';
const hasInnerError = (error) => error !== null && typeof error === 'object' && 'innerError' in error;
const innerErrorHasData = (innerError) => typeof innerError === 'object' && innerError !== null && 'data' in innerError;
const toSerializableObject = (obj, options = {}) => {
    if (PLAIN_TYPES.has(typeof obj))
        return obj;
    const { transformationTypeKey = defaultTransformationTypeKey, serializeKey = defaultTransformKey } = options;
    if (typeof obj === 'undefined') {
        return {
            [transformationTypeKey]: 'undefined'
        };
    }
    if (typeof obj === 'object') {
        if (obj === null)
            return null;
        if (Array.isArray(obj)) {
            return obj.map((item) => (0, exports.toSerializableObject)(item, options));
        }
        if (ArrayBuffer.isView(obj)) {
            const arr = new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength / Uint8Array.BYTES_PER_ELEMENT);
            const value = Buffer.from(arr).toString('hex');
            return { [transformationTypeKey]: 'Buffer', value };
        }
        if (obj instanceof Error) {
            if (hasInnerError(obj) && innerErrorHasData(obj.innerError)) {
                obj.innerError.data = (0, exports.toSerializableObject)(obj.innerError.data);
            }
            return {
                [transformationTypeKey]: 'Error',
                value: (0, serialize_error_1.serializeError)(obj)
            };
        }
        if (obj instanceof Date) {
            return {
                [transformationTypeKey]: 'Date',
                value: obj.getTime()
            };
        }
        if (obj instanceof Set) {
            return {
                [transformationTypeKey]: 'Set',
                value: [...obj].map((item) => (0, exports.toSerializableObject)(item, options))
            };
        }
        if (obj instanceof Map) {
            return {
                [transformationTypeKey]: 'Map',
                value: [...obj.entries()].map(([key, value]) => [
                    (0, exports.toSerializableObject)(key, options),
                    (0, exports.toSerializableObject)(value, options)
                ])
            };
        }
        return (0, transform_js_1.default)(obj, (result, value, key) => {
            result[serializeKey(key)] = (0, exports.toSerializableObject)(value, options);
            return result;
        }, {});
    }
    if (typeof obj === 'bigint')
        return {
            [transformationTypeKey]: 'bigint',
            value: obj.toString()
        };
};
exports.toSerializableObject = toSerializableObject;
const fromSerializableObjectUnknown = (obj, options = {}) => {
    if (PLAIN_TYPES.has(typeof obj))
        return obj;
    if (typeof obj === 'object') {
        if (obj === null)
            return null;
        if (Array.isArray(obj)) {
            return obj.map((item) => fromSerializableObjectUnknown(item, options));
        }
        const { transformationTypeKey = defaultTransformationTypeKey, deserializeKey = defaultTransformKey, errorTypes = [] } = options;
        const docAsAny = obj;
        switch (docAsAny[transformationTypeKey]) {
            case 'undefined':
                return undefined;
            case 'bigint':
                return BigInt(docAsAny.value);
            case 'Buffer':
                return new Uint8Array(Buffer.from(docAsAny.value, 'hex'));
            case 'Date':
                return new Date(docAsAny.value);
            case 'Set':
                return new Set(docAsAny.value.map((item) => fromSerializableObjectUnknown(item, options)));
            case 'Map':
                return new Map(docAsAny.value.map((keyValues) => keyValues.map((kv) => fromSerializableObjectUnknown(kv, options))));
            case 'Error': {
                const error = fromSerializableObjectUnknown(docAsAny.value, options);
                return Object.setPrototypeOf(error, matchPrototype(errorTypes, error));
            }
            default:
                return (0, transform_js_1.default)(obj, (result, value, key) => {
                    result[deserializeKey(key)] = fromSerializableObjectUnknown(value, options);
                    return result;
                }, {});
        }
    }
};
const fromSerializableObject = (serializableObject, options) => fromSerializableObjectUnknown(serializableObject, options);
exports.fromSerializableObject = fromSerializableObject;
//# sourceMappingURL=serializableObject.js.map