"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InvalidStateError = exports.InvalidArgumentError = exports.InvalidStringError = exports.ComposableError = exports.stripStackTrace = exports.formatErrorMessage = void 0;
const ts_custom_error_1 = require("ts-custom-error");
const formatErrorMessage = (reason, detail) => reason + (detail ? ` (${detail})` : '');
exports.formatErrorMessage = formatErrorMessage;
const isWithInnerError = (error) => error !== null && typeof error === 'object' && 'innerError' in error;
const isErrorLike = (error) => {
    if (!error || typeof error !== 'object' || !('message' in error && 'stack' in error))
        return false;
    const { message, stack } = error;
    return typeof message === 'string' && typeof stack === 'string';
};
const stripStackTrace = (error) => {
    if (!error)
        return;
    if (isErrorLike(error)) {
        delete error.stack;
    }
    if (isWithInnerError(error)) {
        (0, exports.stripStackTrace)(error.innerError);
    }
};
exports.stripStackTrace = stripStackTrace;
class ComposableError extends ts_custom_error_1.CustomError {
    constructor(message, innerError) {
        let firstLineOfInnerErrorStack = '';
        let innerErrorStack = [];
        if (isErrorLike(innerError) && innerError.stack) {
            [firstLineOfInnerErrorStack, ...innerErrorStack] = innerError.stack.split(ComposableError.stackDelimiter);
            message = `${message} due to\n ${firstLineOfInnerErrorStack}`;
        }
        if (typeof innerError === 'string')
            message = `${message} due to\n ${innerError}`;
        super(message);
        this.innerError = innerError;
        if (!this.stack || innerErrorStack.length === 0)
            return;
        const [firstLineOfStack] = this.stack.split(ComposableError.stackDelimiter);
        Object.defineProperty(this, 'stack', {
            configurable: true,
            value: `${firstLineOfStack}${innerErrorStack.join(ComposableError.stackDelimiter)}`
        });
    }
}
exports.ComposableError = ComposableError;
ComposableError.stackDelimiter = '\n    at ';
class InvalidStringError extends ComposableError {
    constructor(expectation, innerError) {
        super(`Invalid string: "${expectation}"`, innerError);
    }
}
exports.InvalidStringError = InvalidStringError;
class InvalidArgumentError extends ts_custom_error_1.CustomError {
    constructor(argName, message) {
        super(`Invalid argument '${argName}': ${message}`);
    }
}
exports.InvalidArgumentError = InvalidArgumentError;
class InvalidStateError extends ts_custom_error_1.CustomError {
    constructor(message) {
        super(`Invalid state': ${message}`);
    }
}
exports.InvalidStateError = InvalidStateError;
//# sourceMappingURL=errors.js.map