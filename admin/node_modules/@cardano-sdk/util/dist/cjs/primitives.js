"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.castHexBlob = exports.HexBlob = exports.Base64Blob = exports.typedHex = exports.assertIsHexString = exports.typedBech32 = exports.assertIsBech32WithPrefix = void 0;
const bech32_1 = require("bech32");
const errors_1 = require("./errors");
const MAX_BECH32_LENGTH_LIMIT = 1023;
const isOneOf = (target, options) => (Array.isArray(options) && options.includes(target)) || target === options;
const assertIsBech32WithPrefix = (target, prefix, expectedDecodedLength) => {
    let decoded;
    try {
        decoded = bech32_1.bech32.decode(target, MAX_BECH32_LENGTH_LIMIT);
    }
    catch (error) {
        throw new errors_1.InvalidStringError(`expected bech32-encoded string with '${prefix}' prefix`, error);
    }
    if (!isOneOf(decoded.prefix, prefix)) {
        throw new errors_1.InvalidStringError(`expected bech32 prefix '${prefix}', got '${decoded.prefix}''`);
    }
    if (expectedDecodedLength && !isOneOf(decoded.words.length, expectedDecodedLength)) {
        throw new errors_1.InvalidStringError(`expected decoded length of '${expectedDecodedLength}', got '${decoded.words.length}'`);
    }
};
exports.assertIsBech32WithPrefix = assertIsBech32WithPrefix;
const typedBech32 = (target, prefix, expectedDecodedLength) => {
    (0, exports.assertIsBech32WithPrefix)(target, prefix, expectedDecodedLength);
    return target;
};
exports.typedBech32 = typedBech32;
const assertLength = (expectedLength, target) => {
    if (expectedLength && target.length !== expectedLength) {
        throw new errors_1.InvalidStringError(`expected length '${expectedLength}', got ${target.length}`);
    }
};
const assertIsHexString = (target, expectedLength) => {
    assertLength(expectedLength, target);
    if (target.length > 0 && !/^[\da-f]+$/i.test(target)) {
        throw new errors_1.InvalidStringError('expected hex string');
    }
};
exports.assertIsHexString = assertIsHexString;
const typedHex = (value, length) => {
    (0, exports.assertIsHexString)(value, length);
    return value;
};
exports.typedHex = typedHex;
const Base64Blob = (target) => {
    if (/^(?:[\d+/a-z]{4})*(?:[\d+/a-z]{2}==|[\d+/a-z]{3}=)?$/i.test(target)) {
        return target;
    }
    throw new errors_1.InvalidStringError('expected base64 string');
};
exports.Base64Blob = Base64Blob;
exports.Base64Blob.fromBytes = (bytes) => Buffer.from(bytes).toString('base64');
const HexBlob = (target) => (0, exports.typedHex)(target);
exports.HexBlob = HexBlob;
exports.HexBlob.fromBytes = (bytes) => Buffer.from(bytes).toString('hex');
exports.HexBlob.fromBase64 = (rawData) => Buffer.from(rawData, 'base64').toString('hex');
exports.HexBlob.toTypedBech32 = (prefix, hexString) => bech32_1.bech32.encode(prefix, bech32_1.bech32.toWords(Uint8Array.from(Buffer.from(hexString, 'hex'))));
const castHexBlob = (target, expectedLength) => {
    assertLength(expectedLength, target);
    return target;
};
exports.castHexBlob = castHexBlob;
//# sourceMappingURL=primitives.js.map