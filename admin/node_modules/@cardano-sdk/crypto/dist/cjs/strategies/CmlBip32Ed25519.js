"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CmlBip32Ed25519_CML;
Object.defineProperty(exports, "__esModule", { value: true });
exports.CmlBip32Ed25519 = void 0;
const hexTypes_1 = require("../hexTypes");
const util_1 = require("@cardano-sdk/util");
const EXTENDED_KEY_HEX_LENGTH = 128;
class CmlBip32Ed25519 {
    constructor(CML) {
        _CmlBip32Ed25519_CML.set(this, void 0);
        __classPrivateFieldSet(this, _CmlBip32Ed25519_CML, CML, "f");
    }
    fromBip39Entropy(entropy, passphrase) {
        const hexKey = (0, util_1.usingAutoFree)((scope) => {
            const cmlKey = scope.manage(__classPrivateFieldGet(this, _CmlBip32Ed25519_CML, "f").Bip32PrivateKey.from_bip39_entropy(entropy, Buffer.from(passphrase)));
            return cmlKey.as_bytes();
        });
        return (0, hexTypes_1.Bip32PrivateKeyHex)(Buffer.from(hexKey).toString('hex'));
    }
    getPublicKey(privateKey) {
        return (0, util_1.usingAutoFree)((scope) => {
            const cmlPrivateKey = privateKey.length === EXTENDED_KEY_HEX_LENGTH
                ? scope.manage(__classPrivateFieldGet(this, _CmlBip32Ed25519_CML, "f").PrivateKey.from_extended_bytes(Buffer.from(privateKey, 'hex')))
                : scope.manage(__classPrivateFieldGet(this, _CmlBip32Ed25519_CML, "f").PrivateKey.from_normal_bytes(Buffer.from(privateKey, 'hex')));
            const pubKeyBytes = scope.manage(cmlPrivateKey.to_public()).as_bytes();
            return Promise.resolve((0, hexTypes_1.Ed25519PublicKeyHex)(Buffer.from(pubKeyBytes).toString('hex')));
        });
    }
    getPubKeyHash(publicKey) {
        return (0, util_1.usingAutoFree)((scope) => {
            const cmlPubKey = scope.manage(__classPrivateFieldGet(this, _CmlBip32Ed25519_CML, "f").PublicKey.from_bytes(Buffer.from(publicKey, 'hex')));
            const keyHash = scope.manage(cmlPubKey.hash()).to_bytes();
            return Promise.resolve((0, hexTypes_1.Ed25519KeyHashHex)(Buffer.from(keyHash).toString('hex')));
        });
    }
    getRawPrivateKey(bip32PrivateKey) {
        return (0, util_1.usingAutoFree)((scope) => {
            const cmlPrivateKey = scope.manage(__classPrivateFieldGet(this, _CmlBip32Ed25519_CML, "f").Bip32PrivateKey.from_bytes(Buffer.from(bip32PrivateKey, 'hex')));
            const bytes = scope.manage(cmlPrivateKey.to_raw_key()).as_bytes();
            return Promise.resolve((0, hexTypes_1.Ed25519PrivateExtendedKeyHex)(Buffer.from(bytes).toString('hex')));
        });
    }
    getRawPublicKey(bip32PublicKey) {
        return (0, util_1.usingAutoFree)((scope) => {
            const cmlPublicKey = scope.manage(__classPrivateFieldGet(this, _CmlBip32Ed25519_CML, "f").Bip32PublicKey.from_bytes(Buffer.from(bip32PublicKey, 'hex')));
            const bytes = scope.manage(cmlPublicKey.to_raw_key()).as_bytes();
            return Promise.resolve((0, hexTypes_1.Ed25519PublicKeyHex)(Buffer.from(bytes).toString('hex')));
        });
    }
    getBip32PublicKey(privateKey) {
        return (0, util_1.usingAutoFree)((scope) => {
            const cmlPrivateKey = scope.manage(__classPrivateFieldGet(this, _CmlBip32Ed25519_CML, "f").Bip32PrivateKey.from_bytes(Buffer.from(privateKey, 'hex')));
            const pubKeyBytes = scope.manage(cmlPrivateKey.to_public()).as_bytes();
            return Promise.resolve((0, hexTypes_1.Bip32PublicKeyHex)(Buffer.from(pubKeyBytes).toString('hex')));
        });
    }
    derivePrivateKey(parentKey, derivationIndices) {
        return (0, util_1.usingAutoFree)((scope) => {
            let cmlKey = scope.manage(__classPrivateFieldGet(this, _CmlBip32Ed25519_CML, "f").Bip32PrivateKey.from_bytes(Buffer.from(parentKey, 'hex')));
            for (const index of derivationIndices) {
                cmlKey = scope.manage(cmlKey.derive(index));
            }
            return Promise.resolve((0, hexTypes_1.Bip32PrivateKeyHex)(Buffer.from(cmlKey.as_bytes()).toString('hex')));
        });
    }
    derivePublicKey(parentKey, derivationIndices) {
        return (0, util_1.usingAutoFree)((scope) => {
            let cmlKey = scope.manage(__classPrivateFieldGet(this, _CmlBip32Ed25519_CML, "f").Bip32PublicKey.from_bytes(Buffer.from(parentKey, 'hex')));
            for (const index of derivationIndices) {
                cmlKey = scope.manage(cmlKey.derive(index));
            }
            return Promise.resolve((0, hexTypes_1.Bip32PublicKeyHex)(Buffer.from(cmlKey.as_bytes()).toString('hex')));
        });
    }
    async sign(privateKey, message) {
        return (0, util_1.usingAutoFree)((scope) => {
            const cmlPrivateKey = privateKey.length === EXTENDED_KEY_HEX_LENGTH
                ? scope.manage(__classPrivateFieldGet(this, _CmlBip32Ed25519_CML, "f").PrivateKey.from_extended_bytes(Buffer.from(privateKey, 'hex')))
                : scope.manage(__classPrivateFieldGet(this, _CmlBip32Ed25519_CML, "f").PrivateKey.from_normal_bytes(Buffer.from(privateKey, 'hex')));
            const signature = scope.manage(cmlPrivateKey.sign(Buffer.from(message, 'hex'))).to_bytes();
            return Promise.resolve((0, hexTypes_1.Ed25519SignatureHex)(Buffer.from(signature).toString('hex')));
        });
    }
    async verify(signature, message, publicKey) {
        return (0, util_1.usingAutoFree)((scope) => {
            const cmlKey = scope.manage(__classPrivateFieldGet(this, _CmlBip32Ed25519_CML, "f").PublicKey.from_bytes(Buffer.from(publicKey, 'hex')));
            const cmlSignature = scope.manage(__classPrivateFieldGet(this, _CmlBip32Ed25519_CML, "f").Ed25519Signature.from_bytes(Buffer.from(signature, 'hex')));
            return Promise.resolve(cmlKey.verify(Buffer.from(message, 'hex'), cmlSignature));
        });
    }
}
exports.CmlBip32Ed25519 = CmlBip32Ed25519;
_CmlBip32Ed25519_CML = new WeakMap();
//# sourceMappingURL=CmlBip32Ed25519.js.map