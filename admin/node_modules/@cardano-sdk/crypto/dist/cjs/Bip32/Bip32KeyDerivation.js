"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.derivePublic = exports.derivePrivate = void 0;
const util_1 = require("@cardano-sdk/util");
const arithmetic_1 = require("./arithmetic");
const libsodium_wrappers_sumo_1 = __importDefault(require("libsodium-wrappers-sumo"));
const isHardenedDerivation = (index) => index >= 2147483648;
const deriveHardened = (index, scalar, iv, chainCode) => {
    const data = Buffer.allocUnsafe(1 + 64 + 4);
    data.writeUInt32LE(index, 1 + 64);
    scalar.copy(data, 1);
    iv.copy(data, 1 + 32);
    data[0] = 0x00;
    const zMac = libsodium_wrappers_sumo_1.default.crypto_auth_hmacsha512(data, chainCode);
    data[0] = 0x01;
    const ccMac = libsodium_wrappers_sumo_1.default.crypto_auth_hmacsha512(data, chainCode);
    return { ccMac, zMac };
};
const deriveSoft = (index, scalar, chainCode) => {
    const data = Buffer.allocUnsafe(1 + 32 + 4);
    data.writeUInt32LE(index, 1 + 32);
    const vk = Buffer.from(libsodium_wrappers_sumo_1.default.crypto_scalarmult_ed25519_base_noclamp(scalar));
    vk.copy(data, 1);
    data[0] = 0x02;
    const zMac = libsodium_wrappers_sumo_1.default.crypto_auth_hmacsha512(data, chainCode);
    data[0] = 0x03;
    const ccMac = libsodium_wrappers_sumo_1.default.crypto_auth_hmacsha512(data, chainCode);
    return { ccMac, zMac };
};
const pointOfTrunc28Mul8 = (sk) => {
    const scalar = (0, arithmetic_1.add28Mul8)(new Uint8Array(32).fill(0), sk);
    return libsodium_wrappers_sumo_1.default.crypto_scalarmult_ed25519_base_noclamp(scalar);
};
const derivePrivate = (key, index) => {
    const kl = key.subarray(0, 32);
    const kr = key.subarray(32, 64);
    const cc = key.subarray(64, 96);
    const { ccMac, zMac } = isHardenedDerivation(index) ? deriveHardened(index, kl, kr, cc) : deriveSoft(index, kl, cc);
    const chainCode = ccMac.slice(32, 64);
    const zl = zMac.slice(0, 32);
    const zr = zMac.slice(32, 64);
    const left = (0, arithmetic_1.add28Mul8)(kl, zl);
    const right = (0, arithmetic_1.add256bits)(kr, zr);
    return Buffer.concat([left, right, chainCode]);
};
exports.derivePrivate = derivePrivate;
const derivePublic = (key, index) => {
    const pk = key.subarray(0, 32);
    const cc = key.subarray(32, 64);
    const data = Buffer.allocUnsafe(1 + 32 + 4);
    data.writeUInt32LE(index, 1 + 32);
    if (isHardenedDerivation(index))
        throw new util_1.InvalidArgumentError('index', 'Public key can not be derived from a hardened index.');
    pk.copy(data, 1);
    data[0] = 0x02;
    const z = libsodium_wrappers_sumo_1.default.crypto_auth_hmacsha512(data, cc);
    data[0] = 0x03;
    const c = libsodium_wrappers_sumo_1.default.crypto_auth_hmacsha512(data, cc);
    const chainCode = c.slice(32, 64);
    const zl = z.slice(0, 32);
    const p = pointOfTrunc28Mul8(zl);
    return Buffer.concat([libsodium_wrappers_sumo_1.default.crypto_core_ed25519_add(p, pk), chainCode]);
};
exports.derivePublic = derivePublic;
//# sourceMappingURL=Bip32KeyDerivation.js.map