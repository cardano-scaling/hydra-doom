import { InvalidArgumentError } from '@cardano-sdk/util';
import { add256bits, add28Mul8 } from './arithmetic.js';
import sodium from 'libsodium-wrappers-sumo';
const isHardenedDerivation = (index) => index >= 2147483648;
const deriveHardened = (index, scalar, iv, chainCode) => {
    const data = Buffer.allocUnsafe(1 + 64 + 4);
    data.writeUInt32LE(index, 1 + 64);
    scalar.copy(data, 1);
    iv.copy(data, 1 + 32);
    data[0] = 0x00;
    const zMac = sodium.crypto_auth_hmacsha512(data, chainCode);
    data[0] = 0x01;
    const ccMac = sodium.crypto_auth_hmacsha512(data, chainCode);
    return { ccMac, zMac };
};
const deriveSoft = (index, scalar, chainCode) => {
    const data = Buffer.allocUnsafe(1 + 32 + 4);
    data.writeUInt32LE(index, 1 + 32);
    const vk = Buffer.from(sodium.crypto_scalarmult_ed25519_base_noclamp(scalar));
    vk.copy(data, 1);
    data[0] = 0x02;
    const zMac = sodium.crypto_auth_hmacsha512(data, chainCode);
    data[0] = 0x03;
    const ccMac = sodium.crypto_auth_hmacsha512(data, chainCode);
    return { ccMac, zMac };
};
const pointOfTrunc28Mul8 = (sk) => {
    const scalar = add28Mul8(new Uint8Array(32).fill(0), sk);
    return sodium.crypto_scalarmult_ed25519_base_noclamp(scalar);
};
export const derivePrivate = (key, index) => {
    const kl = key.subarray(0, 32);
    const kr = key.subarray(32, 64);
    const cc = key.subarray(64, 96);
    const { ccMac, zMac } = isHardenedDerivation(index) ? deriveHardened(index, kl, kr, cc) : deriveSoft(index, kl, cc);
    const chainCode = ccMac.slice(32, 64);
    const zl = zMac.slice(0, 32);
    const zr = zMac.slice(32, 64);
    const left = add28Mul8(kl, zl);
    const right = add256bits(kr, zr);
    return Buffer.concat([left, right, chainCode]);
};
export const derivePublic = (key, index) => {
    const pk = key.subarray(0, 32);
    const cc = key.subarray(32, 64);
    const data = Buffer.allocUnsafe(1 + 32 + 4);
    data.writeUInt32LE(index, 1 + 32);
    if (isHardenedDerivation(index))
        throw new InvalidArgumentError('index', 'Public key can not be derived from a hardened index.');
    pk.copy(data, 1);
    data[0] = 0x02;
    const z = sodium.crypto_auth_hmacsha512(data, cc);
    data[0] = 0x03;
    const c = sodium.crypto_auth_hmacsha512(data, cc);
    const chainCode = c.slice(32, 64);
    const zl = z.slice(0, 32);
    const p = pointOfTrunc28Mul8(zl);
    return Buffer.concat([sodium.crypto_core_ed25519_add(p, pk), chainCode]);
};
//# sourceMappingURL=Bip32KeyDerivation.js.map