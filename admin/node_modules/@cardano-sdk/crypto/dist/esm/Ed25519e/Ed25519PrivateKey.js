var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Ed25519PrivateKey_keyMaterial;
import { Ed25519PrivateExtendedKeyHex, Ed25519PrivateNormalKeyHex } from '../hexTypes.js';
import { Ed25519PublicKey } from './Ed25519PublicKey.js';
import { Ed25519Signature } from './Ed25519Signature.js';
import { InvalidArgumentError } from '@cardano-sdk/util';
import sodium from 'libsodium-wrappers-sumo';
const SCALAR_INDEX = 0;
const SCALAR_SIZE = 32;
const IV_INDEX = 32;
const IV_SIZE = 32;
export const NORMAL_ED25519_PRIVATE_KEY_LENGTH = 32;
export const EXTENDED_ED25519_PRIVATE_KEY_LENGTH = 64;
const extendedScalar = (extendedKey) => extendedKey.slice(SCALAR_INDEX, SCALAR_SIZE);
const extendedIv = (extendedKey) => extendedKey.slice(IV_INDEX, IV_INDEX + IV_SIZE);
const signExtendedDetached = (extendedKey, message) => {
    const scalar = extendedScalar(extendedKey);
    const publicKey = sodium.crypto_scalarmult_ed25519_base_noclamp(scalar);
    const nonce = sodium.crypto_core_ed25519_scalar_reduce(sodium.crypto_hash_sha512(Buffer.concat([extendedIv(extendedKey), message])));
    const r = sodium.crypto_scalarmult_ed25519_base_noclamp(nonce);
    let hram = sodium.crypto_hash_sha512(Buffer.concat([r, publicKey, message]));
    hram = sodium.crypto_core_ed25519_scalar_reduce(hram);
    return Buffer.concat([
        r,
        sodium.crypto_core_ed25519_scalar_add(sodium.crypto_core_ed25519_scalar_mul(hram, scalar), nonce)
    ]);
};
export var Ed25519PrivateKeyType;
(function (Ed25519PrivateKeyType) {
    Ed25519PrivateKeyType["Normal"] = "Normal";
    Ed25519PrivateKeyType["Extended"] = "Extended";
})(Ed25519PrivateKeyType || (Ed25519PrivateKeyType = {}));
export class Ed25519PrivateKey {
    constructor(keyMaterial, type) {
        _Ed25519PrivateKey_keyMaterial.set(this, void 0);
        __classPrivateFieldSet(this, _Ed25519PrivateKey_keyMaterial, keyMaterial, "f");
        this.__type = type;
    }
    async toPublic() {
        await sodium.ready;
        return Ed25519PublicKey.fromBytes(this.__type === Ed25519PrivateKeyType.Extended
            ? sodium.crypto_scalarmult_ed25519_base_noclamp(extendedScalar(__classPrivateFieldGet(this, _Ed25519PrivateKey_keyMaterial, "f")))
            : sodium.crypto_sign_seed_keypair(__classPrivateFieldGet(this, _Ed25519PrivateKey_keyMaterial, "f")).publicKey);
    }
    async sign(message) {
        await sodium.ready;
        return Ed25519Signature.fromBytes(this.__type === Ed25519PrivateKeyType.Extended
            ? signExtendedDetached(__classPrivateFieldGet(this, _Ed25519PrivateKey_keyMaterial, "f"), Buffer.from(message, 'hex'))
            : sodium.crypto_sign_detached(Buffer.from(message, 'hex'), Buffer.concat([__classPrivateFieldGet(this, _Ed25519PrivateKey_keyMaterial, "f"), (await this.toPublic()).bytes()])));
    }
    static fromNormalBytes(keyMaterial) {
        if (keyMaterial.length !== NORMAL_ED25519_PRIVATE_KEY_LENGTH)
            throw new InvalidArgumentError('keyMaterial', `Key should be ${NORMAL_ED25519_PRIVATE_KEY_LENGTH} bytes; however ${keyMaterial.length} bytes were provided.`);
        return new Ed25519PrivateKey(keyMaterial, Ed25519PrivateKeyType.Normal);
    }
    static fromExtendedBytes(keyMaterial) {
        if (keyMaterial.length !== EXTENDED_ED25519_PRIVATE_KEY_LENGTH)
            throw new InvalidArgumentError('keyMaterial', `Key should be ${EXTENDED_ED25519_PRIVATE_KEY_LENGTH} bytes; however ${keyMaterial.length} bytes were provided.`);
        return new Ed25519PrivateKey(keyMaterial, Ed25519PrivateKeyType.Extended);
    }
    static fromNormalHex(keyMaterial) {
        return Ed25519PrivateKey.fromNormalBytes(Buffer.from(keyMaterial, 'hex'));
    }
    static fromExtendedHex(keyMaterial) {
        return Ed25519PrivateKey.fromExtendedBytes(Buffer.from(keyMaterial, 'hex'));
    }
    bytes() {
        return __classPrivateFieldGet(this, _Ed25519PrivateKey_keyMaterial, "f");
    }
    hex() {
        return this.__type === Ed25519PrivateKeyType.Extended
            ? Ed25519PrivateExtendedKeyHex(Buffer.from(__classPrivateFieldGet(this, _Ed25519PrivateKey_keyMaterial, "f")).toString('hex'))
            : Ed25519PrivateNormalKeyHex(Buffer.from(__classPrivateFieldGet(this, _Ed25519PrivateKey_keyMaterial, "f")).toString('hex'));
    }
}
_Ed25519PrivateKey_keyMaterial = new WeakMap();
//# sourceMappingURL=Ed25519PrivateKey.js.map